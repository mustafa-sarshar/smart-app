(self.webpackChunksmart_app=self.webpackChunksmart_app||[]).push([[179],{335:(It,Dt,fe)=>{"use strict";var Ue={};fe.r(Ue),fe.d(Ue,{assertParamsValid:()=>F1,computeFlatOffset:()=>$1,computeOutShape:()=>P1,getNormalizedAxes:()=>Zxe,isSliceContinous:()=>L1,maskToAxes:()=>Xxe,parseSliceParams:()=>Tx,sliceInfo:()=>V1,startForAxis:()=>j4,startIndicesWithElidedDims:()=>z4,stopForAxis:()=>W4,stopIndicesWithElidedDims:()=>U4,stridesForAxis:()=>H4,stridesWithElidedDims:()=>$4});var si={};fe.r(si),fe.d(si,{collectGatherOpShapeInfo:()=>$T,computeOutShape:()=>Yj,segOpComputeOptimalWindowSize:()=>qj});var We={};fe.r(We),fe.d(We,{ERF_A1:()=>DT,ERF_A2:()=>ST,ERF_A3:()=>kT,ERF_A4:()=>ET,ERF_A5:()=>IT,ERF_P:()=>CT,PARALLELIZE_THRESHOLD:()=>bT,RowPartitionType:()=>qs,SELU_SCALE:()=>qx,SELU_SCALEALPHA:()=>Gx,applyActivation:()=>Ux,assertAndGetBroadcastShape:()=>Je,assertAxesAreInnerMostDims:()=>Hi,assertParamsConsistent:()=>_T,assignToTypedArray:()=>Mj,axesAreInnerMostDims:()=>K1,calculateShapes:()=>mg,checkEinsumDimSizes:()=>RT,checkPadOnDimRoundingMode:()=>mr,combineLocations:()=>ej,combineRaggedTensorToTensorShapes:()=>Cj,complexWithEvenIndex:()=>Tj,complexWithOddIndex:()=>Aj,computeConv2DInfo:()=>Ti,computeConv3DInfo:()=>Ll,computeDefaultPad:()=>z1,computeDilation2DInfo:()=>ng,computeOptimalWindowSize:()=>Wx,computeOutAndReduceShapes:()=>Ai,computeOutShape:()=>ta,computePool2DInfo:()=>Hs,computePool3DInfo:()=>Ua,convertConv2DDataFormat:()=>Ha,decodeEinsumEquation:()=>MT,eitherStridesOrDilationsAreOne:()=>Ui,expandShapeToKeepDim:()=>Kn,exponent:()=>Rj,exponents:()=>Nj,fromStringArrayToUint8:()=>Kj,fromUint8ToStringArray:()=>dd,getAxesPermutation:()=>Rn,getBroadcastDims:()=>ch,getComplexWithIndex:()=>TT,getEinsumComputePath:()=>OT,getEinsumPermutation:()=>NT,getFusedBiasGradient:()=>zx,getFusedDyActivation:()=>Bx,getImageCenter:()=>yT,getInnerMostAxes:()=>Xn,getPermuted:()=>pg,getRaggedRank:()=>Sj,getReductionAxes:()=>hi,getReshaped:()=>hg,getReshapedPermuted:()=>fg,getRowPartitionTypesHelper:()=>Dj,getSliceBeginCoords:()=>vT,getSliceSize:()=>xT,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Pj,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Lj,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>$j,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>zj,getSparseReshapeInputOutputMismatchErrorMessage:()=>Hj,getSparseReshapeInputOutputMultipleErrorMessage:()=>Uj,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Vj,getSparseReshapeNegativeOutputDimErrorMessage:()=>Bj,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Gj,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>LT,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>jj,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Wj,getUndoAxesPermutation:()=>Vl,isIdentityPermutation:()=>FT,log:()=>fve,mergeRealAndImagArrays:()=>qa,prepareAndValidate:()=>wT,prepareSplitSize:()=>PT,segment_util:()=>si,shouldFuse:()=>Hx,slice_util:()=>Ue,splitRealAndImagArrays:()=>Ij,stridesOrDilationsArePositive:()=>rd,tupleValuesAreOne:()=>$l,upcastType:()=>Gr,validateDefaultValueShape:()=>kj,validateInput:()=>WDe,validateUpdateShape:()=>Ej,warn:()=>hs});var xn={};function ke(n){return"function"==typeof n}function Ve(n){const e=n(i=>{Error.call(i),i.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}fe.r(xn),fe.d(xn,{addImpl:()=>p8,bincountImpl:()=>jA,bincountReduceImpl:()=>y8,castImpl:()=>h8,ceilImpl:()=>v8,concatImpl:()=>x8,equalImpl:()=>D8,expImpl:()=>k8,expm1Impl:()=>I8,floorImpl:()=>M8,gatherNdImpl:()=>N8,gatherV2Impl:()=>R8,greaterEqualImpl:()=>F8,greaterImpl:()=>O8,lessEqualImpl:()=>L8,lessImpl:()=>P8,linSpaceImpl:()=>$8,logImpl:()=>V8,maxImpl:()=>B8,maximumImpl:()=>U8,minimumImpl:()=>H8,multiplyImpl:()=>WA,negImpl:()=>W8,notEqualImpl:()=>G8,prodImpl:()=>X8,raggedGatherImpl:()=>Q8,raggedRangeImpl:()=>e6,raggedTensorToTensorImpl:()=>r6,rangeImpl:()=>s6,rsqrtImpl:()=>o6,scatterImpl:()=>kh,sigmoidImpl:()=>gAe,simpleAbsImpl:()=>m8,sliceImpl:()=>b8,sparseFillEmptyRowsImpl:()=>l6,sparseReshapeImpl:()=>c6,sparseSegmentReductionImpl:()=>ZA,sqrtImpl:()=>VFe,squaredDifferenceImpl:()=>d6,stridedSliceImpl:()=>u6,stringNGramsImpl:()=>h6,stringSplitImpl:()=>p6,stringToHashBucketFastImpl:()=>f6,subImpl:()=>T8,tileImpl:()=>m6,topKImpl:()=>_6,transposeImpl:()=>UA,uniqueImpl:()=>y6});const ot=Ve(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((i,r)=>`${r+1}) ${i.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function Se(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class U{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const s of e)s.remove(this);else e.remove(this);const{initialTeardown:i}=this;if(ke(i))try{i()}catch(s){t=s instanceof ot?s.errors:[s]}const{_finalizers:r}=this;if(r){this._finalizers=null;for(const s of r)try{te(s)}catch(o){t=t??[],o instanceof ot?t=[...t,...o.errors]:t.push(o)}}if(t)throw new ot(t)}}add(t){var e;if(t&&t!==this)if(this.closed)te(t);else{if(t instanceof U){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&Se(e,t)}remove(t){const{_finalizers:e}=this;e&&Se(e,t),t instanceof U&&t._removeParent(this)}}U.EMPTY=(()=>{const n=new U;return n.closed=!0,n})();const he=U.EMPTY;function _e(n){return n instanceof U||n&&"closed"in n&&ke(n.remove)&&ke(n.add)&&ke(n.unsubscribe)}function te(n){ke(n)?n():n.unsubscribe()}const de={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Ie={setTimeout(n,t,...e){const{delegate:i}=Ie;return i?.setTimeout?i.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=Ie;return(t?.clearTimeout||clearTimeout)(n)},delegate:void 0};function Oe(n){Ie.setTimeout(()=>{const{onUnhandledError:t}=de;if(!t)throw n;t(n)})}function qt(){}const Fi=Qr("C",void 0,void 0);function Qr(n,t,e){return{kind:n,value:t,error:e}}let gt=null;function Ot(n){if(de.useDeprecatedSynchronousErrorHandling){const t=!gt;if(t&&(gt={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:i}=gt;if(gt=null,e)throw i}}else n()}class le extends U{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,_e(t)&&t.add(this)):this.destination=Qn}static create(t,e,i){return new Be(t,e,i)}next(t){this.isStopped?zt(function Ao(n){return Qr("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?zt(function _i(n){return Qr("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?zt(Fi,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const J=Function.prototype.bind;function T(n,t){return J.call(n,t)}class ve{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(i){St(i)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(i){St(i)}else St(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){St(e)}}}class Be extends le{constructor(t,e,i){let r;if(super(),ke(t)||!t)r={next:t??void 0,error:e??void 0,complete:i??void 0};else{let s;this&&de.useDeprecatedNextContext?(s=Object.create(t),s.unsubscribe=()=>this.unsubscribe(),r={next:t.next&&T(t.next,s),error:t.error&&T(t.error,s),complete:t.complete&&T(t.complete,s)}):r=t}this.destination=new ve(r)}}function St(n){de.useDeprecatedSynchronousErrorHandling?function jt(n){de.useDeprecatedSynchronousErrorHandling&&gt&&(gt.errorThrown=!0,gt.error=n)}(n):Oe(n)}function zt(n,t){const{onStoppedNotification:e}=de;e&&Ie.setTimeout(()=>e(n,t))}const Qn={closed:!0,next:qt,error:function wt(n){throw n},complete:qt},zn="function"==typeof Symbol&&Symbol.observable||"@@observable";function wn(n){return n}function wr(n){return 0===n.length?wn:1===n.length?n[0]:function(e){return n.reduce((i,r)=>r(i),e)}}let Ze=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const i=new n;return i.source=this,i.operator=e,i}subscribe(e,i,r){const s=function oK(n){return n&&n instanceof le||function Td(n){return n&&ke(n.next)&&ke(n.error)&&ke(n.complete)}(n)&&_e(n)}(e)?e:new Be(e,i,r);return Ot(()=>{const{operator:o,source:a}=this;s.add(o?o.call(s,a):a?this._subscribe(s):this._trySubscribe(s))}),s}_trySubscribe(e){try{return this._subscribe(e)}catch(i){e.error(i)}}forEach(e,i){return new(i=er(i))((r,s)=>{const o=new Be({next:a=>{try{e(a)}catch(l){s(l),o.unsubscribe()}},error:s,complete:r});this.subscribe(o)})}_subscribe(e){var i;return null===(i=this.source)||void 0===i?void 0:i.subscribe(e)}[zn](){return this}pipe(...e){return wr(e)(this)}toPromise(e){return new(e=er(e))((i,r)=>{let s;this.subscribe(o=>s=o,o=>r(o),()=>i(s))})}}return n.create=t=>new n(t),n})();function er(n){var t;return null!==(t=n??de.Promise)&&void 0!==t?t:Promise}const aK=Ve(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let dt=(()=>{class n extends Ze{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const i=new eN(this,this);return i.operator=e,i}_throwIfClosed(){if(this.closed)throw new aK}next(e){Ot(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const i of this.currentObservers)i.next(e)}})}error(e){Ot(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:i}=this;for(;i.length;)i.shift().error(e)}})}complete(){Ot(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:i,isStopped:r,observers:s}=this;return i||r?he:(this.currentObservers=null,s.push(e),new U(()=>{this.currentObservers=null,Se(s,e)}))}_checkFinalizedStatuses(e){const{hasError:i,thrownError:r,isStopped:s}=this;i?e.error(r):s&&e.complete()}asObservable(){const e=new Ze;return e.source=this,e}}return n.create=(t,e)=>new eN(t,e),n})();class eN extends dt{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,i;null===(i=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===i||i.call(e,t)}error(t){var e,i;null===(i=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===i||i.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,i;return null!==(i=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==i?i:he}}function tN(n){return ke(n?.lift)}function Hn(n){return t=>{if(tN(t))return t.lift(function(e){try{return n(e,this)}catch(i){this.error(i)}});throw new TypeError("Unable to lift unknown Observable type")}}function Tn(n,t,e,i,r){return new lK(n,t,e,i,r)}class lK extends le{constructor(t,e,i,r,s,o){super(t),this.onFinalize=s,this.shouldUnsubscribe=o,this._next=e?function(a){try{e(a)}catch(l){t.error(l)}}:super._next,this._error=r?function(a){try{r(a)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=i?function(){try{i()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function Ye(n,t){return Hn((e,i)=>{let r=0;e.subscribe(Tn(i,s=>{i.next(n.call(t,s,r++))}))})}function dc(n){return this instanceof dc?(this.v=n,this):new dc(n)}function hK(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function rN(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],i=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&i>=n.length&&(n=void 0),{value:n&&n[i++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},i("next"),i("throw"),i("return"),e[Symbol.asyncIterator]=function(){return this},e);function i(s){e[s]=n[s]&&function(o){return new Promise(function(a,l){!function r(s,o,a,l){Promise.resolve(l).then(function(c){s({value:c,done:a})},o)}(a,l,(o=n[s](o)).done,o.value)})}}}const Ew=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function sN(n){return ke(n?.then)}function oN(n){return ke(n[zn])}function aN(n){return Symbol.asyncIterator&&ke(n?.[Symbol.asyncIterator])}function lN(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const cN=function fK(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function dN(n){return ke(n?.[cN])}function uN(n){return function uK(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,i=e.apply(n,t||[]),s=[];return r={},o("next"),o("throw"),o("return"),r[Symbol.asyncIterator]=function(){return this},r;function o(h){i[h]&&(r[h]=function(p){return new Promise(function(f,m){s.push([h,p,f,m])>1||a(h,p)})})}function a(h,p){try{!function l(h){h.value instanceof dc?Promise.resolve(h.value.v).then(c,d):u(s[0][2],h)}(i[h](p))}catch(f){u(s[0][3],f)}}function c(h){a("next",h)}function d(h){a("throw",h)}function u(h,p){h(p),s.shift(),s.length&&a(s[0][0],s[0][1])}}(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:i,done:r}=yield dc(e.read());if(r)return yield dc(void 0);yield yield dc(i)}}finally{e.releaseLock()}})}function hN(n){return ke(n?.getReader)}function Cr(n){if(n instanceof Ze)return n;if(null!=n){if(oN(n))return function mK(n){return new Ze(t=>{const e=n[zn]();if(ke(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(Ew(n))return function gK(n){return new Ze(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(sN(n))return function _K(n){return new Ze(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,Oe)})}(n);if(aN(n))return pN(n);if(dN(n))return function bK(n){return new Ze(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(hN(n))return function yK(n){return pN(uN(n))}(n)}throw lN(n)}function pN(n){return new Ze(t=>{(function vK(n,t){var e,i,r,s;return function cK(n,t,e,i){return new(e||(e=Promise))(function(s,o){function a(d){try{c(i.next(d))}catch(u){o(u)}}function l(d){try{c(i.throw(d))}catch(u){o(u)}}function c(d){d.done?s(d.value):function r(s){return s instanceof e?s:new e(function(o){o(s)})}(d.value).then(a,l)}c((i=i.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=hK(n);!(i=yield e.next()).done;)if(t.next(i.value),t.closed)return}catch(o){r={error:o}}finally{try{i&&!i.done&&(s=e.return)&&(yield s.call(e))}finally{if(r)throw r.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function ha(n,t,e,i=0,r=!1){const s=t.schedule(function(){e(),r?n.add(this.schedule(null,i)):this.unsubscribe()},i);if(n.add(s),!r)return s}function Pi(n,t,e=1/0){return ke(t)?Pi((i,r)=>Ye((s,o)=>t(i,s,r,o))(Cr(n(i,r))),e):("number"==typeof t&&(e=t),Hn((i,r)=>function xK(n,t,e,i,r,s,o,a){const l=[];let c=0,d=0,u=!1;const h=()=>{u&&!l.length&&!c&&t.complete()},p=m=>c<i?f(m):l.push(m),f=m=>{s&&t.next(m),c++;let g=!1;Cr(e(m,d++)).subscribe(Tn(t,_=>{r?.(_),s?p(_):t.next(_)},()=>{g=!0},void 0,()=>{if(g)try{for(c--;l.length&&c<i;){const _=l.shift();o?ha(t,o,()=>f(_)):f(_)}h()}catch(_){t.error(_)}}))};return n.subscribe(Tn(t,p,()=>{u=!0,h()})),()=>{a?.()}}(i,r,n,e)))}function Ad(n=1/0){return Pi(wn,n)}const Mo=new Ze(n=>n.complete());function fN(n){return n&&ke(n.schedule)}function Iw(n){return n[n.length-1]}function Kh(n){return fN(Iw(n))?n.pop():void 0}function gN(n,t=0){return Hn((e,i)=>{e.subscribe(Tn(i,r=>ha(i,n,()=>i.next(r),t),()=>ha(i,n,()=>i.complete(),t),r=>ha(i,n,()=>i.error(r),t)))})}function _N(n,t=0){return Hn((e,i)=>{i.add(n.schedule(()=>e.subscribe(i),t))})}function bN(n,t){if(!n)throw new Error("Iterable cannot be null");return new Ze(e=>{ha(e,t,()=>{const i=n[Symbol.asyncIterator]();ha(e,t,()=>{i.next().then(r=>{r.done?e.complete():e.next(r.value)})},0,!0)})})}function oi(n,t){return t?function TK(n,t){if(null!=n){if(oN(n))return function DK(n,t){return Cr(n).pipe(_N(t),gN(t))}(n,t);if(Ew(n))return function kK(n,t){return new Ze(e=>{let i=0;return t.schedule(function(){i===n.length?e.complete():(e.next(n[i++]),e.closed||this.schedule())})})}(n,t);if(sN(n))return function SK(n,t){return Cr(n).pipe(_N(t),gN(t))}(n,t);if(aN(n))return bN(n,t);if(dN(n))return function EK(n,t){return new Ze(e=>{let i;return ha(e,t,()=>{i=n[cN](),ha(e,t,()=>{let r,s;try{({value:r,done:s}=i.next())}catch(o){return void e.error(o)}s?e.complete():e.next(r)},0,!0)}),()=>ke(i?.return)&&i.return()})}(n,t);if(hN(n))return function IK(n,t){return bN(uN(n),t)}(n,t)}throw lN(n)}(n,t):Cr(n)}function n_(...n){const t=Kh(n),e=function CK(n,t){return"number"==typeof Iw(n)?n.pop():t}(n,1/0),i=n;return i.length?1===i.length?Cr(i[0]):Ad(e)(oi(i,t)):Mo}function Tw(n,t,...e){if(!0===t)return void n();if(!1===t)return;const i=new Be({next:()=>{i.unsubscribe(),n()}});return Cr(t(...e)).subscribe(i)}function ln(n){for(let t in n)if(n[t]===ln)return t;throw Error("Could not find renamed property on target object.")}function Aw(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function gn(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(gn).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function Mw(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const AK=ln({__forward_ref__:ln});function Jt(n){return n.__forward_ref__=Jt,n.toString=function(){return gn(this())},n}function He(n){return Nw(n)?n():n}function Nw(n){return"function"==typeof n&&n.hasOwnProperty(AK)&&n.__forward_ref__===Jt}function Rw(n){return n&&!!n.\u0275providers}class Q extends Error{constructor(t,e){super(r_(t,e)),this.code=t}}function r_(n,t){return`NG0${Math.abs(n)}${t?": "+t.trim():""}`}function nt(n){return"string"==typeof n?n:null==n?"":String(n)}function s_(n,t){throw new Q(-201,!1)}function Ds(n,t){null==n&&function Kt(n,t,e,i){throw new Error(`ASSERTION ERROR: ${n}`+(null==i?"":` [Expected=> ${e} ${i} ${t} <=Actual]`))}(t,n,null,"!=")}function me(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function at(n){return{providers:n.providers||[],imports:n.imports||[]}}function o_(n){return vN(n,a_)||vN(n,wN)}function vN(n,t){return n.hasOwnProperty(t)?n[t]:null}function xN(n){return n&&(n.hasOwnProperty(Ow)||n.hasOwnProperty(VK))?n[Ow]:null}const a_=ln({\u0275prov:ln}),Ow=ln({\u0275inj:ln}),wN=ln({ngInjectableDef:ln}),VK=ln({ngInjectorDef:ln});var je=(()=>((je=je||{})[je.Default=0]="Default",je[je.Host=1]="Host",je[je.Self=2]="Self",je[je.SkipSelf=4]="SkipSelf",je[je.Optional=8]="Optional",je))();let Fw;function Ss(n){const t=Fw;return Fw=n,t}function CN(n,t,e){const i=o_(n);return i&&"root"==i.providedIn?void 0===i.value?i.value=i.factory():i.value:e&je.Optional?null:void 0!==t?t:void s_(gn(n))}const Cn=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),Xh={},Pw="__NG_DI_FLAG__",l_="ngTempTokenPath",zK="ngTokenPath",UK=/\n/gm,HK="\u0275",DN="__source";let Zh;function Md(n){const t=Zh;return Zh=n,t}function jK(n,t=je.Default){if(void 0===Zh)throw new Q(-203,!1);return null===Zh?CN(n,void 0,t):Zh.get(n,t&je.Optional?null:void 0,t)}function Y(n,t=je.Default){return(function BK(){return Fw}()||jK)(He(n),t)}function lt(n,t=je.Default){return Y(n,c_(t))}function c_(n){return typeof n>"u"||"number"==typeof n?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function Lw(n){const t=[];for(let e=0;e<n.length;e++){const i=He(n[e]);if(Array.isArray(i)){if(0===i.length)throw new Q(900,!1);let r,s=je.Default;for(let o=0;o<i.length;o++){const a=i[o],l=WK(a);"number"==typeof l?-1===l?r=a.token:s|=l:r=a}t.push(Y(r,s))}else t.push(Y(i))}return t}function Qh(n,t){return n[Pw]=t,n.prototype[Pw]=t,n}function WK(n){return n[Pw]}function el(n){return{toString:n}.toString()}var to=(()=>((to=to||{})[to.OnPush=0]="OnPush",to[to.Default=1]="Default",to))(),no=(()=>{return(n=no||(no={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",no;var n})();const pa={},Wt=[],d_=ln({\u0275cmp:ln}),$w=ln({\u0275dir:ln}),Vw=ln({\u0275pipe:ln}),kN=ln({\u0275mod:ln}),fa=ln({\u0275fac:ln}),Jh=ln({__NG_ELEMENT_ID__:ln});let YK=0;function bi(n){return el(()=>{const e=!0===n.standalone,i={},r={type:n.type,providersResolver:null,decls:n.decls,vars:n.vars,factory:null,template:n.template||null,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:i,inputs:null,outputs:null,exportAs:n.exportAs||null,onPush:n.changeDetection===to.OnPush,directiveDefs:null,pipeDefs:null,standalone:e,dependencies:e&&n.dependencies||null,getStandaloneInjector:null,selectors:n.selectors||Wt,viewQuery:n.viewQuery||null,features:n.features||null,data:n.data||{},encapsulation:n.encapsulation||no.Emulated,id:"c"+YK++,styles:n.styles||Wt,_:null,setInput:null,schemas:n.schemas||null,tView:null,findHostDirectiveDefs:null,hostDirectives:null},s=n.dependencies,o=n.features;return r.inputs=TN(n.inputs,i),r.outputs=TN(n.outputs),o&&o.forEach(a=>a(r)),r.directiveDefs=s?()=>("function"==typeof s?s():s).map(EN).filter(IN):null,r.pipeDefs=s?()=>("function"==typeof s?s():s).map(Dr).filter(IN):null,r})}function EN(n){return Xt(n)||tr(n)}function IN(n){return null!==n}function ut(n){return el(()=>({type:n.type,bootstrap:n.bootstrap||Wt,declarations:n.declarations||Wt,imports:n.imports||Wt,exports:n.exports||Wt,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function TN(n,t){if(null==n)return pa;const e={};for(const i in n)if(n.hasOwnProperty(i)){let r=n[i],s=r;Array.isArray(r)&&(s=r[1],r=r[0]),e[r]=i,t&&(t[r]=s)}return e}const we=bi;function Xt(n){return n[d_]||null}function tr(n){return n[$w]||null}function Dr(n){return n[Vw]||null}function es(n,t){const e=n[kN]||null;if(!e&&!0===t)throw new Error(`Type ${gn(n)} does not have '\u0275mod' property.`);return e}const ma=0,Ee=1,ht=2,jn=3,ro=4,uc=5,nr=6,Rd=7,Jn=8,u_=9,h_=10,_t=11,Bw=12,ep=13,AN=14,Od=15,ir=16,tp=17,Fd=18,No=19,np=20,MN=21,Dn=22,zw=1,NN=2,p_=7,f_=8,Pd=9,Sr=10;function ts(n){return Array.isArray(n)&&"object"==typeof n[zw]}function so(n){return Array.isArray(n)&&!0===n[zw]}function Uw(n){return 0!=(4&n.flags)}function ip(n){return n.componentOffset>-1}function m_(n){return 1==(1&n.flags)}function oo(n){return null!==n.template}function ZK(n){return 0!=(256&n[ht])}function hc(n,t){return n.hasOwnProperty(fa)?n[fa]:null}class eX{constructor(t,e,i){this.previousValue=t,this.currentValue=e,this.firstChange=i}isFirstChange(){return this.firstChange}}function rr(){return FN}function FN(n){return n.type.prototype.ngOnChanges&&(n.setInput=nX),tX}function tX(){const n=LN(this),t=n?.current;if(t){const e=n.previous;if(e===pa)n.previous=t;else for(let i in t)e[i]=t[i];n.current=null,this.ngOnChanges(t)}}function nX(n,t,e,i){const r=this.declaredInputs[e],s=LN(n)||function iX(n,t){return n[PN]=t}(n,{previous:pa,current:null}),o=s.current||(s.current={}),a=s.previous,l=a[r];o[r]=new eX(l&&l.currentValue,t,a===pa),n[i]=t}rr.ngInherit=!0;const PN="__ngSimpleChanges__";function LN(n){return n[PN]||null}const ks=function(n,t,e){};function Gi(n){for(;Array.isArray(n);)n=n[ma];return n}function g_(n,t){return Gi(t[n])}function ns(n,t){return Gi(t[n.index])}function BN(n,t){return n.data[t]}function is(n,t){const e=t[n];return ts(e)?e:e[ma]}function __(n){return 64==(64&n[ht])}function tl(n,t){return null==t?null:n[t]}function zN(n){n[Fd]=0}function jw(n,t){n[uc]+=t;let e=n,i=n[jn];for(;null!==i&&(1===t&&1===e[uc]||-1===t&&0===e[uc]);)i[uc]+=t,e=i,i=i[jn]}const it={lFrame:JN(null),bindingsEnabled:!0};function HN(){return it.bindingsEnabled}function oe(){return it.lFrame.lView}function Ft(){return it.lFrame.tView}function qi(){let n=GN();for(;null!==n&&64===n.type;)n=n.parent;return n}function GN(){return it.lFrame.currentTNode}function Ro(n,t){const e=it.lFrame;e.currentTNode=n,e.isParent=t}function Ww(){return it.lFrame.isParent}function Gw(){it.lFrame.isParent=!1}function $d(){return it.lFrame.bindingIndex++}function gX(n,t){const e=it.lFrame;e.bindingIndex=e.bindingRootIndex=n,qw(t)}function qw(n){it.lFrame.currentDirectiveIndex=n}function XN(){return it.lFrame.currentQueryIndex}function Kw(n){it.lFrame.currentQueryIndex=n}function bX(n){const t=n[Ee];return 2===t.type?t.declTNode:1===t.type?n[nr]:null}function ZN(n,t,e){if(e&je.SkipSelf){let r=t,s=n;for(;!(r=r.parent,null!==r||e&je.Host||(r=bX(s),null===r||(s=s[Od],10&r.type))););if(null===r)return!1;t=r,n=s}const i=it.lFrame=QN();return i.currentTNode=t,i.lView=n,!0}function Xw(n){const t=QN(),e=n[Ee];it.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function QN(){const n=it.lFrame,t=null===n?null:n.child;return null===t?JN(n):t}function JN(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function eR(){const n=it.lFrame;return it.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const tR=eR;function Zw(){const n=eR();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function Er(){return it.lFrame.selectedIndex}function pc(n){it.lFrame.selectedIndex=n}function Ln(){const n=it.lFrame;return BN(n.tView,n.selectedIndex)}function b_(n,t){for(let e=t.directiveStart,i=t.directiveEnd;e<i;e++){const s=n.data[e].type.prototype,{ngAfterContentInit:o,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:c,ngOnDestroy:d}=s;o&&(n.contentHooks||(n.contentHooks=[])).push(-e,o),a&&((n.contentHooks||(n.contentHooks=[])).push(e,a),(n.contentCheckHooks||(n.contentCheckHooks=[])).push(e,a)),l&&(n.viewHooks||(n.viewHooks=[])).push(-e,l),c&&((n.viewHooks||(n.viewHooks=[])).push(e,c),(n.viewCheckHooks||(n.viewCheckHooks=[])).push(e,c)),null!=d&&(n.destroyHooks||(n.destroyHooks=[])).push(e,d)}}function y_(n,t,e){rR(n,t,3,e)}function v_(n,t,e,i){(3&n[ht])===e&&rR(n,t,e,i)}function Qw(n,t){let e=n[ht];(3&e)===t&&(e&=2047,e+=1,n[ht]=e)}function rR(n,t,e,i){const s=i??-1,o=t.length-1;let a=0;for(let l=void 0!==i?65535&n[Fd]:0;l<o;l++)if("number"==typeof t[l+1]){if(a=t[l],null!=i&&a>=i)break}else t[l]<0&&(n[Fd]+=65536),(a<s||-1==s)&&(SX(n,e,t,l),n[Fd]=(4294901760&n[Fd])+l+2),l++}function SX(n,t,e,i){const r=e[i]<0,s=e[i+1],a=n[r?-e[i]:e[i]];if(r){if(n[ht]>>11<n[Fd]>>16&&(3&n[ht])===t){n[ht]+=2048,ks(4,a,s);try{s.call(a)}finally{ks(5,a,s)}}}else{ks(4,a,s);try{s.call(a)}finally{ks(5,a,s)}}}const Vd=-1;class sp{constructor(t,e,i){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=i}}function eC(n,t,e){let i=0;for(;i<e.length;){const r=e[i];if("number"==typeof r){if(0!==r)break;i++;const s=e[i++],o=e[i++],a=e[i++];n.setAttribute(t,o,a,s)}else{const s=r,o=e[++i];oR(s)?n.setProperty(t,s,o):n.setAttribute(t,s,o),i++}}return i}function sR(n){return 3===n||4===n||6===n}function oR(n){return 64===n.charCodeAt(0)}function op(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let i=0;i<t.length;i++){const r=t[i];"number"==typeof r?e=r:0===e||aR(n,e,r,null,-1===e||2===e?t[++i]:null)}}return n}function aR(n,t,e,i,r){let s=0,o=n.length;if(-1===t)o=-1;else for(;s<n.length;){const a=n[s++];if("number"==typeof a){if(a===t){o=-1;break}if(a>t){o=s-1;break}}}for(;s<n.length;){const a=n[s];if("number"==typeof a)break;if(a===e){if(null===i)return void(null!==r&&(n[s+1]=r));if(i===n[s+1])return void(n[s+2]=r)}s++,null!==i&&s++,null!==r&&s++}-1!==o&&(n.splice(o,0,t),s=o+1),n.splice(s++,0,e),null!==i&&n.splice(s++,0,i),null!==r&&n.splice(s++,0,r)}function lR(n){return n!==Vd}function x_(n){return 32767&n}function w_(n,t){let e=function TX(n){return n>>16}(n),i=t;for(;e>0;)i=i[Od],e--;return i}let tC=!0;function C_(n){const t=tC;return tC=n,t}const cR=255,dR=5;let AX=0;const Oo={};function D_(n,t){const e=uR(n,t);if(-1!==e)return e;const i=t[Ee];i.firstCreatePass&&(n.injectorIndex=t.length,nC(i.data,n),nC(t,null),nC(i.blueprint,null));const r=iC(n,t),s=n.injectorIndex;if(lR(r)){const o=x_(r),a=w_(r,t),l=a[Ee].data;for(let c=0;c<8;c++)t[s+c]=a[o+c]|l[o+c]}return t[s+8]=r,s}function nC(n,t){n.push(0,0,0,0,0,0,0,0,t)}function uR(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function iC(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,i=null,r=t;for(;null!==r;){if(i=bR(r),null===i)return Vd;if(e++,r=r[Od],-1!==i.injectorIndex)return i.injectorIndex|e<<16}return Vd}function rC(n,t,e){!function MX(n,t,e){let i;"string"==typeof e?i=e.charCodeAt(0)||0:e.hasOwnProperty(Jh)&&(i=e[Jh]),null==i&&(i=e[Jh]=AX++);const r=i&cR;t.data[n+(r>>dR)]|=1<<r}(n,t,e)}function hR(n,t,e){if(e&je.Optional||void 0!==n)return n;s_()}function pR(n,t,e,i){if(e&je.Optional&&void 0===i&&(i=null),!(e&(je.Self|je.Host))){const r=n[u_],s=Ss(void 0);try{return r?r.get(t,i,e&je.Optional):CN(t,i,e&je.Optional)}finally{Ss(s)}}return hR(i,0,e)}function fR(n,t,e,i=je.Default,r){if(null!==n){if(1024&t[ht]){const o=function PX(n,t,e,i,r){let s=n,o=t;for(;null!==s&&null!==o&&1024&o[ht]&&!(256&o[ht]);){const a=mR(s,o,e,i|je.Self,Oo);if(a!==Oo)return a;let l=s.parent;if(!l){const c=o[MN];if(c){const d=c.get(e,Oo,i);if(d!==Oo)return d}l=bR(o),o=o[Od]}s=l}return r}(n,t,e,i,Oo);if(o!==Oo)return o}const s=mR(n,t,e,i,Oo);if(s!==Oo)return s}return pR(t,e,i,r)}function mR(n,t,e,i,r){const s=function OX(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(Jh)?n[Jh]:void 0;return"number"==typeof t?t>=0?t&cR:FX:t}(e);if("function"==typeof s){if(!ZN(t,n,i))return i&je.Host?hR(r,0,i):pR(t,e,i,r);try{const o=s(i);if(null!=o||i&je.Optional)return o;s_()}finally{tR()}}else if("number"==typeof s){let o=null,a=uR(n,t),l=Vd,c=i&je.Host?t[ir][nr]:null;for((-1===a||i&je.SkipSelf)&&(l=-1===a?iC(n,t):t[a+8],l!==Vd&&_R(i,!1)?(o=t[Ee],a=x_(l),t=w_(l,t)):a=-1);-1!==a;){const d=t[Ee];if(gR(s,a,d.data)){const u=RX(a,t,e,o,i,c);if(u!==Oo)return u}l=t[a+8],l!==Vd&&_R(i,t[Ee].data[a+8]===c)&&gR(s,a,t)?(o=d,a=x_(l),t=w_(l,t)):a=-1}}return r}function RX(n,t,e,i,r,s){const o=t[Ee],a=o.data[n+8],d=S_(a,o,e,null==i?ip(a)&&tC:i!=o&&0!=(3&a.type),r&je.Host&&s===a);return null!==d?fc(t,o,d,a):Oo}function S_(n,t,e,i,r){const s=n.providerIndexes,o=t.data,a=1048575&s,l=n.directiveStart,d=s>>20,h=r?a+d:n.directiveEnd;for(let p=i?a:a+d;p<h;p++){const f=o[p];if(p<l&&e===f||p>=l&&f.type===e)return p}if(r){const p=o[l];if(p&&oo(p)&&p.type===e)return l}return null}function fc(n,t,e,i){let r=n[e];const s=t.data;if(function kX(n){return n instanceof sp}(r)){const o=r;o.resolving&&function MK(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new Q(-200,`Circular dependency in DI detected for ${n}${e}`)}(function Yt(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():nt(n)}(s[e]));const a=C_(o.canSeeViewProviders);o.resolving=!0;const l=o.injectImpl?Ss(o.injectImpl):null;ZN(n,i,je.Default);try{r=n[e]=o.factory(void 0,s,n,i),t.firstCreatePass&&e>=i.directiveStart&&function DX(n,t,e){const{ngOnChanges:i,ngOnInit:r,ngDoCheck:s}=t.type.prototype;if(i){const o=FN(t);(e.preOrderHooks||(e.preOrderHooks=[])).push(n,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,o)}r&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-n,r),s&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n,s),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,s))}(e,s[e],t)}finally{null!==l&&Ss(l),C_(a),o.resolving=!1,tR()}}return r}function gR(n,t,e){return!!(e[t+(n>>dR)]&1<<n)}function _R(n,t){return!(n&je.Self||n&je.Host&&t)}class Bd{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,i){return fR(this._tNode,this._lView,t,c_(i),e)}}function FX(){return new Bd(qi(),oe())}function sC(n){return Nw(n)?()=>{const t=sC(He(n));return t&&t()}:hc(n)}function bR(n){const t=n[Ee],e=t.type;return 2===e?t.declTNode:1===e?n[nr]:null}const Ud="__parameters__";function jd(n,t,e){return el(()=>{const i=function oC(n){return function(...e){if(n){const i=n(...e);for(const r in i)this[r]=i[r]}}}(t);function r(...s){if(this instanceof r)return i.apply(this,s),this;const o=new r(...s);return a.annotation=o,a;function a(l,c,d){const u=l.hasOwnProperty(Ud)?l[Ud]:Object.defineProperty(l,Ud,{value:[]})[Ud];for(;u.length<=d;)u.push(null);return(u[d]=u[d]||[]).push(o),l}}return e&&(r.prototype=Object.create(e.prototype)),r.prototype.ngMetadataName=n,r.annotationCls=r,r})}class ne{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=me({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function mc(n,t){n.forEach(e=>Array.isArray(e)?mc(e,t):t(e))}function vR(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function E_(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function cp(n,t){const e=[];for(let i=0;i<n;i++)e.push(t);return e}function rs(n,t,e){let i=Wd(n,t);return i>=0?n[1|i]=e:(i=~i,function BX(n,t,e,i){let r=n.length;if(r==t)n.push(e,i);else if(1===r)n.push(i,n[0]),n[0]=e;else{for(r--,n.push(n[r-1],n[r]);r>t;)n[r]=n[r-2],r--;n[t]=e,n[t+1]=i}}(n,i,t,e)),i}function lC(n,t){const e=Wd(n,t);if(e>=0)return n[1|e]}function Wd(n,t){return function xR(n,t,e){let i=0,r=n.length>>e;for(;r!==i;){const s=i+(r-i>>1),o=n[s<<e];if(t===o)return s<<e;o>t?r=s:i=s+1}return~(r<<e)}(n,t,1)}const T_=Qh(jd("Inject",n=>({token:n})),-1),Is=Qh(jd("Optional"),8),ba=Qh(jd("SkipSelf"),4);var Br=(()=>((Br=Br||{})[Br.Important=1]="Important",Br[Br.DashCase=2]="DashCase",Br))();const pC=new Map;let l7=0;const mC="__ngContext__";function sr(n,t){ts(t)?(n[mC]=t[np],function d7(n){pC.set(n[np],n)}(t)):n[mC]=t}let gC;function _C(n,t){return gC(n,t)}function pp(n){const t=n[jn];return so(t)?t[jn]:t}function bC(n){return zR(n[ep])}function yC(n){return zR(n[ro])}function zR(n){for(;null!==n&&!so(n);)n=n[ro];return n}function qd(n,t,e,i,r){if(null!=i){let s,o=!1;so(i)?s=i:ts(i)&&(o=!0,i=i[ma]);const a=Gi(i);0===n&&null!==e?null==r?qR(t,e,a):gc(t,e,a,r||null,!0):1===n&&null!==e?gc(t,e,a,r||null,!0):2===n?function kC(n,t,e){const i=N_(n,t);i&&function A7(n,t,e,i){n.removeChild(t,e,i)}(n,i,t,e)}(t,a,o):3===n&&t.destroyNode(a),null!=s&&function R7(n,t,e,i,r){const s=e[p_];s!==Gi(e)&&qd(t,n,i,s,r);for(let a=Sr;a<e.length;a++){const l=e[a];fp(l[Ee],l,n,t,i,s)}}(t,n,s,e,r)}}function xC(n,t,e){return n.createElement(t,e)}function HR(n,t){const e=n[Pd],i=e.indexOf(t),r=t[jn];512&t[ht]&&(t[ht]&=-513,jw(r,-1)),e.splice(i,1)}function wC(n,t){if(n.length<=Sr)return;const e=Sr+t,i=n[e];if(i){const r=i[tp];null!==r&&r!==n&&HR(r,i),t>0&&(n[e-1][ro]=i[ro]);const s=E_(n,Sr+t);!function w7(n,t){fp(n,t,t[_t],2,null,null),t[ma]=null,t[nr]=null}(i[Ee],i);const o=s[No];null!==o&&o.detachView(s[Ee]),i[jn]=null,i[ro]=null,i[ht]&=-65}return i}function jR(n,t){if(!(128&t[ht])){const e=t[_t];e.destroyNode&&fp(n,t,e,3,null,null),function S7(n){let t=n[ep];if(!t)return CC(n[Ee],n);for(;t;){let e=null;if(ts(t))e=t[ep];else{const i=t[Sr];i&&(e=i)}if(!e){for(;t&&!t[ro]&&t!==n;)ts(t)&&CC(t[Ee],t),t=t[jn];null===t&&(t=n),ts(t)&&CC(t[Ee],t),e=t&&t[ro]}t=e}}(t)}}function CC(n,t){if(!(128&t[ht])){t[ht]&=-65,t[ht]|=128,function T7(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let i=0;i<e.length;i+=2){const r=t[e[i]];if(!(r instanceof sp)){const s=e[i+1];if(Array.isArray(s))for(let o=0;o<s.length;o+=2){const a=r[s[o]],l=s[o+1];ks(4,a,l);try{l.call(a)}finally{ks(5,a,l)}}else{ks(4,r,s);try{s.call(r)}finally{ks(5,r,s)}}}}}(n,t),function I7(n,t){const e=n.cleanup,i=t[Rd];let r=-1;if(null!==e)for(let s=0;s<e.length-1;s+=2)if("string"==typeof e[s]){const o=e[s+3];o>=0?i[r=o]():i[r=-o].unsubscribe(),s+=2}else{const o=i[r=e[s+1]];e[s].call(o)}if(null!==i){for(let s=r+1;s<i.length;s++)(0,i[s])();t[Rd]=null}}(n,t),1===t[Ee].type&&t[_t].destroy();const e=t[tp];if(null!==e&&so(t[jn])){e!==t[jn]&&HR(e,t);const i=t[No];null!==i&&i.detachView(n)}!function u7(n){pC.delete(n[np])}(t)}}function WR(n,t,e){return function GR(n,t,e){let i=t;for(;null!==i&&40&i.type;)i=(t=i).parent;if(null===i)return e[ma];{const{componentOffset:r}=i;if(r>-1){const{encapsulation:s}=n.data[i.directiveStart+r];if(s===no.None||s===no.Emulated)return null}return ns(i,e)}}(n,t.parent,e)}function gc(n,t,e,i,r){n.insertBefore(t,e,i,r)}function qR(n,t,e){n.appendChild(t,e)}function YR(n,t,e,i,r){null!==i?gc(n,t,e,i,r):qR(n,t,e)}function N_(n,t){return n.parentNode(t)}function KR(n,t,e){return ZR(n,t,e)}let DC,TC,ZR=function XR(n,t,e){return 40&n.type?ns(n,e):null};function R_(n,t,e,i){const r=WR(n,i,t),s=t[_t],a=KR(i.parent||t[nr],i,t);if(null!=r)if(Array.isArray(e))for(let l=0;l<e.length;l++)YR(s,r,e[l],a,!1);else YR(s,r,e,a,!1);void 0!==DC&&DC(s,i,t,e,r)}function O_(n,t){if(null!==t){const e=t.type;if(3&e)return ns(t,n);if(4&e)return SC(-1,n[t.index]);if(8&e){const i=t.child;if(null!==i)return O_(n,i);{const r=n[t.index];return so(r)?SC(-1,r):Gi(r)}}if(32&e)return _C(t,n)()||Gi(n[t.index]);{const i=JR(n,t);return null!==i?Array.isArray(i)?i[0]:O_(pp(n[ir]),i):O_(n,t.next)}}return null}function JR(n,t){return null!==t?n[ir][nr].projection[t.projection]:null}function SC(n,t){const e=Sr+n+1;if(e<t.length){const i=t[e],r=i[Ee].firstChild;if(null!==r)return O_(i,r)}return t[p_]}function EC(n,t,e,i,r,s,o){for(;null!=e;){const a=i[e.index],l=e.type;if(o&&0===t&&(a&&sr(Gi(a),i),e.flags|=2),32!=(32&e.flags))if(8&l)EC(n,t,e.child,i,r,s,!1),qd(t,n,r,a,s);else if(32&l){const c=_C(e,i);let d;for(;d=c();)qd(t,n,r,d,s);qd(t,n,r,a,s)}else 16&l?eO(n,t,i,e,r,s):qd(t,n,r,a,s);e=o?e.projectionNext:e.next}}function fp(n,t,e,i,r,s){EC(e,i,n.firstChild,t,r,s,!1)}function eO(n,t,e,i,r,s){const o=e[ir],l=o[nr].projection[i.projection];if(Array.isArray(l))for(let c=0;c<l.length;c++)qd(t,n,r,l[c],s);else EC(n,t,l,o[jn],r,s,!0)}function tO(n,t,e){""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e)}function nO(n,t,e){const{mergedAttrs:i,classes:r,styles:s}=e;null!==i&&eC(n,t,i),null!==r&&tO(n,t,r),null!==s&&function F7(n,t,e){n.setAttribute(t,"style",e)}(n,t,s)}class _c{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}const V_=new ne("ENVIRONMENT_INITIALIZER"),_O=new ne("INJECTOR",-1),bO=new ne("INJECTOR_DEF_TYPES");class yO{get(t,e=Xh){if(e===Xh){const i=new Error(`NullInjectorError: No provider for ${gn(t)}!`);throw i.name="NullInjectorError",i}return e}}function p9(...n){return{\u0275providers:vO(0,n),\u0275fromNgModule:!0}}function vO(n,...t){const e=[],i=new Set;let r;return mc(t,s=>{const o=s;OC(o,e,[],i)&&(r||(r=[]),r.push(o))}),void 0!==r&&xO(r,e),e}function xO(n,t){for(let e=0;e<n.length;e++){const{providers:r}=n[e];FC(r,s=>{t.push(s)})}}function OC(n,t,e,i){if(!(n=He(n)))return!1;let r=null,s=xN(n);const o=!s&&Xt(n);if(s||o){if(o&&!o.standalone)return!1;r=n}else{const l=n.ngModule;if(s=xN(l),!s)return!1;r=l}const a=i.has(r);if(o){if(a)return!1;if(i.add(r),o.dependencies){const l="function"==typeof o.dependencies?o.dependencies():o.dependencies;for(const c of l)OC(c,t,e,i)}}else{if(!s)return!1;{if(null!=s.imports&&!a){let c;i.add(r);try{mc(s.imports,d=>{OC(d,t,e,i)&&(c||(c=[]),c.push(d))})}finally{}void 0!==c&&xO(c,t)}if(!a){const c=hc(r)||(()=>new r);t.push({provide:r,useFactory:c,deps:Wt},{provide:bO,useValue:r,multi:!0},{provide:V_,useValue:()=>Y(r),multi:!0})}const l=s.providers;null==l||a||FC(l,d=>{t.push(d)})}}return r!==n&&void 0!==n.providers}function FC(n,t){for(let e of n)Rw(e)&&(e=e.\u0275providers),Array.isArray(e)?FC(e,t):t(e)}const f9=ln({provide:String,useValue:ln});function PC(n){return null!==n&&"object"==typeof n&&f9 in n}function bc(n){return"function"==typeof n}const LC=new ne("Set Injector scope."),B_={},g9={};let $C;function z_(){return void 0===$C&&($C=new yO),$C}class va{}class DO extends va{get destroyed(){return this._destroyed}constructor(t,e,i,r){super(),this.parent=e,this.source=i,this.scopes=r,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,BC(t,o=>this.processProvider(o)),this.records.set(_O,Kd(void 0,this)),r.has("environment")&&this.records.set(va,Kd(void 0,this));const s=this.records.get(LC);null!=s&&"string"==typeof s.value&&this.scopes.add(s.value),this.injectorDefTypes=new Set(this.get(bO.multi,Wt,je.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const t of this._ngOnDestroyHooks)t.ngOnDestroy();for(const t of this._onDestroyHooks)t()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(t){this._onDestroyHooks.push(t)}runInContext(t){this.assertNotDestroyed();const e=Md(this),i=Ss(void 0);try{return t()}finally{Md(e),Ss(i)}}get(t,e=Xh,i=je.Default){this.assertNotDestroyed(),i=c_(i);const r=Md(this),s=Ss(void 0);try{if(!(i&je.SkipSelf)){let a=this.records.get(t);if(void 0===a){const l=function x9(n){return"function"==typeof n||"object"==typeof n&&n instanceof ne}(t)&&o_(t);a=l&&this.injectableDefInScope(l)?Kd(VC(t),B_):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(i&je.Self?z_():this.parent).get(t,e=i&je.Optional&&e===Xh?null:e)}catch(o){if("NullInjectorError"===o.name){if((o[l_]=o[l_]||[]).unshift(gn(t)),r)throw o;return function GK(n,t,e,i){const r=n[l_];throw t[DN]&&r.unshift(t[DN]),n.message=function qK(n,t,e,i=null){n=n&&"\n"===n.charAt(0)&&n.charAt(1)==HK?n.slice(2):n;let r=gn(t);if(Array.isArray(t))r=t.map(gn).join(" -> ");else if("object"==typeof t){let s=[];for(let o in t)if(t.hasOwnProperty(o)){let a=t[o];s.push(o+":"+("string"==typeof a?JSON.stringify(a):gn(a)))}r=`{${s.join(", ")}}`}return`${e}${i?"("+i+")":""}[${r}]: ${n.replace(UK,"\n  ")}`}("\n"+n.message,r,e,i),n[zK]=r,n[l_]=null,n}(o,t,"R3InjectorError",this.source)}throw o}finally{Ss(s),Md(r)}}resolveInjectorInitializers(){const t=Md(this),e=Ss(void 0);try{const i=this.get(V_.multi,Wt,je.Self);for(const r of i)r()}finally{Md(t),Ss(e)}}toString(){const t=[],e=this.records;for(const i of e.keys())t.push(gn(i));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Q(205,!1)}processProvider(t){let e=bc(t=He(t))?t:He(t&&t.provide);const i=function b9(n){return PC(n)?Kd(void 0,n.useValue):Kd(SO(n),B_)}(t);if(bc(t)||!0!==t.multi)this.records.get(e);else{let r=this.records.get(e);r||(r=Kd(void 0,B_,!0),r.factory=()=>Lw(r.multi),this.records.set(e,r)),e=t,r.multi.push(t)}this.records.set(e,i)}hydrate(t,e){return e.value===B_&&(e.value=g9,e.value=e.factory()),"object"==typeof e.value&&e.value&&function v9(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=He(t.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}}function VC(n){const t=o_(n),e=null!==t?t.factory:hc(n);if(null!==e)return e;if(n instanceof ne)throw new Q(204,!1);if(n instanceof Function)return function _9(n){const t=n.length;if(t>0)throw cp(t,"?"),new Q(204,!1);const e=function LK(n){const t=n&&(n[a_]||n[wN]);return t?(function $K(n){if(n.hasOwnProperty("name"))return n.name;(""+n).match(/^function\s*([^\s(]+)/)}(n),t):null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new Q(204,!1)}function SO(n,t,e){let i;if(bc(n)){const r=He(n);return hc(r)||VC(r)}if(PC(n))i=()=>He(n.useValue);else if(function CO(n){return!(!n||!n.useFactory)}(n))i=()=>n.useFactory(...Lw(n.deps||[]));else if(function wO(n){return!(!n||!n.useExisting)}(n))i=()=>Y(He(n.useExisting));else{const r=He(n&&(n.useClass||n.provide));if(!function y9(n){return!!n.deps}(n))return hc(r)||VC(r);i=()=>new r(...Lw(n.deps))}return i}function Kd(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function BC(n,t){for(const e of n)Array.isArray(e)?BC(e,t):e&&Rw(e)?BC(e.\u0275providers,t):t(e)}class w9{}class kO{}class D9{resolveComponentFactory(t){throw function C9(n){const t=Error(`No component factory found for ${gn(n)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=n,t}(t)}}let yc=(()=>{class n{}return n.NULL=new D9,n})();function S9(){return Xd(qi(),oe())}function Xd(n,t){return new Pt(ns(n,t))}let Pt=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=S9,n})();function k9(n){return n instanceof Pt?n.nativeElement:n}class _p{}let I9=(()=>{class n{}return n.\u0275prov=me({token:n,providedIn:"root",factory:()=>null}),n})();class vc{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const T9=new vc("15.2.1"),zC={},UC="ngOriginalError";function HC(n){return n[UC]}class nl{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&HC(t);for(;e&&HC(e);)e=HC(e);return e||null}}function wa(n){return n instanceof Function?n():n}function TO(n,t,e){let i=n.length;for(;;){const r=n.indexOf(t,e);if(-1===r)return r;if(0===r||n.charCodeAt(r-1)<=32){const s=t.length;if(r+s===i||n.charCodeAt(r+s)<=32)return r}e=r+1}}const AO="ng-template";function B9(n,t,e){let i=0;for(;i<n.length;){let r=n[i++];if(e&&"class"===r){if(r=n[i],-1!==TO(r.toLowerCase(),t,0))return!0}else if(1===r){for(;i<n.length&&"string"==typeof(r=n[i++]);)if(r.toLowerCase()===t)return!0;return!1}}return!1}function MO(n){return 4===n.type&&n.value!==AO}function z9(n,t,e){return t===(4!==n.type||e?n.value:AO)}function U9(n,t,e){let i=4;const r=n.attrs||[],s=function W9(n){for(let t=0;t<n.length;t++)if(sR(n[t]))return t;return n.length}(r);let o=!1;for(let a=0;a<t.length;a++){const l=t[a];if("number"!=typeof l){if(!o)if(4&i){if(i=2|1&i,""!==l&&!z9(n,l,e)||""===l&&1===t.length){if(ao(i))return!1;o=!0}}else{const c=8&i?l:t[++a];if(8&i&&null!==n.attrs){if(!B9(n.attrs,c,e)){if(ao(i))return!1;o=!0}continue}const u=H9(8&i?"class":l,r,MO(n),e);if(-1===u){if(ao(i))return!1;o=!0;continue}if(""!==c){let h;h=u>s?"":r[u+1].toLowerCase();const p=8&i?h:null;if(p&&-1!==TO(p,c,0)||2&i&&c!==h){if(ao(i))return!1;o=!0}}}}else{if(!o&&!ao(i)&&!ao(l))return!1;if(o&&ao(l))continue;o=!1,i=l|1&i}}return ao(i)||o}function ao(n){return 0==(1&n)}function H9(n,t,e,i){if(null===t)return-1;let r=0;if(i||!e){let s=!1;for(;r<t.length;){const o=t[r];if(o===n)return r;if(3===o||6===o)s=!0;else{if(1===o||2===o){let a=t[++r];for(;"string"==typeof a;)a=t[++r];continue}if(4===o)break;if(0===o){r+=4;continue}}r+=s?1:2}return-1}return function G9(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const i=n[e];if("number"==typeof i)return-1;if(i===t)return e;e++}return-1}(t,n)}function NO(n,t,e=!1){for(let i=0;i<t.length;i++)if(U9(n,t[i],e))return!0;return!1}function q9(n,t){e:for(let e=0;e<t.length;e++){const i=t[e];if(n.length===i.length){for(let r=0;r<n.length;r++)if(n[r]!==i[r])continue e;return!0}}return!1}function RO(n,t){return n?":not("+t.trim()+")":t}function Y9(n){let t=n[0],e=1,i=2,r="",s=!1;for(;e<n.length;){let o=n[e];if("string"==typeof o)if(2&i){const a=n[++e];r+="["+o+(a.length>0?'="'+a+'"':"")+"]"}else 8&i?r+="."+o:4&i&&(r+=" "+o);else""!==r&&!ao(o)&&(t+=RO(s,r),r=""),i=o,s=s||!ao(i);e++}return""!==r&&(t+=RO(s,r)),t}const rt={};function xi(n){OO(Ft(),oe(),Er()+n,!1)}function OO(n,t,e,i){if(!i)if(3==(3&t[ht])){const s=n.preOrderCheckHooks;null!==s&&y_(t,s,e)}else{const s=n.preOrderHooks;null!==s&&v_(t,s,0,e)}pc(e)}function $O(n,t=null,e=null,i){const r=VO(n,t,e,i);return r.resolveInjectorInitializers(),r}function VO(n,t=null,e=null,i,r=new Set){const s=[e||Wt,p9(n)];return i=i||("object"==typeof n?void 0:gn(n)),new DO(s,t||z_(),i||null,r)}let Li=(()=>{class n{static create(e,i){if(Array.isArray(e))return $O({name:""},i,e,"");{const r=e.name??"";return $O({name:r},e.parent,e.providers,r)}}}return n.THROW_IF_NOT_FOUND=Xh,n.NULL=new yO,n.\u0275prov=me({token:n,providedIn:"any",factory:()=>Y(_O)}),n.__NG_ELEMENT_ID__=-1,n})();function V(n,t=je.Default){const e=oe();return null===e?Y(n,t):fR(qi(),e,He(n),t)}function bp(){throw new Error("invalid")}function GO(n,t){const e=n.contentQueries;if(null!==e)for(let i=0;i<e.length;i+=2){const s=e[i+1];if(-1!==s){const o=n.data[s];Kw(e[i]),o.contentQueries(2,t[s],s)}}}function H_(n,t,e,i,r,s,o,a,l,c,d){const u=t.blueprint.slice();return u[ma]=r,u[ht]=76|i,(null!==d||n&&1024&n[ht])&&(u[ht]|=1024),zN(u),u[jn]=u[Od]=n,u[Jn]=e,u[h_]=o||n&&n[h_],u[_t]=a||n&&n[_t],u[Bw]=l||n&&n[Bw]||null,u[u_]=c||n&&n[u_]||null,u[nr]=s,u[np]=function c7(){return l7++}(),u[MN]=d,u[ir]=2==t.type?n[ir]:u,u}function Jd(n,t,e,i,r){let s=n.data[t];if(null===s)s=function YC(n,t,e,i,r){const s=GN(),o=Ww(),l=n.data[t]=function vZ(n,t,e,i,r,s){return{type:e,index:i,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:s,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,prev:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?s:s&&s.parent,e,t,i,r);return null===n.firstChild&&(n.firstChild=l),null!==s&&(o?null==s.child&&null!==l.parent&&(s.child=l):null===s.next&&(s.next=l,l.prev=s)),l}(n,t,e,i,r),function mX(){return it.lFrame.inI18n}()&&(s.flags|=32);else if(64&s.type){s.type=e,s.value=i,s.attrs=r;const o=function rp(){const n=it.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();s.injectorIndex=null===o?-1:o.injectorIndex}return Ro(s,!0),s}function yp(n,t,e,i){if(0===e)return-1;const r=t.length;for(let s=0;s<e;s++)t.push(i),n.blueprint.push(i),n.data.push(null);return r}function KC(n,t,e){Xw(t);try{const i=n.viewQuery;null!==i&&sD(1,i,e);const r=n.template;null!==r&&qO(n,t,r,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&GO(n,t),n.staticViewQueries&&sD(2,n.viewQuery,e);const s=n.components;null!==s&&function _Z(n,t){for(let e=0;e<t.length;e++)VZ(n,t[e])}(t,s)}catch(i){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),i}finally{t[ht]&=-5,Zw()}}function j_(n,t,e,i){const r=t[ht];if(128!=(128&r)){Xw(t);try{zN(t),function YN(n){return it.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&qO(n,t,e,2,i);const o=3==(3&r);if(o){const c=n.preOrderCheckHooks;null!==c&&y_(t,c,null)}else{const c=n.preOrderHooks;null!==c&&v_(t,c,0,null),Qw(t,0)}if(function LZ(n){for(let t=bC(n);null!==t;t=yC(t)){if(!t[NN])continue;const e=t[Pd];for(let i=0;i<e.length;i++){const r=e[i];512&r[ht]||jw(r[jn],1),r[ht]|=512}}}(t),function PZ(n){for(let t=bC(n);null!==t;t=yC(t))for(let e=Sr;e<t.length;e++){const i=t[e],r=i[Ee];__(i)&&j_(r,i,r.template,i[Jn])}}(t),null!==n.contentQueries&&GO(n,t),o){const c=n.contentCheckHooks;null!==c&&y_(t,c)}else{const c=n.contentHooks;null!==c&&v_(t,c,1),Qw(t,1)}!function mZ(n,t){const e=n.hostBindingOpCodes;if(null!==e)try{for(let i=0;i<e.length;i++){const r=e[i];if(r<0)pc(~r);else{const s=r,o=e[++i],a=e[++i];gX(o,s),a(2,t[s])}}}finally{pc(-1)}}(n,t);const a=n.components;null!==a&&function gZ(n,t){for(let e=0;e<t.length;e++)$Z(n,t[e])}(t,a);const l=n.viewQuery;if(null!==l&&sD(2,l,i),o){const c=n.viewCheckHooks;null!==c&&y_(t,c)}else{const c=n.viewHooks;null!==c&&v_(t,c,2),Qw(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),t[ht]&=-41,512&t[ht]&&(t[ht]&=-513,jw(t[jn],-1))}finally{Zw()}}}function qO(n,t,e,i,r){const s=Er(),o=2&i;try{pc(-1),o&&t.length>Dn&&OO(n,t,Dn,!1),ks(o?2:0,r),e(i,r)}finally{pc(s),ks(o?3:1,r)}}function XC(n,t,e){if(Uw(t)){const r=t.directiveEnd;for(let s=t.directiveStart;s<r;s++){const o=n.data[s];o.contentQueries&&o.contentQueries(1,e[s],s)}}}function ZC(n,t,e){HN()&&(function kZ(n,t,e,i){const r=e.directiveStart,s=e.directiveEnd;ip(e)&&function RZ(n,t,e){const i=ns(t,n),r=YO(e),s=n[h_],o=W_(n,H_(n,r,null,e.onPush?32:16,i,t,s,s.createRenderer(i,e),null,null,null));n[t.index]=o}(t,e,n.data[r+e.componentOffset]),n.firstCreatePass||D_(e,t),sr(i,t);const o=e.initialInputs;for(let a=r;a<s;a++){const l=n.data[a],c=fc(t,n,a,e);sr(c,t),null!==o&&OZ(0,a-r,c,l,0,o),oo(l)&&(is(e.index,t)[Jn]=fc(t,n,a,e))}}(n,t,e,ns(e,t)),64==(64&e.flags)&&eF(n,t,e))}function QC(n,t,e=ns){const i=t.localNames;if(null!==i){let r=t.index+1;for(let s=0;s<i.length;s+=2){const o=i[s+1],a=-1===o?e(t,n):n[o];n[r++]=a}}}function YO(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=JC(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts):t}function JC(n,t,e,i,r,s,o,a,l,c){const d=Dn+i,u=d+r,h=function bZ(n,t){const e=[];for(let i=0;i<t;i++)e.push(i<n?null:rt);return e}(d,u),p="function"==typeof c?c():c;return h[Ee]={type:n,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:t,data:h.slice().fill(null,d),bindingStartIndex:d,expandoStartIndex:u,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof s?s():s,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function KO(n,t,e,i){const r=nF(t);null===e?r.push(i):(r.push(e),n.firstCreatePass&&iF(n).push(i,r.length-1))}function XO(n,t,e,i){for(let r in n)if(n.hasOwnProperty(r)){e=null===e?{}:e;const s=n[r];null===i?ZO(e,t,r,s):i.hasOwnProperty(r)&&ZO(e,t,i[r],s)}return e}function ZO(n,t,e,i){n.hasOwnProperty(e)?n[e].push(t,i):n[e]=[t,i]}function os(n,t,e,i,r,s,o,a){const l=ns(t,e);let d,c=t.inputs;!a&&null!=c&&(d=c[i])?(oD(n,e,d,i,r),ip(t)&&QO(e,t.index)):3&t.type&&(i=function wZ(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(i),r=null!=o?o(r,t.value||"",i):r,s.setProperty(l,i,r))}function QO(n,t){const e=is(t,n);16&e[ht]||(e[ht]|=32)}function eD(n,t,e,i){if(HN()){const r=null===i?null:{"":-1},s=function IZ(n,t){const e=n.directiveRegistry;let i=null,r=null;if(e)for(let s=0;s<e.length;s++){const o=e[s];if(NO(t,o.selectors,!1))if(i||(i=[]),oo(o))if(null!==o.findHostDirectiveDefs){const a=[];r=r||new Map,o.findHostDirectiveDefs(o,a,r),i.unshift(...a,o),tD(n,t,a.length)}else i.unshift(o),tD(n,t,0);else r=r||new Map,o.findHostDirectiveDefs?.(o,i,r),i.push(o)}return null===i?null:[i,r]}(n,e);let o,a;null===s?o=a=null:[o,a]=s,null!==o&&JO(n,t,e,o,r,a),r&&function TZ(n,t,e){if(t){const i=n.localNames=[];for(let r=0;r<t.length;r+=2){const s=e[t[r+1]];if(null==s)throw new Q(-301,!1);i.push(t[r],s)}}}(e,i,r)}e.mergedAttrs=op(e.mergedAttrs,e.attrs)}function JO(n,t,e,i,r,s){for(let c=0;c<i.length;c++)rC(D_(e,t),n,i[c].type);!function MZ(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}(e,n.data.length,i.length);for(let c=0;c<i.length;c++){const d=i[c];d.providersResolver&&d.providersResolver(d)}let o=!1,a=!1,l=yp(n,t,i.length,null);for(let c=0;c<i.length;c++){const d=i[c];e.mergedAttrs=op(e.mergedAttrs,d.hostAttrs),NZ(n,e,t,l,d),AZ(l,d,r),null!==d.contentQueries&&(e.flags|=4),(null!==d.hostBindings||null!==d.hostAttrs||0!==d.hostVars)&&(e.flags|=64);const u=d.type.prototype;!o&&(u.ngOnChanges||u.ngOnInit||u.ngDoCheck)&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e.index),o=!0),!a&&(u.ngOnChanges||u.ngDoCheck)&&((n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e.index),a=!0),l++}!function xZ(n,t,e){const r=t.directiveEnd,s=n.data,o=t.attrs,a=[];let l=null,c=null;for(let d=t.directiveStart;d<r;d++){const u=s[d],h=e?e.get(u):null,f=h?h.outputs:null;l=XO(u.inputs,d,l,h?h.inputs:null),c=XO(u.outputs,d,c,f);const m=null===l||null===o||MO(t)?null:FZ(l,d,o);a.push(m)}null!==l&&(l.hasOwnProperty("class")&&(t.flags|=8),l.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=a,t.inputs=l,t.outputs=c}(n,e,s)}function eF(n,t,e){const i=e.directiveStart,r=e.directiveEnd,s=e.index,o=function _X(){return it.lFrame.currentDirectiveIndex}();try{pc(s);for(let a=i;a<r;a++){const l=n.data[a],c=t[a];qw(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&EZ(l,c)}}finally{pc(-1),qw(o)}}function EZ(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function tD(n,t,e){t.componentOffset=e,(n.components||(n.components=[])).push(t.index)}function AZ(n,t,e){if(e){if(t.exportAs)for(let i=0;i<t.exportAs.length;i++)e[t.exportAs[i]]=n;oo(t)&&(e[""]=n)}}function NZ(n,t,e,i,r){n.data[i]=r;const s=r.factory||(r.factory=hc(r.type)),o=new sp(s,oo(r),V);n.blueprint[i]=o,e[i]=o,function DZ(n,t,e,i,r){const s=r.hostBindings;if(s){let o=n.hostBindingOpCodes;null===o&&(o=n.hostBindingOpCodes=[]);const a=~t.index;(function SZ(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(o)!=a&&o.push(a),o.push(e,i,s)}}(n,t,i,yp(n,e,r.hostVars,rt),r)}function Po(n,t,e,i,r,s){const o=ns(n,t);!function nD(n,t,e,i,r,s,o){if(null==s)n.removeAttribute(t,r,e);else{const a=null==o?nt(s):o(s,i||"",r);n.setAttribute(t,r,a,e)}}(t[_t],o,s,n.value,e,i,r)}function OZ(n,t,e,i,r,s){const o=s[t];if(null!==o){const a=i.setInput;for(let l=0;l<o.length;){const c=o[l++],d=o[l++],u=o[l++];null!==a?i.setInput(e,u,c,d):e[d]=u}}}function FZ(n,t,e){let i=null,r=0;for(;r<e.length;){const s=e[r];if(0!==s)if(5!==s){if("number"==typeof s)break;if(n.hasOwnProperty(s)){null===i&&(i=[]);const o=n[s];for(let a=0;a<o.length;a+=2)if(o[a]===t){i.push(s,o[a+1],e[r+1]);break}}r+=2}else r+=2;else r+=4}return i}function tF(n,t,e,i){return[n,!0,!1,t,null,0,i,e,null,null]}function $Z(n,t){const e=is(t,n);if(__(e)){const i=e[Ee];48&e[ht]?j_(i,e,i.template,e[Jn]):e[uc]>0&&iD(e)}}function iD(n){for(let i=bC(n);null!==i;i=yC(i))for(let r=Sr;r<i.length;r++){const s=i[r];if(__(s))if(512&s[ht]){const o=s[Ee];j_(o,s,o.template,s[Jn])}else s[uc]>0&&iD(s)}const e=n[Ee].components;if(null!==e)for(let i=0;i<e.length;i++){const r=is(e[i],n);__(r)&&r[uc]>0&&iD(r)}}function VZ(n,t){const e=is(t,n),i=e[Ee];(function BZ(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])})(i,e),KC(i,e,e[Jn])}function W_(n,t){return n[ep]?n[AN][ro]=t:n[ep]=t,n[AN]=t,t}function rD(n){for(;n;){n[ht]|=32;const t=pp(n);if(ZK(n)&&!t)return n;n=t}return null}function G_(n,t,e,i=!0){const r=t[h_];r.begin&&r.begin();try{j_(n,t,n.template,e)}catch(o){throw i&&sF(t,o),o}finally{r.end&&r.end()}}function sD(n,t,e){Kw(0),t(n,e)}function nF(n){return n[Rd]||(n[Rd]=[])}function iF(n){return n.cleanup||(n.cleanup=[])}function sF(n,t){const e=n[u_],i=e?e.get(nl,null):null;i&&i.handleError(t)}function oD(n,t,e,i,r){for(let s=0;s<e.length;){const o=e[s++],a=e[s++],l=t[o],c=n.data[o];null!==c.setInput?c.setInput(l,r,i,a):l[a]=r}}function q_(n,t,e){let i=e?n.styles:null,r=e?n.classes:null,s=0;if(null!==t)for(let o=0;o<t.length;o++){const a=t[o];"number"==typeof a?s=a:1==s?r=Mw(r,a):2==s&&(i=Mw(i,a+": "+t[++o]+";"))}e?n.styles=i:n.stylesWithoutHost=i,e?n.classes=r:n.classesWithoutHost=r}function Y_(n,t,e,i,r=!1){for(;null!==e;){const s=t[e.index];if(null!==s&&i.push(Gi(s)),so(s))for(let a=Sr;a<s.length;a++){const l=s[a],c=l[Ee].firstChild;null!==c&&Y_(l[Ee],l,c,i)}const o=e.type;if(8&o)Y_(n,t,e.child,i);else if(32&o){const a=_C(e,t);let l;for(;l=a();)i.push(l)}else if(16&o){const a=JR(t,e);if(Array.isArray(a))i.push(...a);else{const l=pp(t[ir]);Y_(l[Ee],l,a,i,!0)}}e=r?e.projectionNext:e.next}return i}class vp{get rootNodes(){const t=this._lView,e=t[Ee];return Y_(e,t,e.firstChild,[])}constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[Jn]}set context(t){this._lView[Jn]=t}get destroyed(){return 128==(128&this._lView[ht])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[jn];if(so(t)){const e=t[f_],i=e?e.indexOf(this):-1;i>-1&&(wC(t,i),E_(e,i))}this._attachedToViewContainer=!1}jR(this._lView[Ee],this._lView)}onDestroy(t){KO(this._lView[Ee],this._lView,null,t)}markForCheck(){rD(this._cdRefInjectingView||this._lView)}detach(){this._lView[ht]&=-65}reattach(){this._lView[ht]|=64}detectChanges(){G_(this._lView[Ee],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Q(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function D7(n,t){fp(n,t,t[_t],2,null,null)}(this._lView[Ee],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Q(902,!1);this._appRef=t}}class zZ extends vp{constructor(t){super(t),this._view=t}detectChanges(){const t=this._view;G_(t[Ee],t,t[Jn],!1)}checkNoChanges(){}get context(){return null}}class oF extends yc{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=Xt(t);return new xp(e,this.ngModule)}}function aF(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class HZ{constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,i){i=c_(i);const r=this.injector.get(t,zC,i);return r!==zC||e===zC?r:this.parentInjector.get(t,e,i)}}class xp extends kO{get inputs(){return aF(this.componentDef.inputs)}get outputs(){return aF(this.componentDef.outputs)}constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function K9(n){return n.map(Y9).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}create(t,e,i,r){let s=(r=r||this.ngModule)instanceof va?r:r?.injector;s&&null!==this.componentDef.getStandaloneInjector&&(s=this.componentDef.getStandaloneInjector(s)||s);const o=s?new HZ(t,s):t,a=o.get(_p,null);if(null===a)throw new Q(407,!1);const l=o.get(I9,null),c=a.createRenderer(null,this.componentDef),d=this.componentDef.selectors[0][0]||"div",u=i?function yZ(n,t,e){return n.selectRootElement(t,e===no.ShadowDom)}(c,i,this.componentDef.encapsulation):xC(c,d,function UZ(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(d)),h=this.componentDef.onPush?288:272,p=JC(0,null,null,1,0,null,null,null,null,null),f=H_(null,p,null,h,null,null,a,c,l,o,null);let m,g;Xw(f);try{const _=this.componentDef;let b,y=null;_.findHostDirectiveDefs?(b=[],y=new Map,_.findHostDirectiveDefs(_,b,y),b.push(_)):b=[_];const v=function WZ(n,t){const e=n[Ee],i=Dn;return n[i]=t,Jd(e,i,2,"#host",null)}(f,u),x=function GZ(n,t,e,i,r,s,o,a){const l=r[Ee];!function qZ(n,t,e,i){for(const r of n)t.mergedAttrs=op(t.mergedAttrs,r.hostAttrs);null!==t.mergedAttrs&&(q_(t,t.mergedAttrs,!0),null!==e&&nO(i,e,t))}(i,n,t,o);const c=s.createRenderer(t,e),d=H_(r,YO(e),null,e.onPush?32:16,r[n.index],n,s,c,a||null,null,null);return l.firstCreatePass&&tD(l,n,i.length-1),W_(r,d),r[n.index]=d}(v,u,_,b,f,a,c);g=BN(p,Dn),u&&function KZ(n,t,e,i){if(i)eC(n,e,["ng-version",T9.full]);else{const{attrs:r,classes:s}=function X9(n){const t=[],e=[];let i=1,r=2;for(;i<n.length;){let s=n[i];if("string"==typeof s)2===r?""!==s&&t.push(s,n[++i]):8===r&&e.push(s);else{if(!ao(r))break;r=s}i++}return{attrs:t,classes:e}}(t.selectors[0]);r&&eC(n,e,r),s&&s.length>0&&tO(n,e,s.join(" "))}}(c,_,u,i),void 0!==e&&function XZ(n,t,e){const i=n.projection=[];for(let r=0;r<t.length;r++){const s=e[r];i.push(null!=s?Array.from(s):null)}}(g,this.ngContentSelectors,e),m=function YZ(n,t,e,i,r,s){const o=qi(),a=r[Ee],l=ns(o,r);JO(a,r,o,e,null,i);for(let d=0;d<e.length;d++)sr(fc(r,a,o.directiveStart+d,o),r);eF(a,r,o),l&&sr(l,r);const c=fc(r,a,o.directiveStart+o.componentOffset,o);if(n[Jn]=r[Jn]=c,null!==s)for(const d of s)d(c,t);return XC(a,o,n),c}(x,_,b,y,f,[ZZ]),KC(p,f,null)}finally{Zw()}return new jZ(this.componentType,m,Xd(g,f),f,g)}}class jZ extends w9{constructor(t,e,i,r,s){super(),this.location=i,this._rootLView=r,this._tNode=s,this.instance=e,this.hostView=this.changeDetectorRef=new zZ(r),this.componentType=t}setInput(t,e){const i=this._tNode.inputs;let r;if(null!==i&&(r=i[t])){const s=this._rootLView;oD(s[Ee],s,r,t,e),QO(s,this._tNode.index)}}get injector(){return new Bd(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}function ZZ(){const n=qi();b_(oe()[Ee],n)}function ct(n){let t=function lF(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const i=[n];for(;t;){let r;if(oo(n))r=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new Q(903,!1);r=t.\u0275dir}if(r){if(e){i.push(r);const o=n;o.inputs=aD(n.inputs),o.declaredInputs=aD(n.declaredInputs),o.outputs=aD(n.outputs);const a=r.hostBindings;a&&tQ(n,a);const l=r.viewQuery,c=r.contentQueries;if(l&&JZ(n,l),c&&eQ(n,c),Aw(n.inputs,r.inputs),Aw(n.declaredInputs,r.declaredInputs),Aw(n.outputs,r.outputs),oo(r)&&r.data.animation){const d=n.data;d.animation=(d.animation||[]).concat(r.data.animation)}}const s=r.features;if(s)for(let o=0;o<s.length;o++){const a=s[o];a&&a.ngInherit&&a(n),a===ct&&(e=!1)}}t=Object.getPrototypeOf(t)}!function QZ(n){let t=0,e=null;for(let i=n.length-1;i>=0;i--){const r=n[i];r.hostVars=t+=r.hostVars,r.hostAttrs=op(r.hostAttrs,e=op(e,r.hostAttrs))}}(i)}function aD(n){return n===pa?{}:n===Wt?[]:n}function JZ(n,t){const e=n.viewQuery;n.viewQuery=e?(i,r)=>{t(i,r),e(i,r)}:t}function eQ(n,t){const e=n.contentQueries;n.contentQueries=e?(i,r,s)=>{t(i,r,s),e(i,r,s)}:t}function tQ(n,t){const e=n.hostBindings;n.hostBindings=e?(i,r)=>{t(i,r),e(i,r)}:t}function or(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function $i(n,t,e,i){const r=oe();return or(r,$d(),t)&&(Ft(),Po(Ln(),r,n,t,e,i)),$i}function wi(n,t,e,i,r,s,o,a){const l=oe(),c=Ft(),d=n+Dn,u=c.firstCreatePass?function uQ(n,t,e,i,r,s,o,a,l){const c=t.consts,d=Jd(t,n,4,o||null,tl(c,a));eD(t,e,d,tl(c,l)),b_(t,d);const u=d.tViews=JC(2,d,i,r,s,t.directiveRegistry,t.pipeRegistry,null,t.schemas,c);return null!==t.queries&&(t.queries.template(t,d),u.queries=t.queries.embeddedTView(d)),d}(d,c,l,t,e,i,r,s,o):c.data[d];Ro(u,!1);const h=l[_t].createComment("");R_(c,l,h,u),sr(h,l),W_(l,l[d]=tF(h,l,h,u)),m_(u)&&ZC(c,l,u),null!=o&&QC(l,u,a)}function ai(n,t,e){const i=oe();return or(i,$d(),t)&&os(Ft(),Ln(),i,n,t,i[_t],e,!1),ai}function cD(n,t,e,i,r){const o=r?"class":"style";oD(n,e,t.inputs[o],o,i)}function kt(n,t,e,i){const r=oe(),s=Ft(),o=Dn+n,a=r[_t],l=s.firstCreatePass?function pQ(n,t,e,i,r,s){const o=t.consts,l=Jd(t,n,2,i,tl(o,r));return eD(t,e,l,tl(o,s)),null!==l.attrs&&q_(l,l.attrs,!1),null!==l.mergedAttrs&&q_(l,l.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,l),l}(o,s,r,t,e,i):s.data[o],c=r[o]=xC(a,t,function CX(){return it.lFrame.currentNamespace}()),d=m_(l);return Ro(l,!0),nO(a,c,l),32!=(32&l.flags)&&R_(s,r,c,l),0===function cX(){return it.lFrame.elementDepthCount}()&&sr(c,r),function dX(){it.lFrame.elementDepthCount++}(),d&&(ZC(s,r,l),XC(s,l,r)),null!==i&&QC(r,l),kt}function Lt(){let n=qi();Ww()?Gw():(n=n.parent,Ro(n,!1));const t=n;!function uX(){it.lFrame.elementDepthCount--}();const e=Ft();return e.firstCreatePass&&(b_(e,n),Uw(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function EX(n){return 0!=(8&n.flags)}(t)&&cD(e,t,oe(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function IX(n){return 0!=(16&n.flags)}(t)&&cD(e,t,oe(),t.stylesWithoutHost,!1),Lt}function Ci(n,t,e,i){return kt(n,t,e,i),Lt(),Ci}function Cp(n){return!!n&&"function"==typeof n.then}const hD=function CF(n){return!!n&&"function"==typeof n.subscribe};function An(n,t,e,i){const r=oe(),s=Ft(),o=qi();return function SF(n,t,e,i,r,s,o){const a=m_(i),c=n.firstCreatePass&&iF(n),d=t[Jn],u=nF(t);let h=!0;if(3&i.type||o){const m=ns(i,t),g=o?o(m):m,_=u.length,b=o?v=>o(Gi(v[i.index])):i.index;let y=null;if(!o&&a&&(y=function mQ(n,t,e,i){const r=n.cleanup;if(null!=r)for(let s=0;s<r.length-1;s+=2){const o=r[s];if(o===e&&r[s+1]===i){const a=t[Rd],l=r[s+2];return a.length>l?a[l]:null}"string"==typeof o&&(s+=2)}return null}(n,t,r,i.index)),null!==y)(y.__ngLastListenerFn__||y).__ngNextListenerFn__=s,y.__ngLastListenerFn__=s,h=!1;else{s=EF(i,t,d,s,!1);const v=e.listen(g,r,s);u.push(s,v),c&&c.push(r,b,_,_+1)}}else s=EF(i,t,d,s,!1);const p=i.outputs;let f;if(h&&null!==p&&(f=p[r])){const m=f.length;if(m)for(let g=0;g<m;g+=2){const x=t[f[g]][f[g+1]].subscribe(s),w=u.length;u.push(s,x),c&&c.push(r,i.index,w,-(w+1))}}}(s,r,r[_t],o,n,t,i),An}function kF(n,t,e,i){try{return ks(6,t,e),!1!==e(i)}catch(r){return sF(n,r),!1}finally{ks(7,t,e)}}function EF(n,t,e,i,r){return function s(o){if(o===Function)return i;rD(n.componentOffset>-1?is(n.index,t):t);let l=kF(t,e,i,o),c=s.__ngNextListenerFn__;for(;c;)l=kF(t,e,c,o)&&l,c=c.__ngNextListenerFn__;return r&&!1===l&&(o.preventDefault(),o.returnValue=!1),l}}function $o(n=1){return function yX(n){return(it.lFrame.contextLView=function vX(n,t){for(;n>0;)t=t[Od],n--;return t}(n,it.lFrame.contextLView))[Jn]}(n)}function gQ(n,t){let e=null;const i=function j9(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(!(1&e))return t[e+1]}return null}(n);for(let r=0;r<t.length;r++){const s=t[r];if("*"!==s){if(null===i?NO(n,s,!0):q9(i,s))return r}else e=r}return e}function rl(n){const t=oe()[ir][nr];if(!t.projection){const i=t.projection=cp(n?n.length:1,null),r=i.slice();let s=t.child;for(;null!==s;){const o=n?gQ(s,n):0;null!==o&&(r[o]?r[o].projectionNext=s:i[o]=s,r[o]=s),s=s.next}}}function Vi(n,t=0,e){const i=oe(),r=Ft(),s=Jd(r,Dn+n,16,null,e||null);null===s.projection&&(s.projection=t),Gw(),32!=(32&s.flags)&&function N7(n,t,e){eO(t[_t],0,t,e,WR(n,e,t),KR(e.parent||t[nr],e,t))}(r,i,s)}function Z_(n,t){return n<<17|t<<2}function sl(n){return n>>17&32767}function fD(n){return 2|n}function wc(n){return(131068&n)>>2}function mD(n,t){return-131069&n|t<<2}function gD(n){return 1|n}function LF(n,t,e,i,r){const s=n[e+1],o=null===t;let a=i?sl(s):wc(s),l=!1;for(;0!==a&&(!1===l||o);){const d=n[a+1];wQ(n[a],t)&&(l=!0,n[a+1]=i?gD(d):fD(d)),a=i?sl(d):wc(d)}l&&(n[e+1]=i?fD(s):gD(s))}function wQ(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&Wd(n,t)>=0}function _D(n,t,e){return lo(n,t,e,!1),_D}function ar(n,t){return lo(n,t,null,!0),ar}function lo(n,t,e,i){const r=oe(),s=Ft(),o=function _a(n){const t=it.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}(2);s.firstUpdatePass&&function WF(n,t,e,i){const r=n.data;if(null===r[e+1]){const s=r[Er()],o=function jF(n,t){return t>=n.expandoStartIndex}(n,e);(function KF(n,t){return 0!=(n.flags&(t?8:16))})(s,i)&&null===t&&!o&&(t=!1),t=function MQ(n,t,e,i){const r=function Yw(n){const t=it.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}(n);let s=i?t.residualClasses:t.residualStyles;if(null===r)0===(i?t.classBindings:t.styleBindings)&&(e=Dp(e=bD(null,n,t,e,i),t.attrs,i),s=null);else{const o=t.directiveStylingLast;if(-1===o||n[o]!==r)if(e=bD(r,n,t,e,i),null===s){let l=function NQ(n,t,e){const i=e?t.classBindings:t.styleBindings;if(0!==wc(i))return n[sl(i)]}(n,t,i);void 0!==l&&Array.isArray(l)&&(l=bD(null,n,t,l[1],i),l=Dp(l,t.attrs,i),function RQ(n,t,e,i){n[sl(e?t.classBindings:t.styleBindings)]=i}(n,t,i,l))}else s=function OQ(n,t,e){let i;const r=t.directiveEnd;for(let s=1+t.directiveStylingLast;s<r;s++)i=Dp(i,n[s].hostAttrs,e);return Dp(i,t.attrs,e)}(n,t,i)}return void 0!==s&&(i?t.residualClasses=s:t.residualStyles=s),e}(r,s,t,i),function vQ(n,t,e,i,r,s){let o=s?t.classBindings:t.styleBindings,a=sl(o),l=wc(o);n[i]=e;let d,c=!1;if(Array.isArray(e)?(d=e[1],(null===d||Wd(e,d)>0)&&(c=!0)):d=e,r)if(0!==l){const h=sl(n[a+1]);n[i+1]=Z_(h,a),0!==h&&(n[h+1]=mD(n[h+1],i)),n[a+1]=function bQ(n,t){return 131071&n|t<<17}(n[a+1],i)}else n[i+1]=Z_(a,0),0!==a&&(n[a+1]=mD(n[a+1],i)),a=i;else n[i+1]=Z_(l,0),0===a?a=i:n[l+1]=mD(n[l+1],i),l=i;c&&(n[i+1]=fD(n[i+1])),LF(n,d,i,!0),LF(n,d,i,!1),function xQ(n,t,e,i,r){const s=r?n.residualClasses:n.residualStyles;null!=s&&"string"==typeof t&&Wd(s,t)>=0&&(e[i+1]=gD(e[i+1]))}(t,d,n,i,s),o=Z_(a,l),s?t.classBindings=o:t.styleBindings=o}(r,s,t,e,o,i)}}(s,n,o,i),t!==rt&&or(r,o,t)&&function qF(n,t,e,i,r,s,o,a){if(!(3&t.type))return;const l=n.data,c=l[a+1],d=function yQ(n){return 1==(1&n)}(c)?YF(l,t,e,r,wc(c),o):void 0;Q_(d)||(Q_(s)||function _Q(n){return 2==(2&n)}(c)&&(s=YF(l,null,e,r,a,o)),function O7(n,t,e,i,r){if(t)r?n.addClass(e,i):n.removeClass(e,i);else{let s=-1===i.indexOf("-")?void 0:Br.DashCase;null==r?n.removeStyle(e,i,s):("string"==typeof r&&r.endsWith("!important")&&(r=r.slice(0,-10),s|=Br.Important),n.setStyle(e,i,r,s))}}(i,o,g_(Er(),e),r,s))}(s,s.data[Er()],r,r[_t],n,r[o+1]=function LQ(n,t){return null==n||("string"==typeof t?n+=t:"object"==typeof n&&(n=gn(function ss(n){return n instanceof _c?n.changingThisBreaksApplicationSecurity:n}(n)))),n}(t,e),i,o)}function bD(n,t,e,i,r){let s=null;const o=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<o&&(s=t[a],i=Dp(i,s.hostAttrs,r),s!==n);)a++;return null!==n&&(e.directiveStylingLast=a),i}function Dp(n,t,e){const i=e?1:2;let r=-1;if(null!==t)for(let s=0;s<t.length;s++){const o=t[s];"number"==typeof o?r=o:r===i&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),rs(n,o,!!e||t[++s]))}return void 0===n?null:n}function YF(n,t,e,i,r,s){const o=null===t;let a;for(;r>0;){const l=n[r],c=Array.isArray(l),d=c?l[1]:l,u=null===d;let h=e[r+1];h===rt&&(h=u?Wt:void 0);let p=u?lC(h,i):d===i?h:void 0;if(c&&!Q_(p)&&(p=lC(l,i)),Q_(p)&&(a=p,o))return a;const f=n[r+1];r=o?sl(f):wc(f)}if(null!==t){let l=s?t.residualClasses:t.residualStyles;null!=l&&(a=lC(l,i))}return a}function Q_(n){return void 0!==n}function as(n,t=""){const e=oe(),i=Ft(),r=n+Dn,s=i.firstCreatePass?Jd(i,r,1,t,null):i.data[r],o=e[r]=function vC(n,t){return n.createText(t)}(e[_t],t);R_(i,e,o,s),Ro(s,!1)}function yD(n){return J_("",n,""),yD}function J_(n,t,e){const i=oe(),r=function tu(n,t,e,i){return or(n,$d(),e)?t+nt(e)+i:rt}(i,n,t,e);return r!==rt&&function Ca(n,t,e){const i=g_(t,n);!function UR(n,t,e){n.setValue(t,e)}(n[_t],i,e)}(i,Er(),r),J_}function eb(n,t,e){const i=oe();return or(i,$d(),t)&&os(Ft(),Ln(),i,n,t,i[_t],e,!0),eb}const uu="en-US";let gP=uu;function wD(n,t,e,i,r){if(n=He(n),Array.isArray(n))for(let s=0;s<n.length;s++)wD(n[s],t,e,i,r);else{const s=Ft(),o=oe();let a=bc(n)?n:He(n.provide),l=SO(n);const c=qi(),d=1048575&c.providerIndexes,u=c.directiveStart,h=c.providerIndexes>>20;if(bc(n)||!n.multi){const p=new sp(l,r,V),f=DD(a,t,r?d:d+h,u);-1===f?(rC(D_(c,o),s,a),CD(s,n,t.length),t.push(a),c.directiveStart++,c.directiveEnd++,r&&(c.providerIndexes+=1048576),e.push(p),o.push(p)):(e[f]=p,o[f]=p)}else{const p=DD(a,t,d+h,u),f=DD(a,t,d,d+h),g=f>=0&&e[f];if(r&&!g||!r&&!(p>=0&&e[p])){rC(D_(c,o),s,a);const _=function tee(n,t,e,i,r){const s=new sp(n,e,V);return s.multi=[],s.index=t,s.componentProviders=0,zP(s,r,i&&!e),s}(r?eee:JJ,e.length,r,i,l);!r&&g&&(e[f].providerFactory=_),CD(s,n,t.length,0),t.push(a),c.directiveStart++,c.directiveEnd++,r&&(c.providerIndexes+=1048576),e.push(_),o.push(_)}else CD(s,n,p>-1?p:f,zP(e[r?f:p],l,!r&&i));!r&&i&&g&&e[f].componentProviders++}}}function CD(n,t,e,i){const r=bc(t),s=function m9(n){return!!n.useClass}(t);if(r||s){const l=(s?He(t.useClass):t).prototype.ngOnDestroy;if(l){const c=n.destroyHooks||(n.destroyHooks=[]);if(!r&&t.multi){const d=c.indexOf(e);-1===d?c.push(e,[i,l]):c[d+1].push(i,l)}else c.push(e,l)}}}function zP(n,t,e){return e&&n.componentProviders++,n.multi.push(t)-1}function DD(n,t,e,i){for(let r=e;r<i;r++)if(t[r]===n)return r;return-1}function JJ(n,t,e,i){return SD(this.multi,[])}function eee(n,t,e,i){const r=this.multi;let s;if(this.providerFactory){const o=this.providerFactory.componentProviders,a=fc(e,e[Ee],this.providerFactory.index,i);s=a.slice(0,o),SD(r,s);for(let l=o;l<a.length;l++)s.push(a[l])}else s=[],SD(r,s);return s}function SD(n,t){for(let e=0;e<n.length;e++)t.push((0,n[e])());return t}function rn(n,t=[]){return e=>{e.providersResolver=(i,r)=>function QJ(n,t,e){const i=Ft();if(i.firstCreatePass){const r=oo(n);wD(e,i.data,i.blueprint,r,!0),wD(t,i.data,i.blueprint,r,!1)}}(i,r?r(n):n,t)}}class hu{}class UP{}class HP extends hu{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new oF(this);const i=es(t);this._bootstrapComponents=wa(i.bootstrap),this._r3Injector=VO(t,e,[{provide:hu,useValue:this},{provide:yc,useValue:this.componentFactoryResolver}],gn(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class kD extends UP{constructor(t){super(),this.moduleType=t}create(t){return new HP(this.moduleType,t)}}class iee extends hu{constructor(t,e,i){super(),this.componentFactoryResolver=new oF(this),this.instance=null;const r=new DO([...t,{provide:hu,useValue:this},{provide:yc,useValue:this.componentFactoryResolver}],e||z_(),i,new Set(["environment"]));this.injector=r,r.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}}function sb(n,t,e=null){return new iee(n,t,e).injector}let ree=(()=>{class n{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const i=vO(0,e.type),r=i.length>0?sb([i],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,r)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return n.\u0275prov=me({token:n,providedIn:"environment",factory:()=>new n(Y(va))}),n})();function ED(n){n.getStandaloneInjector=t=>t.get(ree).getOrCreateStandaloneInjector(n)}function TD(n){return t=>{setTimeout(n,void 0,t)}}const $t=class Aee extends dt{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,i){let r=t,s=e||(()=>null),o=i;if(t&&"object"==typeof t){const l=t;r=l.next?.bind(l),s=l.error?.bind(l),o=l.complete?.bind(l)}this.__isAsync&&(s=TD(s),r&&(r=TD(r)),o&&(o=TD(o)));const a=super.subscribe({next:r,error:s,complete:o});return t instanceof U&&t.add(a),a}};function Mee(){return this._results[Symbol.iterator]()}class Np{get changes(){return this._changes||(this._changes=new $t)}constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=Np.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=Mee)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const i=this;i.dirty=!1;const r=function Es(n){return n.flat(Number.POSITIVE_INFINITY)}(t);(this._changesDetected=!function $X(n,t,e){if(n.length!==t.length)return!1;for(let i=0;i<n.length;i++){let r=n[i],s=t[i];if(e&&(r=e(r),s=e(s)),s!==r)return!1}return!0}(i._results,r,e))&&(i._results=r,i.length=r.length,i.last=r[this.length-1],i.first=r[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let zo=(()=>{class n{}return n.__NG_ELEMENT_ID__=Oee,n})();const Nee=zo,Ree=class extends Nee{constructor(t,e,i){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=i}createEmbeddedView(t,e){const i=this._declarationTContainer.tViews,r=H_(this._declarationLView,i,t,16,null,i.declTNode,null,null,null,null,e||null);r[tp]=this._declarationLView[this._declarationTContainer.index];const o=this._declarationLView[No];return null!==o&&(r[No]=o.createEmbeddedView(i)),KC(i,r,t),new vp(r)}};function Oee(){return ob(qi(),oe())}function ob(n,t){return 4&n.type?new Ree(t,n,Xd(n,t)):null}let As=(()=>{class n{}return n.__NG_ELEMENT_ID__=Fee,n})();function Fee(){return r2(qi(),oe())}const Pee=As,t2=class extends Pee{constructor(t,e,i){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=i}get element(){return Xd(this._hostTNode,this._hostLView)}get injector(){return new Bd(this._hostTNode,this._hostLView)}get parentInjector(){const t=iC(this._hostTNode,this._hostLView);if(lR(t)){const e=w_(t,this._hostLView),i=x_(t);return new Bd(e[Ee].data[i+8],e)}return new Bd(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=n2(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-Sr}createEmbeddedView(t,e,i){let r,s;"number"==typeof i?r=i:null!=i&&(r=i.index,s=i.injector);const o=t.createEmbeddedView(e||{},s);return this.insert(o,r),o}createComponent(t,e,i,r,s){const o=t&&!function lp(n){return"function"==typeof n}(t);let a;if(o)a=e;else{const u=e||{};a=u.index,i=u.injector,r=u.projectableNodes,s=u.environmentInjector||u.ngModuleRef}const l=o?t:new xp(Xt(t)),c=i||this.parentInjector;if(!s&&null==l.ngModule){const h=(o?c:this.parentInjector).get(va,null);h&&(s=h)}const d=l.create(c,r,void 0,s);return this.insert(d.hostView,a),d}insert(t,e){const i=t._lView,r=i[Ee];if(function lX(n){return so(n[jn])}(i)){const d=this.indexOf(t);if(-1!==d)this.detach(d);else{const u=i[jn],h=new t2(u,u[nr],u[jn]);h.detach(h.indexOf(t))}}const s=this._adjustIndex(e),o=this._lContainer;!function k7(n,t,e,i){const r=Sr+i,s=e.length;i>0&&(e[r-1][ro]=t),i<s-Sr?(t[ro]=e[r],vR(e,Sr+i,t)):(e.push(t),t[ro]=null),t[jn]=e;const o=t[tp];null!==o&&e!==o&&function E7(n,t){const e=n[Pd];t[ir]!==t[jn][jn][ir]&&(n[NN]=!0),null===e?n[Pd]=[t]:e.push(t)}(o,t);const a=t[No];null!==a&&a.insertView(n),t[ht]|=64}(r,i,o,s);const a=SC(s,o),l=i[_t],c=N_(l,o[p_]);return null!==c&&function C7(n,t,e,i,r,s){i[ma]=r,i[nr]=t,fp(n,i,e,1,r,s)}(r,o[nr],l,i,c,a),t.attachToViewContainerRef(),vR(AD(o),s,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=n2(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),i=wC(this._lContainer,e);i&&(E_(AD(this._lContainer),e),jR(i[Ee],i))}detach(t){const e=this._adjustIndex(t,-1),i=wC(this._lContainer,e);return i&&null!=E_(AD(this._lContainer),e)?new vp(i):null}_adjustIndex(t,e=0){return t??this.length+e}};function n2(n){return n[f_]}function AD(n){return n[f_]||(n[f_]=[])}function r2(n,t){let e;const i=t[n.index];if(so(i))e=i;else{let r;if(8&n.type)r=Gi(i);else{const s=t[_t];r=s.createComment("");const o=ns(n,t);gc(s,N_(s,o),r,function M7(n,t){return n.nextSibling(t)}(s,o),!1)}t[n.index]=e=tF(i,t,r,n),W_(t,e)}return new t2(e,n,t)}class MD{constructor(t){this.queryList=t,this.matches=null}clone(){return new MD(this.queryList)}setDirty(){this.queryList.setDirty()}}class ND{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const i=null!==t.contentQueries?t.contentQueries[0]:e.length,r=[];for(let s=0;s<i;s++){const o=e.getByIndex(s);r.push(this.queries[o.indexInDeclarationView].clone())}return new ND(r)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==c2(t,e).matches&&this.queries[e].setDirty()}}class s2{constructor(t,e,i=null){this.predicate=t,this.flags=e,this.read=i}}class RD{constructor(t=[]){this.queries=t}elementStart(t,e){for(let i=0;i<this.queries.length;i++)this.queries[i].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let i=0;i<this.length;i++){const r=null!==e?e.length:0,s=this.getByIndex(i).embeddedTView(t,r);s&&(s.indexInDeclarationView=i,null!==e?e.push(s):e=[s])}return null!==e?new RD(e):null}template(t,e){for(let i=0;i<this.queries.length;i++)this.queries[i].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class OD{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new OD(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let i=t.parent;for(;null!==i&&8&i.type&&i.index!==e;)i=i.parent;return e===(null!==i?i.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const i=this.metadata.predicate;if(Array.isArray(i))for(let r=0;r<i.length;r++){const s=i[r];this.matchTNodeWithReadOption(t,e,Lee(e,s)),this.matchTNodeWithReadOption(t,e,S_(e,t,s,!1,!1))}else i===zo?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,S_(e,t,i,!1,!1))}matchTNodeWithReadOption(t,e,i){if(null!==i){const r=this.metadata.read;if(null!==r)if(r===Pt||r===As||r===zo&&4&e.type)this.addMatch(e.index,-2);else{const s=S_(e,t,r,!1,!1);null!==s&&this.addMatch(e.index,s)}else this.addMatch(e.index,i)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function Lee(n,t){const e=n.localNames;if(null!==e)for(let i=0;i<e.length;i+=2)if(e[i]===t)return e[i+1];return null}function Vee(n,t,e,i){return-1===e?function $ee(n,t){return 11&n.type?Xd(n,t):4&n.type?ob(n,t):null}(t,n):-2===e?function Bee(n,t,e){return e===Pt?Xd(t,n):e===zo?ob(t,n):e===As?r2(t,n):void 0}(n,t,i):fc(n,n[Ee],e,t)}function o2(n,t,e,i){const r=t[No].queries[i];if(null===r.matches){const s=n.data,o=e.matches,a=[];for(let l=0;l<o.length;l+=2){const c=o[l];a.push(c<0?null:Vee(t,s[c],o[l+1],e.metadata.read))}r.matches=a}return r.matches}function FD(n,t,e,i){const r=n.queries.getByIndex(e),s=r.matches;if(null!==s){const o=o2(n,t,r,e);for(let a=0;a<s.length;a+=2){const l=s[a];if(l>0)i.push(o[a/2]);else{const c=s[a+1],d=t[-l];for(let u=Sr;u<d.length;u++){const h=d[u];h[tp]===h[jn]&&FD(h[Ee],h,c,i)}if(null!==d[Pd]){const u=d[Pd];for(let h=0;h<u.length;h++){const p=u[h];FD(p[Ee],p,c,i)}}}}}return i}function Ms(n){const t=oe(),e=Ft(),i=XN();Kw(i+1);const r=c2(e,i);if(n.dirty&&function aX(n){return 4==(4&n[ht])}(t)===(2==(2&r.metadata.flags))){if(null===r.matches)n.reset([]);else{const s=r.crossesNgTemplate?FD(e,t,i,[]):o2(e,t,r,i);n.reset(s,k9),n.notifyOnChanges()}return!0}return!1}function pu(n,t,e){const i=Ft();i.firstCreatePass&&(function l2(n,t,e){null===n.queries&&(n.queries=new RD),n.queries.track(new OD(t,e))}(i,new s2(n,t,e),-1),2==(2&t)&&(i.staticViewQueries=!0)),function a2(n,t,e){const i=new Np(4==(4&e));KO(n,t,i,i.destroy),null===t[No]&&(t[No]=new ND),t[No].queries.push(new MD(i))}(i,oe(),t)}function Ns(){return function zee(n,t){return n[No].queries[t].queryList}(oe(),XN())}function c2(n,t){return n.queries.getByIndex(t)}function cb(...n){}const db=new ne("Application Initializer");let ub=(()=>{class n{constructor(e){this.appInits=e,this.resolve=cb,this.reject=cb,this.initialized=!1,this.done=!1,this.donePromise=new Promise((i,r)=>{this.resolve=i,this.reject=r})}runInitializers(){if(this.initialized)return;const e=[],i=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let r=0;r<this.appInits.length;r++){const s=this.appInits[r]();if(Cp(s))e.push(s);else if(hD(s)){const o=new Promise((a,l)=>{s.subscribe({complete:a,error:l})});e.push(o)}}Promise.all(e).then(()=>{i()}).catch(r=>{this.reject(r)}),0===e.length&&i(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)(Y(db,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Op=new ne("AppId",{providedIn:"root",factory:function E2(){return`${zD()}${zD()}${zD()}`}});function zD(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const I2=new ne("Platform Initializer"),UD=new ne("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),T2=new ne("appBootstrapListener"),Da=new ne("AnimationModuleType");let lte=(()=>{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();const Uo=new ne("LocaleId",{providedIn:"root",factory:()=>lt(Uo,je.Optional|je.SkipSelf)||function cte(){return typeof $localize<"u"&&$localize.locale||uu}()});class ute{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}let A2=(()=>{class n{compileModuleSync(e){return new kD(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const i=this.compileModuleSync(e),s=wa(es(e).declarations).reduce((o,a)=>{const l=Xt(a);return l&&o.push(new xp(l)),o},[]);return new ute(i,s)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const fte=(()=>Promise.resolve(0))();function HD(n){typeof Zone>"u"?fte.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}class Qe{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:i=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new $t(!1),this.onMicrotaskEmpty=new $t(!1),this.onStable=new $t(!1),this.onError=new $t(!1),typeof Zone>"u")throw new Q(908,!1);Zone.assertZonePatched();const r=this;r._nesting=0,r._outer=r._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(r._inner=r._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(r._inner=r._inner.fork(Zone.longStackTraceZoneSpec)),r.shouldCoalesceEventChangeDetection=!i&&e,r.shouldCoalesceRunChangeDetection=i,r.lastRequestAnimationFrameId=-1,r.nativeRequestAnimationFrame=function mte(){let n=Cn.requestAnimationFrame,t=Cn.cancelAnimationFrame;if(typeof Zone<"u"&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const i=t[Zone.__symbol__("OriginalDelegate")];i&&(t=i)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function bte(n){const t=()=>{!function _te(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(Cn,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,WD(n),n.isCheckStableRunning=!0,jD(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),WD(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,i,r,s,o,a)=>{try{return R2(n),e.invokeTask(r,s,o,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===s.type||n.shouldCoalesceRunChangeDetection)&&t(),O2(n)}},onInvoke:(e,i,r,s,o,a,l)=>{try{return R2(n),e.invoke(r,s,o,a,l)}finally{n.shouldCoalesceRunChangeDetection&&t(),O2(n)}},onHasTask:(e,i,r,s)=>{e.hasTask(r,s),i===r&&("microTask"==s.change?(n._hasPendingMicrotasks=s.microTask,WD(n),jD(n)):"macroTask"==s.change&&(n.hasPendingMacrotasks=s.macroTask))},onHandleError:(e,i,r,s)=>(e.handleError(r,s),n.runOutsideAngular(()=>n.onError.emit(s)),!1)})}(r)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Qe.isInAngularZone())throw new Q(909,!1)}static assertNotInAngularZone(){if(Qe.isInAngularZone())throw new Q(909,!1)}run(t,e,i){return this._inner.run(t,e,i)}runTask(t,e,i,r){const s=this._inner,o=s.scheduleEventTask("NgZoneEvent: "+r,t,gte,cb,cb);try{return s.runTask(o,e,i)}finally{s.cancelTask(o)}}runGuarded(t,e,i){return this._inner.runGuarded(t,e,i)}runOutsideAngular(t){return this._outer.run(t)}}const gte={};function jD(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function WD(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function R2(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function O2(n){n._nesting--,jD(n)}class yte{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new $t,this.onMicrotaskEmpty=new $t,this.onStable=new $t,this.onError=new $t}run(t,e,i){return t.apply(e,i)}runGuarded(t,e,i){return t.apply(e,i)}runOutsideAngular(t){return t()}runTask(t,e,i,r){return t.apply(e,i)}}const F2=new ne(""),hb=new ne("");let YD,GD=(()=>{class n{constructor(e,i,r){this._ngZone=e,this.registry=i,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,YD||(function vte(n){YD=n}(r),r.addToWindow(i)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Qe.assertNotInAngularZone(),HD(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())HD(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(i=>!i.updateCb||!i.updateCb(e)||(clearTimeout(i.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,i,r){let s=-1;i&&i>0&&(s=setTimeout(()=>{this._callbacks=this._callbacks.filter(o=>o.timeoutId!==s),e(this._didWork,this.getPendingTasks())},i)),this._callbacks.push({doneCb:e,timeoutId:s,updateCb:r})}whenStable(e,i,r){if(r&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,i,r),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,i,r){return[]}}return n.\u0275fac=function(e){return new(e||n)(Y(Qe),Y(qD),Y(hb))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})(),qD=(()=>{class n{constructor(){this._applications=new Map}registerApplication(e,i){this._applications.set(e,i)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,i=!0){return YD?.findTestabilityInTree(this,e,i)??null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})(),ol=null;const P2=new ne("AllowMultipleToken"),KD=new ne("PlatformDestroyListeners"),Sa=!1;class L2{constructor(t,e){this.name=t,this.token=e}}function V2(n,t,e=[]){const i=`Platform: ${t}`,r=new ne(i);return(s=[])=>{let o=XD();if(!o||o.injector.get(P2,!1)){const a=[...e,...s,{provide:r,useValue:!0}];n?n(a):function Cte(n){if(ol&&!ol.get(P2,!1))throw new Q(400,!1);ol=n;const t=n.get(z2);(function $2(n){const t=n.get(I2,null);t&&t.forEach(e=>e())})(n)}(function B2(n=[],t){return Li.create({name:t,providers:[{provide:LC,useValue:"platform"},{provide:KD,useValue:new Set([()=>ol=null])},...n]})}(a,i))}return function Ste(n){const t=XD();if(!t)throw new Q(401,!1);return t}()}}function XD(){return ol?.get(z2)??null}let z2=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,i){const r=function H2(n,t){let e;return e="noop"===n?new yte:("zone.js"===n?void 0:n)||new Qe(t),e}(i?.ngZone,function U2(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!n||!n.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!n||!n.ngZoneRunCoalescing)||!1}}(i)),s=[{provide:Qe,useValue:r}];return r.run(()=>{const o=Li.create({providers:s,parent:this.injector,name:e.moduleType.name}),a=e.create(o),l=a.injector.get(nl,null);if(!l)throw new Q(402,!1);return r.runOutsideAngular(()=>{const c=r.onError.subscribe({next:d=>{l.handleError(d)}});a.onDestroy(()=>{pb(this._modules,a),c.unsubscribe()})}),function j2(n,t,e){try{const i=e();return Cp(i)?i.catch(r=>{throw t.runOutsideAngular(()=>n.handleError(r)),r}):i}catch(i){throw t.runOutsideAngular(()=>n.handleError(i)),i}}(l,r,()=>{const c=a.injector.get(ub);return c.runInitializers(),c.donePromise.then(()=>(function _P(n){Ds(n,"Expected localeId to be defined"),"string"==typeof n&&(gP=n.toLowerCase().replace(/_/g,"-"))}(a.injector.get(Uo,uu)||uu),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,i=[]){const r=W2({},i);return function xte(n,t,e){const i=new kD(e);return Promise.resolve(i)}(0,0,e).then(s=>this.bootstrapModuleFactory(s,r))}_moduleDoBootstrap(e){const i=e.injector.get(gu);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(r=>i.bootstrap(r));else{if(!e.instance.ngDoBootstrap)throw new Q(-403,!1);e.instance.ngDoBootstrap(i)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Q(404,!1);this._modules.slice().forEach(i=>i.destroy()),this._destroyListeners.forEach(i=>i());const e=this._injector.get(KD,null);e&&(e.forEach(i=>i()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(Y(Li))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function W2(n,t){return Array.isArray(t)?t.reduce(W2,n):{...n,...t}}let gu=(()=>{class n{get destroyed(){return this._destroyed}get injector(){return this._injector}constructor(e,i,r){this._zone=e,this._injector=i,this._exceptionHandler=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const s=new Ze(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),o=new Ze(a=>{let l;this._zone.runOutsideAngular(()=>{l=this._zone.onStable.subscribe(()=>{Qe.assertNotInAngularZone(),HD(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const c=this._zone.onUnstable.subscribe(()=>{Qe.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{l.unsubscribe(),c.unsubscribe()}});this.isStable=n_(s,o.pipe(function yN(n={}){const{connector:t=(()=>new dt),resetOnError:e=!0,resetOnComplete:i=!0,resetOnRefCountZero:r=!0}=n;return s=>{let o,a,l,c=0,d=!1,u=!1;const h=()=>{a?.unsubscribe(),a=void 0},p=()=>{h(),o=l=void 0,d=u=!1},f=()=>{const m=o;p(),m?.unsubscribe()};return Hn((m,g)=>{c++,!u&&!d&&h();const _=l=l??t();g.add(()=>{c--,0===c&&!u&&!d&&(a=Tw(f,r))}),_.subscribe(g),!o&&c>0&&(o=new Be({next:b=>_.next(b),error:b=>{u=!0,h(),a=Tw(p,e,b),_.error(b)},complete:()=>{d=!0,h(),a=Tw(p,i),_.complete()}}),Cr(m).subscribe(o))})(s)}}()))}bootstrap(e,i){const r=e instanceof kO;if(!this._injector.get(ub).done){!r&&function Nd(n){const t=Xt(n)||tr(n)||Dr(n);return null!==t&&t.standalone}(e);throw new Q(405,Sa)}let o;o=r?e:this._injector.get(yc).resolveComponentFactory(e),this.componentTypes.push(o.componentType);const a=function wte(n){return n.isBoundToModule}(o)?void 0:this._injector.get(hu),c=o.create(Li.NULL,[],i||o.selector,a),d=c.location.nativeElement,u=c.injector.get(F2,null);return u?.registerApplication(d),c.onDestroy(()=>{this.detachView(c.hostView),pb(this.components,c),u?.unregisterApplication(d)}),this._loadComponent(c),c}tick(){if(this._runningTick)throw new Q(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const i=e;this._views.push(i),i.attachToAppRef(this)}detachView(e){const i=e;pb(this._views,i),i.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);const i=this._injector.get(T2,[]);i.push(...this._bootstrapListeners),i.forEach(r=>r(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>pb(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new Q(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return n.\u0275fac=function(e){return new(e||n)(Y(Qe),Y(va),Y(nl))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function pb(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}let _u=(()=>{class n{}return n.__NG_ELEMENT_ID__=Ete,n})();function Ete(n){return function Ite(n,t,e){if(ip(n)&&!e){const i=is(n.index,t);return new vp(i,i)}return 47&n.type?new vp(t[ir],t):null}(qi(),oe(),16==(16&n))}const zte=V2(null,"core",[]);let Ute=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(Y(gu))},n.\u0275mod=ut({type:n}),n.\u0275inj=at({}),n})(),tS=null;function ka(){return tS}class Wte{}const bt=new ne("DocumentToken");let nS=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:function(){return function Gte(){return Y(nL)}()},providedIn:"platform"}),n})();const qte=new ne("Location Initialized");let nL=(()=>{class n extends nS{constructor(e){super(),this._doc=e,this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return ka().getBaseHref(this._doc)}onPopState(e){const i=ka().getGlobalEventTarget(this._doc,"window");return i.addEventListener("popstate",e,!1),()=>i.removeEventListener("popstate",e)}onHashChange(e){const i=ka().getGlobalEventTarget(this._doc,"window");return i.addEventListener("hashchange",e,!1),()=>i.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,i,r){iL()?this._history.pushState(e,i,r):this._location.hash=r}replaceState(e,i,r){iL()?this._history.replaceState(e,i,r):this._location.hash=r}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)(Y(bt))},n.\u0275prov=me({token:n,factory:function(){return function Yte(){return new nL(Y(bt))}()},providedIn:"platform"}),n})();function iL(){return!!window.history.pushState}function iS(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,2==e?n+t.substring(1):1==e?n+t:n+"/"+t}function rL(n){const t=n.match(/#|\?|$/),e=t&&t.index||n.length;return n.slice(0,e-("/"===n[e-1]?1:0))+n.slice(e)}function Ea(n){return n&&"?"!==n[0]?"?"+n:n}let kc=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:function(){return lt(oL)},providedIn:"root"}),n})();const sL=new ne("appBaseHref");let oL=(()=>{class n extends kc{constructor(e,i){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=i??this._platformLocation.getBaseHrefFromDOM()??lt(bt).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return iS(this._baseHref,e)}path(e=!1){const i=this._platformLocation.pathname+Ea(this._platformLocation.search),r=this._platformLocation.hash;return r&&e?`${i}${r}`:i}pushState(e,i,r,s){const o=this.prepareExternalUrl(r+Ea(s));this._platformLocation.pushState(e,i,o)}replaceState(e,i,r,s){const o=this.prepareExternalUrl(r+Ea(s));this._platformLocation.replaceState(e,i,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Y(nS),Y(sL,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Kte=(()=>{class n extends kc{constructor(e,i){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=i&&(this._baseHref=i)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let i=this._platformLocation.hash;return null==i&&(i="#"),i.length>0?i.substring(1):i}prepareExternalUrl(e){const i=iS(this._baseHref,e);return i.length>0?"#"+i:i}pushState(e,i,r,s){let o=this.prepareExternalUrl(r+Ea(s));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.pushState(e,i,o)}replaceState(e,i,r,s){let o=this.prepareExternalUrl(r+Ea(s));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.replaceState(e,i,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Y(nS),Y(sL,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})(),Pp=(()=>{class n{constructor(e){this._subject=new $t,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const i=this._locationStrategy.getBaseHref();this._basePath=function Qte(n){if(new RegExp("^(https?:)?//").test(n)){const[,e]=n.split(/\/\/[^\/]+/);return e}return n}(rL(aL(i))),this._locationStrategy.onPopState(r=>{this._subject.emit({url:this.path(!0),pop:!0,state:r.state,type:r.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,i=""){return this.path()==this.normalize(e+Ea(i))}normalize(e){return n.stripTrailingSlash(function Zte(n,t){if(!n||!t.startsWith(n))return t;const e=t.substring(n.length);return""===e||["/",";","?","#"].includes(e[0])?e:t}(this._basePath,aL(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,i="",r=null){this._locationStrategy.pushState(r,"",e,i),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ea(i)),r)}replaceState(e,i="",r=null){this._locationStrategy.replaceState(r,"",e,i),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ea(i)),r)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(i=>{this._notifyUrlChangeListeners(i.url,i.state)})),()=>{const i=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(i,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",i){this._urlChangeListeners.forEach(r=>r(e,i))}subscribe(e,i,r){return this._subject.subscribe({next:e,error:i,complete:r})}}return n.normalizeQueryParams=Ea,n.joinWithSlash=iS,n.stripTrailingSlash=rL,n.\u0275fac=function(e){return new(e||n)(Y(kc))},n.\u0275prov=me({token:n,factory:function(){return function Xte(){return new Pp(Y(kc))}()},providedIn:"root"}),n})();function aL(n){return n.replace(/\/index.html$/,"")}let fS=(()=>{class n{constructor(e,i){this._viewContainer=e,this._context=new zne,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=i}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){vL("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){vL("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,i){return!0}}return n.\u0275fac=function(e){return new(e||n)(V(As),V(zo))},n.\u0275dir=we({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),n})();class zne{constructor(){this.$implicit=null,this.ngIf=null}}function vL(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${gn(t)}'.`)}let Ta=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({}),n})();const DL="browser";let bie=(()=>{class n{}return n.\u0275prov=me({token:n,providedIn:"root",factory:()=>new yie(Y(bt),window)}),n})();class yie{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function vie(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if("function"==typeof n.createTreeWalker&&n.body&&(n.body.createShadowRoot||n.body.attachShadow)){const i=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let r=i.currentNode;for(;r;){const s=r.shadowRoot;if(s){const o=s.getElementById(t)||s.querySelector(`[name="${t}"]`);if(o)return o}r=i.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),i=e.left+this.window.pageXOffset,r=e.top+this.window.pageYOffset,s=this.offset();this.window.scrollTo(i-s[0],r-s[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=SL(this.window.history)||SL(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function SL(n){return Object.getOwnPropertyDescriptor(n,"scrollRestoration")}class Yie extends Wte{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class xS extends Yie{static makeCurrent(){!function jte(n){tS||(tS=n)}(new xS)}onAndCancel(t,e,i){return t.addEventListener(e,i,!1),()=>{t.removeEventListener(e,i,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function Kie(){return Bp=Bp||document.querySelector("base"),Bp?Bp.getAttribute("href"):null}();return null==e?null:function Xie(n){Ib=Ib||document.createElement("a"),Ib.setAttribute("href",n);const t=Ib.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){Bp=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function Fne(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const i=e.indexOf("="),[r,s]=-1==i?[e,""]:[e.slice(0,i),e.slice(i+1)];if(r.trim()===t)return decodeURIComponent(s)}return null}(document.cookie,t)}}let Ib,Bp=null;const AL=new ne("TRANSITION_ID"),Qie=[{provide:db,useFactory:function Zie(n,t,e){return()=>{e.get(ub).donePromise.then(()=>{const i=ka(),r=t.querySelectorAll(`style[ng-transition="${n}"]`);for(let s=0;s<r.length;s++)i.remove(r[s])})}},deps:[AL,bt,Li],multi:!0}];let ere=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();const Tb=new ne("EventManagerPlugins");let Ab=(()=>{class n{constructor(e,i){this._zone=i,this._eventNameToPlugin=new Map,e.forEach(r=>r.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,i,r){return this._findPluginFor(i).addEventListener(e,i,r)}addGlobalEventListener(e,i,r){return this._findPluginFor(i).addGlobalEventListener(e,i,r)}getZone(){return this._zone}_findPluginFor(e){const i=this._eventNameToPlugin.get(e);if(i)return i;const r=this._plugins;for(let s=0;s<r.length;s++){const o=r[s];if(o.supports(e))return this._eventNameToPlugin.set(e,o),o}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(Y(Tb),Y(Qe))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();class ML{constructor(t){this._doc=t}addGlobalEventListener(t,e,i){const r=ka().getGlobalEventTarget(this._doc,t);if(!r)throw new Error(`Unsupported event target ${r} for event ${e}`);return this.addEventListener(r,e,i)}}let NL=(()=>{class n{constructor(){this.usageCount=new Map}addStyles(e){for(const i of e)1===this.changeUsageCount(i,1)&&this.onStyleAdded(i)}removeStyles(e){for(const i of e)0===this.changeUsageCount(i,-1)&&this.onStyleRemoved(i)}onStyleRemoved(e){}onStyleAdded(e){}getAllStyles(){return this.usageCount.keys()}changeUsageCount(e,i){const r=this.usageCount;let s=r.get(e)??0;return s+=i,s>0?r.set(e,s):r.delete(e),s}ngOnDestroy(){for(const e of this.getAllStyles())this.onStyleRemoved(e);this.usageCount.clear()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})(),zp=(()=>{class n extends NL{constructor(e){super(),this.doc=e,this.styleRef=new Map,this.hostNodes=new Set,this.resetHostNodes()}onStyleAdded(e){for(const i of this.hostNodes)this.addStyleToHost(i,e)}onStyleRemoved(e){const i=this.styleRef;i.get(e)?.forEach(s=>s.remove()),i.delete(e)}ngOnDestroy(){super.ngOnDestroy(),this.styleRef.clear(),this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(const i of this.getAllStyles())this.addStyleToHost(e,i)}removeHost(e){this.hostNodes.delete(e)}addStyleToHost(e,i){const r=this.doc.createElement("style");r.textContent=i,e.appendChild(r);const s=this.styleRef.get(i);s?s.push(r):this.styleRef.set(i,[r])}resetHostNodes(){const e=this.hostNodes;e.clear(),e.add(this.doc.head)}}return n.\u0275fac=function(e){return new(e||n)(Y(bt))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();const wS={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},CS=/%COMP%/g,FL=new ne("RemoveStylesOnCompDestory",{providedIn:"root",factory:()=>!1});function PL(n,t){return t.flat(100).map(e=>e.replace(CS,n))}function LL(n){return t=>{if("__ngUnwrap__"===t)return n;!1===n(t)&&(t.preventDefault(),t.returnValue=!1)}}let Mb=(()=>{class n{constructor(e,i,r,s){this.eventManager=e,this.sharedStylesHost=i,this.appId=r,this.removeStylesOnCompDestory=s,this.rendererByCompId=new Map,this.defaultRenderer=new DS(e)}createRenderer(e,i){if(!e||!i)return this.defaultRenderer;const r=this.getOrCreateRenderer(e,i);return r instanceof BL?r.applyToHost(e):r instanceof SS&&r.applyStyles(),r}getOrCreateRenderer(e,i){const r=this.rendererByCompId;let s=r.get(i.id);if(!s){const o=this.eventManager,a=this.sharedStylesHost,l=this.removeStylesOnCompDestory;switch(i.encapsulation){case no.Emulated:s=new BL(o,a,i,this.appId,l);break;case no.ShadowDom:return new are(o,a,e,i);default:s=new SS(o,a,i,l)}s.onDestroy=()=>r.delete(i.id),r.set(i.id,s)}return s}ngOnDestroy(){this.rendererByCompId.clear()}begin(){}end(){}}return n.\u0275fac=function(e){return new(e||n)(Y(Ab),Y(zp),Y(Op),Y(FL))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();class DS{constructor(t){this.eventManager=t,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?document.createElementNS(wS[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){(VL(t)?t.content:t).appendChild(e)}insertBefore(t,e,i){t&&(VL(t)?t.content:t).insertBefore(e,i)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let i="string"==typeof t?document.querySelector(t):t;if(!i)throw new Error(`The selector "${t}" did not match any elements`);return e||(i.textContent=""),i}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,i,r){if(r){e=r+":"+e;const s=wS[r];s?t.setAttributeNS(s,e,i):t.setAttribute(e,i)}else t.setAttribute(e,i)}removeAttribute(t,e,i){if(i){const r=wS[i];r?t.removeAttributeNS(r,e):t.removeAttribute(`${i}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,i,r){r&(Br.DashCase|Br.Important)?t.style.setProperty(e,i,r&Br.Important?"important":""):t.style[e]=i}removeStyle(t,e,i){i&Br.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,i){t[e]=i}setValue(t,e){t.nodeValue=e}listen(t,e,i){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,LL(i)):this.eventManager.addEventListener(t,e,LL(i))}}function VL(n){return"TEMPLATE"===n.tagName&&void 0!==n.content}class are extends DS{constructor(t,e,i,r){super(t),this.sharedStylesHost=e,this.hostEl=i,this.shadowRoot=i.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const s=PL(r.id,r.styles);for(const o of s){const a=document.createElement("style");a.textContent=o,this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,i){return super.insertBefore(this.nodeOrShadowRoot(t),e,i)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class SS extends DS{constructor(t,e,i,r,s=i.id){super(t),this.sharedStylesHost=e,this.removeStylesOnCompDestory=r,this.rendererUsageCount=0,this.styles=PL(s,i.styles)}applyStyles(){this.sharedStylesHost.addStyles(this.styles),this.rendererUsageCount++}destroy(){this.removeStylesOnCompDestory&&(this.sharedStylesHost.removeStyles(this.styles),this.rendererUsageCount--,0===this.rendererUsageCount&&this.onDestroy?.())}}class BL extends SS{constructor(t,e,i,r,s){const o=r+"-"+i.id;super(t,e,i,s,o),this.contentAttr=function rre(n){return"_ngcontent-%COMP%".replace(CS,n)}(o),this.hostAttr=function sre(n){return"_nghost-%COMP%".replace(CS,n)}(o)}applyToHost(t){this.applyStyles(),this.setAttribute(t,this.hostAttr,"")}createElement(t,e){const i=super.createElement(t,e);return super.setAttribute(i,this.contentAttr,""),i}}let lre=(()=>{class n extends ML{constructor(e){super(e)}supports(e){return!0}addEventListener(e,i,r){return e.addEventListener(i,r,!1),()=>this.removeEventListener(e,i,r)}removeEventListener(e,i,r){return e.removeEventListener(i,r)}}return n.\u0275fac=function(e){return new(e||n)(Y(bt))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();const zL=["alt","control","meta","shift"],cre={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},dre={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let ure=(()=>{class n extends ML{constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,i,r){const s=n.parseEventName(i),o=n.eventCallback(s.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>ka().onAndCancel(e,s.domEventName,o))}static parseEventName(e){const i=e.toLowerCase().split("."),r=i.shift();if(0===i.length||"keydown"!==r&&"keyup"!==r)return null;const s=n._normalizeKey(i.pop());let o="",a=i.indexOf("code");if(a>-1&&(i.splice(a,1),o="code."),zL.forEach(c=>{const d=i.indexOf(c);d>-1&&(i.splice(d,1),o+=c+".")}),o+=s,0!=i.length||0===s.length)return null;const l={};return l.domEventName=r,l.fullKey=o,l}static matchEventFullKeyCode(e,i){let r=cre[e.key]||e.key,s="";return i.indexOf("code.")>-1&&(r=e.code,s="code."),!(null==r||!r)&&(r=r.toLowerCase()," "===r?r="space":"."===r&&(r="dot"),zL.forEach(o=>{o!==r&&(0,dre[o])(e)&&(s+=o+".")}),s+=r,s===i)}static eventCallback(e,i,r){return s=>{n.matchEventFullKeyCode(s,e)&&r.runGuarded(()=>i(s))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(Y(bt))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();const HL=[{provide:UD,useValue:DL},{provide:I2,useValue:function hre(){xS.makeCurrent()},multi:!0},{provide:bt,useFactory:function fre(){return function V7(n){TC=n}(document),document},deps:[]}],mre=V2(zte,"browser",HL),jL=new ne(""),WL=[{provide:hb,useClass:class Jie{addToWindow(t){Cn.getAngularTestability=(i,r=!0)=>{const s=t.findTestabilityInTree(i,r);if(null==s)throw new Error("Could not find testability for element.");return s},Cn.getAllAngularTestabilities=()=>t.getAllTestabilities(),Cn.getAllAngularRootElements=()=>t.getAllRootElements(),Cn.frameworkStabilizers||(Cn.frameworkStabilizers=[]),Cn.frameworkStabilizers.push(i=>{const r=Cn.getAllAngularTestabilities();let s=r.length,o=!1;const a=function(l){o=o||l,s--,0==s&&i(o)};r.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(t,e,i){return null==e?null:t.getTestability(e)??(i?ka().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null)}},deps:[]},{provide:F2,useClass:GD,deps:[Qe,qD,hb]},{provide:GD,useClass:GD,deps:[Qe,qD,hb]}],GL=[{provide:LC,useValue:"root"},{provide:nl,useFactory:function pre(){return new nl},deps:[]},{provide:Tb,useClass:lre,multi:!0,deps:[bt,Qe,UD]},{provide:Tb,useClass:ure,multi:!0,deps:[bt]},{provide:Mb,useClass:Mb,deps:[Ab,zp,Op,FL]},{provide:_p,useExisting:Mb},{provide:NL,useExisting:zp},{provide:zp,useClass:zp,deps:[bt]},{provide:Ab,useClass:Ab,deps:[Tb,Qe]},{provide:class xie{},useClass:ere,deps:[]},[]];let TS,qL=(()=>{class n{constructor(e){}static withServerTransition(e){return{ngModule:n,providers:[{provide:Op,useValue:e.appId},{provide:AL,useExisting:Op},Qie]}}}return n.\u0275fac=function(e){return new(e||n)(Y(jL,12))},n.\u0275mod=ut({type:n}),n.\u0275inj=at({providers:[...GL,...WL],imports:[Ta,Ute]}),n})(),YL=(()=>{class n{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return n.\u0275fac=function(e){return new(e||n)(Y(bt))},n.\u0275prov=me({token:n,factory:function(e){let i=null;return i=e?new e:function _re(){return new YL(Y(bt))}(),i},providedIn:"root"}),n})();typeof window<"u"&&window;try{TS=typeof Intl<"u"&&Intl.v8BreakIterator}catch{TS=!1}let Up,Nb,Ec,AS,Ar=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?function _ie(n){return n===DL}(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!TS)&&typeof CSS<"u"&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(Y(UD))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function vu(n){return function Sre(){if(null==Up&&typeof window<"u")try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>Up=!0}))}finally{Up=Up||!1}return Up}()?n:!!n.capture}function JL(){if(null==Ec){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return Ec=!1,Ec;if("scrollBehavior"in document.documentElement.style)Ec=!0;else{const n=Element.prototype.scrollTo;Ec=!!n&&!/\{\s*\[native code\]\s*\}/.test(n.toString())}}return Ec}function Hp(){if("object"!=typeof document||!document)return 0;if(null==Nb){const n=document.createElement("div"),t=n.style;n.dir="rtl",t.width="1px",t.overflow="auto",t.visibility="hidden",t.pointerEvents="none",t.position="absolute";const e=document.createElement("div"),i=e.style;i.width="2px",i.height="1px",n.appendChild(e),document.body.appendChild(n),Nb=0,0===n.scrollLeft&&(n.scrollLeft=1,Nb=0===n.scrollLeft?1:2),n.remove()}return Nb}function Rb(){let n=typeof document<"u"&&document?document.activeElement:null;for(;n&&n.shadowRoot;){const t=n.shadowRoot.activeElement;if(t===n)break;n=t}return n}function ll(n){return n.composedPath?n.composedPath()[0]:n.target}function MS(){return typeof __karma__<"u"&&!!__karma__||typeof jasmine<"u"&&!!jasmine||typeof jest<"u"&&!!jest||typeof Mocha<"u"&&!!Mocha}class ls extends dt{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:i}=this;if(t)throw e;return this._throwIfClosed(),i}next(t){super.next(this._value=t)}}function Fe(...n){return oi(n,Kh(n))}function xu(n,...t){return t.length?t.some(e=>n[e]):n.altKey||n.shiftKey||n.ctrlKey||n.metaKey}function di(n,t,e){const i=ke(n)||t||e?{next:n,error:t,complete:e}:n;return i?Hn((r,s)=>{var o;null===(o=i.subscribe)||void 0===o||o.call(i);let a=!0;r.subscribe(Tn(s,l=>{var c;null===(c=i.next)||void 0===c||c.call(i,l),s.next(l)},()=>{var l;a=!1,null===(l=i.complete)||void 0===l||l.call(i),s.complete()},l=>{var c;a=!1,null===(c=i.error)||void 0===c||c.call(i,l),s.error(l)},()=>{var l,c;a&&(null===(l=i.unsubscribe)||void 0===l||l.call(i)),null===(c=i.finalize)||void 0===c||c.call(i)}))}):wn}class Gre extends U{constructor(t,e){super()}schedule(t,e=0){return this}}const Ob={setInterval(n,t,...e){const{delegate:i}=Ob;return i?.setInterval?i.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=Ob;return(t?.clearInterval||clearInterval)(n)},delegate:void 0};class NS extends Gre{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var i;if(this.closed)return this;this.state=t;const r=this.id,s=this.scheduler;return null!=r&&(this.id=this.recycleAsyncId(s,r,e)),this.pending=!0,this.delay=e,this.id=null!==(i=this.id)&&void 0!==i?i:this.requestAsyncId(s,this.id,e),this}requestAsyncId(t,e,i=0){return Ob.setInterval(t.flush.bind(t,this),i)}recycleAsyncId(t,e,i=0){if(null!=i&&this.delay===i&&!1===this.pending)return e;null!=e&&Ob.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const i=this._execute(t,e);if(i)return i;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let r,i=!1;try{this.work(t)}catch(s){i=!0,r=s||new Error("Scheduled action threw falsy error")}if(i)return this.unsubscribe(),r}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:i}=e;this.work=this.state=this.scheduler=null,this.pending=!1,Se(i,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}}const i$={now:()=>(i$.delegate||Date).now(),delegate:void 0};class jp{constructor(t,e=jp.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,i){return new this.schedulerActionCtor(this,t).schedule(i,e)}}jp.now=i$.now;class RS extends jp{constructor(t,e=jp.now){super(t,e),this.actions=[],this._active=!1}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let i;this._active=!0;do{if(i=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,i){for(;t=e.shift();)t.unsubscribe();throw i}}}const OS=new RS(NS),qre=OS;function lr(n,t){return Hn((e,i)=>{let r=0;e.subscribe(Tn(i,s=>n.call(t,s,r++)&&i.next(s)))})}function fo(n){return n<=0?()=>Mo:Hn((t,e)=>{let i=0;t.subscribe(Tn(e,r=>{++i<=n&&(e.next(r),n<=i&&e.complete())}))})}function r$(n){return lr((t,e)=>n<=e)}function s$(n,t=wn){return n=n??Yre,Hn((e,i)=>{let r,s=!0;e.subscribe(Tn(i,o=>{const a=t(o);(s||!n(r,a))&&(s=!1,r=a,i.next(o))}))})}function Yre(n,t){return n===t}function Ic(n){return Hn((t,e)=>{Cr(n).subscribe(Tn(e,()=>e.complete(),qt)),!e.closed&&t.subscribe(e)})}function cs(n){return null!=n&&"false"!=`${n}`}function Fb(n,t=0){return function Kre(n){return!isNaN(parseFloat(n))&&!isNaN(Number(n))}(n)?Number(n):t}function Pb(n){return Array.isArray(n)?n:[n]}function ui(n){return null==n?"":"string"==typeof n?n:`${n}px`}function Tc(n){return n instanceof Pt?n.nativeElement:n}let o$=(()=>{class n{create(e){return typeof MutationObserver>"u"?null:new MutationObserver(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),PS=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({providers:[o$]}),n})();const{isArray:Qre}=Array,{getPrototypeOf:Jre,prototype:ese,keys:tse}=Object;const{isArray:ise}=Array;function LS(n){return Ye(t=>function rse(n,t){return ise(t)?n(...t):n(t)}(n,t))}function $S(...n){const t=Kh(n),e=function mN(n){return ke(Iw(n))?n.pop():void 0}(n),{args:i,keys:r}=function a$(n){if(1===n.length){const t=n[0];if(Qre(t))return{args:t,keys:null};if(function nse(n){return n&&"object"==typeof n&&Jre(n)===ese}(t)){const e=tse(t);return{args:e.map(i=>t[i]),keys:e}}}return{args:n,keys:null}}(n);if(0===i.length)return oi([],t);const s=new Ze(function sse(n,t,e=wn){return i=>{c$(t,()=>{const{length:r}=n,s=new Array(r);let o=r,a=r;for(let l=0;l<r;l++)c$(t,()=>{const c=oi(n[l],t);let d=!1;c.subscribe(Tn(i,u=>{s[l]=u,d||(d=!0,a--),a||i.next(e(s.slice()))},()=>{--o||i.complete()}))},i)},i)}}(i,t,r?o=>function l$(n,t){return n.reduce((e,i,r)=>(e[i]=t[r],e),{})}(r,o):wn));return e?s.pipe(LS(e)):s}function c$(n,t,e){n?ha(e,n,t):t()}function Lb(...n){return function ose(){return Ad(1)}()(oi(n,Kh(n)))}function Wp(...n){const t=Kh(n);return Hn((e,i)=>{(t?Lb(n,e,t):Lb(n,e)).subscribe(i)})}const d$=new Set;let wu,ase=(()=>{class n{constructor(e){this._platform=e,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):cse}matchMedia(e){return(this._platform.WEBKIT||this._platform.BLINK)&&function lse(n){if(!d$.has(n))try{wu||(wu=document.createElement("style"),wu.setAttribute("type","text/css"),document.head.appendChild(wu)),wu.sheet&&(wu.sheet.insertRule(`@media ${n} {body{ }}`,0),d$.add(n))}catch(t){console.error(t)}}(e),this._matchMedia(e)}}return n.\u0275fac=function(e){return new(e||n)(Y(Ar))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function cse(n){return{matches:"all"===n||""===n,media:n,addListener:()=>{},removeListener:()=>{}}}let dse=(()=>{class n{constructor(e,i){this._mediaMatcher=e,this._zone=i,this._queries=new Map,this._destroySubject=new dt}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return u$(Pb(e)).some(r=>this._registerQuery(r).mql.matches)}observe(e){let s=$S(u$(Pb(e)).map(o=>this._registerQuery(o).observable));return s=Lb(s.pipe(fo(1)),s.pipe(r$(1),function FS(n,t=OS){return Hn((e,i)=>{let r=null,s=null,o=null;const a=()=>{if(r){r.unsubscribe(),r=null;const c=s;s=null,i.next(c)}};function l(){const c=o+n,d=t.now();if(d<c)return r=this.schedule(void 0,c-d),void i.add(r);a()}e.subscribe(Tn(i,c=>{s=c,o=t.now(),r||(r=t.schedule(l,n),i.add(r))},()=>{a(),i.complete()},void 0,()=>{s=r=null}))})}(0))),s.pipe(Ye(o=>{const a={matches:!1,breakpoints:{}};return o.forEach(({matches:l,query:c})=>{a.matches=a.matches||l,a.breakpoints[c]=l}),a}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const i=this._mediaMatcher.matchMedia(e),s={observable:new Ze(o=>{const a=l=>this._zone.run(()=>o.next(l));return i.addListener(a),()=>{i.removeListener(a)}}).pipe(Wp(i),Ye(({matches:o})=>({query:e,matches:o})),Ic(this._destroySubject)),mql:i};return this._queries.set(e,s),s}}return n.\u0275fac=function(e){return new(e||n)(Y(ase),Y(Qe))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function u$(n){return n.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}let $b=(()=>{class n{constructor(e){this._platform=e}isDisabled(e){return e.hasAttribute("disabled")}isVisible(e){return function gse(n){return!!(n.offsetWidth||n.offsetHeight||"function"==typeof n.getClientRects&&n.getClientRects().length)}(e)&&"visible"===getComputedStyle(e).visibility}isTabbable(e){if(!this._platform.isBrowser)return!1;const i=function mse(n){try{return n.frameElement}catch{return null}}(function Dse(n){return n.ownerDocument&&n.ownerDocument.defaultView||window}(e));if(i&&(-1===m$(i)||!this.isVisible(i)))return!1;let r=e.nodeName.toLowerCase(),s=m$(e);return e.hasAttribute("contenteditable")?-1!==s:!("iframe"===r||"object"===r||this._platform.WEBKIT&&this._platform.IOS&&!function wse(n){let t=n.nodeName.toLowerCase(),e="input"===t&&n.type;return"text"===e||"password"===e||"select"===t||"textarea"===t}(e))&&("audio"===r?!!e.hasAttribute("controls")&&-1!==s:"video"===r?-1!==s&&(null!==s||this._platform.FIREFOX||e.hasAttribute("controls")):e.tabIndex>=0)}isFocusable(e,i){return function Cse(n){return!function bse(n){return function vse(n){return"input"==n.nodeName.toLowerCase()}(n)&&"hidden"==n.type}(n)&&(function _se(n){let t=n.nodeName.toLowerCase();return"input"===t||"select"===t||"button"===t||"textarea"===t}(n)||function yse(n){return function xse(n){return"a"==n.nodeName.toLowerCase()}(n)&&n.hasAttribute("href")}(n)||n.hasAttribute("contenteditable")||f$(n))}(e)&&!this.isDisabled(e)&&(i?.ignoreVisibility||this.isVisible(e))}}return n.\u0275fac=function(e){return new(e||n)(Y(Ar))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function f$(n){if(!n.hasAttribute("tabindex")||void 0===n.tabIndex)return!1;let t=n.getAttribute("tabindex");return!(!t||isNaN(parseInt(t,10)))}function m$(n){if(!f$(n))return null;const t=parseInt(n.getAttribute("tabindex")||"",10);return isNaN(t)?-1:t}class Sse{get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}constructor(t,e,i,r,s=!1){this._element=t,this._checker=e,this._ngZone=i,this._document=r,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,s||this.attachAnchors()}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.remove()),e&&(e.removeEventListener("focus",this.endAnchorListener),e.remove()),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusInitialElement(t)))})}focusFirstTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusFirstTabbableElement(t)))})}focusLastTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusLastTabbableElement(t)))})}_getRegionBoundary(t){const e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(t){const e=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(e){if(!this._checker.isFocusable(e)){const i=this._getFirstTabbableElement(e);return i?.focus(t),!!i}return e.focus(t),!0}return this.focusFirstTabbableElement(t)}focusFirstTabbableElement(t){const e=this._getRegionBoundary("start");return e&&e.focus(t),!!e}focusLastTabbableElement(t){const e=this._getRegionBoundary("end");return e&&e.focus(t),!!e}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;const e=t.children;for(let i=0;i<e.length;i++){const r=e[i].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[i]):null;if(r)return r}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;const e=t.children;for(let i=e.length-1;i>=0;i--){const r=e[i].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[i]):null;if(r)return r}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(fo(1)).subscribe(t)}}let VS=(()=>{class n{constructor(e,i,r){this._checker=e,this._ngZone=i,this._document=r}create(e,i=!1){return new Sse(e,this._checker,this._ngZone,this._document,i)}}return n.\u0275fac=function(e){return new(e||n)(Y($b),Y(Qe),Y(bt))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function g$(n){return 0===n.buttons||0===n.offsetX&&0===n.offsetY}function _$(n){const t=n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&&1!==t.radiusX||null!=t.radiusY&&1!==t.radiusY)}const kse=new ne("cdk-input-modality-detector-options"),Ese={ignoreKeys:[18,17,224,91,16]},Cu=vu({passive:!0,capture:!0});let Ise=(()=>{class n{get mostRecentModality(){return this._modality.value}constructor(e,i,r,s){this._platform=e,this._mostRecentTarget=null,this._modality=new ls(null),this._lastTouchMs=0,this._onKeydown=o=>{this._options?.ignoreKeys?.some(a=>a===o.keyCode)||(this._modality.next("keyboard"),this._mostRecentTarget=ll(o))},this._onMousedown=o=>{Date.now()-this._lastTouchMs<650||(this._modality.next(g$(o)?"keyboard":"mouse"),this._mostRecentTarget=ll(o))},this._onTouchstart=o=>{_$(o)?this._modality.next("keyboard"):(this._lastTouchMs=Date.now(),this._modality.next("touch"),this._mostRecentTarget=ll(o))},this._options={...Ese,...s},this.modalityDetected=this._modality.pipe(r$(1)),this.modalityChanged=this.modalityDetected.pipe(s$()),e.isBrowser&&i.runOutsideAngular(()=>{r.addEventListener("keydown",this._onKeydown,Cu),r.addEventListener("mousedown",this._onMousedown,Cu),r.addEventListener("touchstart",this._onTouchstart,Cu)})}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&&(document.removeEventListener("keydown",this._onKeydown,Cu),document.removeEventListener("mousedown",this._onMousedown,Cu),document.removeEventListener("touchstart",this._onTouchstart,Cu))}}return n.\u0275fac=function(e){return new(e||n)(Y(Ar),Y(Qe),Y(bt),Y(kse,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Ase=new ne("cdk-focus-monitor-default-options"),Vb=vu({passive:!0,capture:!0});let Bb=(()=>{class n{constructor(e,i,r,s,o){this._ngZone=e,this._platform=i,this._inputModalityDetector=r,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=window.setTimeout(()=>this._windowFocused=!1)},this._stopInputModalityDetector=new dt,this._rootNodeFocusAndBlurListener=a=>{for(let c=ll(a);c;c=c.parentElement)"focus"===a.type?this._onFocus(a,c):this._onBlur(a,c)},this._document=s,this._detectionMode=o?.detectionMode||0}monitor(e,i=!1){const r=Tc(e);if(!this._platform.isBrowser||1!==r.nodeType)return Fe(null);const s=function Ere(n){if(function kre(){if(null==AS){const n=typeof document<"u"?document.head:null;AS=!(!n||!n.createShadowRoot&&!n.attachShadow)}return AS}()){const t=n.getRootNode?n.getRootNode():null;if(typeof ShadowRoot<"u"&&ShadowRoot&&t instanceof ShadowRoot)return t}return null}(r)||this._getDocument(),o=this._elementInfo.get(r);if(o)return i&&(o.checkChildren=!0),o.subject;const a={checkChildren:i,subject:new dt,rootNode:s};return this._elementInfo.set(r,a),this._registerGlobalListeners(a),a.subject}stopMonitoring(e){const i=Tc(e),r=this._elementInfo.get(i);r&&(r.subject.complete(),this._setClasses(i),this._elementInfo.delete(i),this._removeGlobalListeners(r))}focusVia(e,i,r){const s=Tc(e);s===this._getDocument().activeElement?this._getClosestElementsInfo(s).forEach(([a,l])=>this._originChanged(a,i,l)):(this._setOrigin(i),"function"==typeof s.focus&&s.focus(r))}ngOnDestroy(){this._elementInfo.forEach((e,i)=>this.stopMonitoring(i))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_getFocusOrigin(e){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(e)?"touch":"program":this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:e&&this._isLastInteractionFromInputLabel(e)?"mouse":"program"}_shouldBeAttributedToTouch(e){return 1===this._detectionMode||!!e?.contains(this._inputModalityDetector._mostRecentTarget)}_setClasses(e,i){e.classList.toggle("cdk-focused",!!i),e.classList.toggle("cdk-touch-focused","touch"===i),e.classList.toggle("cdk-keyboard-focused","keyboard"===i),e.classList.toggle("cdk-mouse-focused","mouse"===i),e.classList.toggle("cdk-program-focused","program"===i)}_setOrigin(e,i=!1){this._ngZone.runOutsideAngular(()=>{this._origin=e,this._originFromTouchInteraction="touch"===e&&i,0===this._detectionMode&&(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=>this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(e,i){const r=this._elementInfo.get(i),s=ll(e);!r||!r.checkChildren&&i!==s||this._originChanged(i,this._getFocusOrigin(s),r)}_onBlur(e,i){const r=this._elementInfo.get(i);!r||r.checkChildren&&e.relatedTarget instanceof Node&&i.contains(e.relatedTarget)||(this._setClasses(i),this._emitOrigin(r,null))}_emitOrigin(e,i){e.subject.observers.length&&this._ngZone.run(()=>e.subject.next(i))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const i=e.rootNode,r=this._rootNodeFocusListenerCount.get(i)||0;r||this._ngZone.runOutsideAngular(()=>{i.addEventListener("focus",this._rootNodeFocusAndBlurListener,Vb),i.addEventListener("blur",this._rootNodeFocusAndBlurListener,Vb)}),this._rootNodeFocusListenerCount.set(i,r+1),1==++this._monitoredElementCount&&(this._ngZone.runOutsideAngular(()=>{this._getWindow().addEventListener("focus",this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(Ic(this._stopInputModalityDetector)).subscribe(s=>{this._setOrigin(s,!0)}))}_removeGlobalListeners(e){const i=e.rootNode;if(this._rootNodeFocusListenerCount.has(i)){const r=this._rootNodeFocusListenerCount.get(i);r>1?this._rootNodeFocusListenerCount.set(i,r-1):(i.removeEventListener("focus",this._rootNodeFocusAndBlurListener,Vb),i.removeEventListener("blur",this._rootNodeFocusAndBlurListener,Vb),this._rootNodeFocusListenerCount.delete(i))}--this._monitoredElementCount||(this._getWindow().removeEventListener("focus",this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(e,i,r){this._setClasses(e,i),this._emitOrigin(r,i),this._lastFocusOrigin=i}_getClosestElementsInfo(e){const i=[];return this._elementInfo.forEach((r,s)=>{(s===e||r.checkChildren&&s.contains(e))&&i.push([s,r])}),i}_isLastInteractionFromInputLabel(e){const{_mostRecentTarget:i,mostRecentModality:r}=this._inputModalityDetector;if("mouse"!==r||!i||i===e||"INPUT"!==e.nodeName&&"TEXTAREA"!==e.nodeName||e.disabled)return!1;const s=e.labels;if(s)for(let o=0;o<s.length;o++)if(s[o].contains(i))return!0;return!1}}return n.\u0275fac=function(e){return new(e||n)(Y(Qe),Y(Ar),Y(Ise),Y(bt,8),Y(Ase,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const y$="cdk-high-contrast-black-on-white",v$="cdk-high-contrast-white-on-black",BS="cdk-high-contrast-active";let x$=(()=>{class n{constructor(e,i){this._platform=e,this._document=i,this._breakpointSubscription=lt(dse).observe("(forced-colors: active)").subscribe(()=>{this._hasCheckedHighContrastMode&&(this._hasCheckedHighContrastMode=!1,this._applyBodyHighContrastModeCssClasses())})}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const i=this._document.defaultView||window,r=i&&i.getComputedStyle?i.getComputedStyle(e):null,s=(r&&r.backgroundColor||"").replace(/ /g,"");switch(e.remove(),s){case"rgb(0,0,0)":case"rgb(45,50,54)":case"rgb(32,32,32)":return 2;case"rgb(255,255,255)":case"rgb(255,250,239)":return 1}return 0}ngOnDestroy(){this._breakpointSubscription.unsubscribe()}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(BS,y$,v$),this._hasCheckedHighContrastMode=!0;const i=this.getHighContrastMode();1===i?e.add(BS,y$):2===i&&e.add(BS,v$)}}}return n.\u0275fac=function(e){return new(e||n)(Y(Ar),Y(bt))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),zS=(()=>{class n{constructor(e){e._applyBodyHighContrastModeCssClasses()}}return n.\u0275fac=function(e){return new(e||n)(Y(x$))},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[PS]}),n})();const Mse=["addListener","removeListener"],Nse=["addEventListener","removeEventListener"],Rse=["on","off"];function zb(n,t,e,i){if(ke(e)&&(i=e,e=void 0),i)return zb(n,t,e).pipe(LS(i));const[r,s]=function Pse(n){return ke(n.addEventListener)&&ke(n.removeEventListener)}(n)?Nse.map(o=>a=>n[o](t,a,e)):function Ose(n){return ke(n.addListener)&&ke(n.removeListener)}(n)?Mse.map(w$(n,t)):function Fse(n){return ke(n.on)&&ke(n.off)}(n)?Rse.map(w$(n,t)):[];if(!r&&Ew(n))return Pi(o=>zb(o,t,e))(Cr(n));if(!r)throw new TypeError("Invalid event target");return new Ze(o=>{const a=(...l)=>o.next(1<l.length?l:l[0]);return r(a),()=>s(a)})}function w$(n,t){return e=>i=>n[e](t,i)}const Gp={schedule(n){let t=requestAnimationFrame,e=cancelAnimationFrame;const{delegate:i}=Gp;i&&(t=i.requestAnimationFrame,e=i.cancelAnimationFrame);const r=t(s=>{e=void 0,n(s)});return new U(()=>e?.(r))},requestAnimationFrame(...n){const{delegate:t}=Gp;return(t?.requestAnimationFrame||requestAnimationFrame)(...n)},cancelAnimationFrame(...n){const{delegate:t}=Gp;return(t?.cancelAnimationFrame||cancelAnimationFrame)(...n)},delegate:void 0},Vse=new class $se extends RS{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:i}=this;let r;t=t||i.shift();do{if(r=t.execute(t.state,t.delay))break}while((t=i[0])&&t.id===e&&i.shift());if(this._active=!1,r){for(;(t=i[0])&&t.id===e&&i.shift();)t.unsubscribe();throw r}}}(class Lse extends NS{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,i=0){return null!==i&&i>0?super.requestAsyncId(t,e,i):(t.actions.push(this),t._scheduled||(t._scheduled=Gp.requestAnimationFrame(()=>t.flush(void 0))))}recycleAsyncId(t,e,i=0){var r;if(null!=i?i>0:this.delay>0)return super.recycleAsyncId(t,e,i);const{actions:s}=t;null!=e&&(null===(r=s[s.length-1])||void 0===r?void 0:r.id)!==e&&(Gp.cancelAnimationFrame(e),t._scheduled=void 0)}});let US,Bse=1;const Ub={};function C$(n){return n in Ub&&(delete Ub[n],!0)}const zse={setImmediate(n){const t=Bse++;return Ub[t]=!0,US||(US=Promise.resolve()),US.then(()=>C$(t)&&n()),t},clearImmediate(n){C$(n)}},{setImmediate:Use,clearImmediate:Hse}=zse,Hb={setImmediate(...n){const{delegate:t}=Hb;return(t?.setImmediate||Use)(...n)},clearImmediate(n){const{delegate:t}=Hb;return(t?.clearImmediate||Hse)(n)},delegate:void 0},Gse=new class Wse extends RS{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:i}=this;let r;t=t||i.shift();do{if(r=t.execute(t.state,t.delay))break}while((t=i[0])&&t.id===e&&i.shift());if(this._active=!1,r){for(;(t=i[0])&&t.id===e&&i.shift();)t.unsubscribe();throw r}}}(class jse extends NS{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,i=0){return null!==i&&i>0?super.requestAsyncId(t,e,i):(t.actions.push(this),t._scheduled||(t._scheduled=Hb.setImmediate(t.flush.bind(t,void 0))))}recycleAsyncId(t,e,i=0){var r;if(null!=i?i>0:this.delay>0)return super.recycleAsyncId(t,e,i);const{actions:s}=t;null!=e&&(null===(r=s[s.length-1])||void 0===r?void 0:r.id)!==e&&(Hb.clearImmediate(e),t._scheduled=void 0)}});function HS(n,t=OS){return function qse(n){return Hn((t,e)=>{let i=!1,r=null,s=null,o=!1;const a=()=>{if(s?.unsubscribe(),s=null,i){i=!1;const c=r;r=null,e.next(c)}o&&e.complete()},l=()=>{s=null,o&&e.complete()};t.subscribe(Tn(e,c=>{i=!0,r=c,s||Cr(n(c)).subscribe(s=Tn(e,a,l))},()=>{o=!0,(!i||!s||s.closed)&&e.complete()}))})}(()=>function Kse(n=0,t,e=qre){let i=-1;return null!=t&&(fN(t)?e=t:i=t),new Ze(r=>{let s=function Yse(n){return n instanceof Date&&!isNaN(n)}(n)?+n-e.now():n;s<0&&(s=0);let o=0;return e.schedule(function(){r.closed||(r.next(o++),0<=i?this.schedule(void 0,i):r.complete())},s)})}(n,t))}const Xse=new ne("cdk-dir-doc",{providedIn:"root",factory:function Zse(){return lt(bt)}}),Qse=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;let Du=(()=>{class n{constructor(e){this.value="ltr",this.change=new $t,e&&(this.value=function Jse(n){const t=n?.toLowerCase()||"";return"auto"===t&&typeof navigator<"u"&&navigator?.language?Qse.test(navigator.language)?"rtl":"ltr":"rtl"===t?"rtl":"ltr"}((e.body?e.body.dir:null)||(e.documentElement?e.documentElement.dir:null)||"ltr"))}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(Y(Xse,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),qp=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({}),n})();const eoe=["contentWrapper"],toe=["*"],noe=new ne("VIRTUAL_SCROLL_STRATEGY");let jb=(()=>{class n{constructor(e,i,r){this._ngZone=e,this._platform=i,this._scrolled=new dt,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=r}register(e){this.scrollContainers.has(e)||this.scrollContainers.set(e,e.elementScrolled().subscribe(()=>this._scrolled.next(e)))}deregister(e){const i=this.scrollContainers.get(e);i&&(i.unsubscribe(),this.scrollContainers.delete(e))}scrolled(e=20){return this._platform.isBrowser?new Ze(i=>{this._globalSubscription||this._addGlobalListener();const r=e>0?this._scrolled.pipe(HS(e)).subscribe(i):this._scrolled.subscribe(i);return this._scrolledCount++,()=>{r.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Fe()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((e,i)=>this.deregister(i)),this._scrolled.complete()}ancestorScrolled(e,i){const r=this.getAncestorScrollContainers(e);return this.scrolled(i).pipe(lr(s=>!s||r.indexOf(s)>-1))}getAncestorScrollContainers(e){const i=[];return this.scrollContainers.forEach((r,s)=>{this._scrollableContainsElement(s,e)&&i.push(s)}),i}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(e,i){let r=Tc(i),s=e.getElementRef().nativeElement;do{if(r==s)return!0}while(r=r.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>zb(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return n.\u0275fac=function(e){return new(e||n)(Y(Qe),Y(Ar),Y(bt,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),D$=(()=>{class n{constructor(e,i,r,s){this.elementRef=e,this.scrollDispatcher=i,this.ngZone=r,this.dir=s,this._destroyed=new dt,this._elementScrolled=new Ze(o=>this.ngZone.runOutsideAngular(()=>zb(this.elementRef.nativeElement,"scroll").pipe(Ic(this._destroyed)).subscribe(o)))}ngOnInit(){this.scrollDispatcher.register(this)}ngOnDestroy(){this.scrollDispatcher.deregister(this),this._destroyed.next(),this._destroyed.complete()}elementScrolled(){return this._elementScrolled}getElementRef(){return this.elementRef}scrollTo(e){const i=this.elementRef.nativeElement,r=this.dir&&"rtl"==this.dir.value;null==e.left&&(e.left=r?e.end:e.start),null==e.right&&(e.right=r?e.start:e.end),null!=e.bottom&&(e.top=i.scrollHeight-i.clientHeight-e.bottom),r&&0!=Hp()?(null!=e.left&&(e.right=i.scrollWidth-i.clientWidth-e.left),2==Hp()?e.left=e.right:1==Hp()&&(e.left=e.right?-e.right:e.right)):null!=e.right&&(e.left=i.scrollWidth-i.clientWidth-e.right),this._applyScrollToOptions(e)}_applyScrollToOptions(e){const i=this.elementRef.nativeElement;JL()?i.scrollTo(e):(null!=e.top&&(i.scrollTop=e.top),null!=e.left&&(i.scrollLeft=e.left))}measureScrollOffset(e){const i="left",r="right",s=this.elementRef.nativeElement;if("top"==e)return s.scrollTop;if("bottom"==e)return s.scrollHeight-s.clientHeight-s.scrollTop;const o=this.dir&&"rtl"==this.dir.value;return"start"==e?e=o?r:i:"end"==e&&(e=o?i:r),o&&2==Hp()?e==i?s.scrollWidth-s.clientWidth-s.scrollLeft:s.scrollLeft:o&&1==Hp()?e==i?s.scrollLeft+s.scrollWidth-s.clientWidth:-s.scrollLeft:e==i?s.scrollLeft:s.scrollWidth-s.clientWidth-s.scrollLeft}}return n.\u0275fac=function(e){return new(e||n)(V(Pt),V(jb),V(Qe),V(Du,8))},n.\u0275dir=we({type:n,selectors:[["","cdk-scrollable",""],["","cdkScrollable",""]],standalone:!0}),n})(),jS=(()=>{class n{constructor(e,i,r){this._platform=e,this._change=new dt,this._changeListener=s=>{this._change.next(s)},this._document=r,i.runOutsideAngular(()=>{if(e.isBrowser){const s=this._getWindow();s.addEventListener("resize",this._changeListener),s.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener("resize",this._changeListener),e.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:i,height:r}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+r,right:e.left+i,height:r,width:i}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._document,i=this._getWindow(),r=e.documentElement,s=r.getBoundingClientRect();return{top:-s.top||e.body.scrollTop||i.scrollY||r.scrollTop||0,left:-s.left||e.body.scrollLeft||i.scrollX||r.scrollLeft||0}}change(e=20){return e>0?this._change.pipe(HS(e)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return n.\u0275fac=function(e){return new(e||n)(Y(Ar),Y(Qe),Y(bt,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const S$=new ne("VIRTUAL_SCROLLABLE");let soe=(()=>{class n extends D${constructor(e,i,r,s){super(e,i,r,s)}measureViewportSize(e){const i=this.elementRef.nativeElement;return"horizontal"===e?i.clientWidth:i.clientHeight}}return n.\u0275fac=function(e){return new(e||n)(V(Pt),V(jb),V(Qe),V(Du,8))},n.\u0275dir=we({type:n,features:[ct]}),n})();const aoe=typeof requestAnimationFrame<"u"?Vse:Gse;let loe=(()=>{class n extends soe{get orientation(){return this._orientation}set orientation(e){this._orientation!==e&&(this._orientation=e,this._calculateSpacerSize())}get appendOnly(){return this._appendOnly}set appendOnly(e){this._appendOnly=cs(e)}constructor(e,i,r,s,o,a,l,c){super(e,a,r,o),this.elementRef=e,this._changeDetectorRef=i,this._scrollStrategy=s,this.scrollable=c,this._platform=lt(Ar),this._detachedSubject=new dt,this._renderedRangeSubject=new dt,this._orientation="vertical",this._appendOnly=!1,this.scrolledIndexChange=new Ze(d=>this._scrollStrategy.scrolledIndexChange.subscribe(u=>Promise.resolve().then(()=>this.ngZone.run(()=>d.next(u))))),this.renderedRangeStream=this._renderedRangeSubject,this._totalContentSize=0,this._totalContentWidth="",this._totalContentHeight="",this._renderedRange={start:0,end:0},this._dataLength=0,this._viewportSize=0,this._renderedContentOffset=0,this._renderedContentOffsetNeedsRewrite=!1,this._isChangeDetectionPending=!1,this._runAfterChangeDetection=[],this._viewportChanges=U.EMPTY,this._viewportChanges=l.change().subscribe(()=>{this.checkViewportSize()}),this.scrollable||(this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable"),this.scrollable=this)}ngOnInit(){this._platform.isBrowser&&(this.scrollable===this&&super.ngOnInit(),this.ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>{this._measureViewportSize(),this._scrollStrategy.attach(this),this.scrollable.elementScrolled().pipe(Wp(null),HS(0,aoe)).subscribe(()=>this._scrollStrategy.onContentScrolled()),this._markChangeDetectionNeeded()})))}ngOnDestroy(){this.detach(),this._scrollStrategy.detach(),this._renderedRangeSubject.complete(),this._detachedSubject.complete(),this._viewportChanges.unsubscribe(),super.ngOnDestroy()}attach(e){this.ngZone.runOutsideAngular(()=>{this._forOf=e,this._forOf.dataStream.pipe(Ic(this._detachedSubject)).subscribe(i=>{const r=i.length;r!==this._dataLength&&(this._dataLength=r,this._scrollStrategy.onDataLengthChanged()),this._doChangeDetection()})})}detach(){this._forOf=null,this._detachedSubject.next()}getDataLength(){return this._dataLength}getViewportSize(){return this._viewportSize}getRenderedRange(){return this._renderedRange}measureBoundingClientRectWithScrollOffset(e){return this.getElementRef().nativeElement.getBoundingClientRect()[e]}setTotalContentSize(e){this._totalContentSize!==e&&(this._totalContentSize=e,this._calculateSpacerSize(),this._markChangeDetectionNeeded())}setRenderedRange(e){(function ooe(n,t){return n.start==t.start&&n.end==t.end})(this._renderedRange,e)||(this.appendOnly&&(e={start:0,end:Math.max(this._renderedRange.end,e.end)}),this._renderedRangeSubject.next(this._renderedRange=e),this._markChangeDetectionNeeded(()=>this._scrollStrategy.onContentRendered()))}getOffsetToRenderedContentStart(){return this._renderedContentOffsetNeedsRewrite?null:this._renderedContentOffset}setRenderedContentOffset(e,i="to-start"){e=this.appendOnly&&"to-start"===i?0:e;const s="horizontal"==this.orientation,o=s?"X":"Y";let l=`translate${o}(${Number((s&&this.dir&&"rtl"==this.dir.value?-1:1)*e)}px)`;this._renderedContentOffset=e,"to-end"===i&&(l+=` translate${o}(-100%)`,this._renderedContentOffsetNeedsRewrite=!0),this._renderedContentTransform!=l&&(this._renderedContentTransform=l,this._markChangeDetectionNeeded(()=>{this._renderedContentOffsetNeedsRewrite?(this._renderedContentOffset-=this.measureRenderedContentSize(),this._renderedContentOffsetNeedsRewrite=!1,this.setRenderedContentOffset(this._renderedContentOffset)):this._scrollStrategy.onRenderedOffsetChanged()}))}scrollToOffset(e,i="auto"){const r={behavior:i};"horizontal"===this.orientation?r.start=e:r.top=e,this.scrollable.scrollTo(r)}scrollToIndex(e,i="auto"){this._scrollStrategy.scrollToIndex(e,i)}measureScrollOffset(e){let i;return i=this.scrollable==this?r=>super.measureScrollOffset(r):r=>this.scrollable.measureScrollOffset(r),Math.max(0,i(e??("horizontal"===this.orientation?"start":"top"))-this.measureViewportOffset())}measureViewportOffset(e){let i;const r="left",s="right",o="rtl"==this.dir?.value;i="start"==e?o?s:r:"end"==e?o?r:s:e||("horizontal"===this.orientation?"left":"top");const a=this.scrollable.measureBoundingClientRectWithScrollOffset(i);return this.elementRef.nativeElement.getBoundingClientRect()[i]-a}measureRenderedContentSize(){const e=this._contentWrapper.nativeElement;return"horizontal"===this.orientation?e.offsetWidth:e.offsetHeight}measureRangeSize(e){return this._forOf?this._forOf.measureRangeSize(e,this.orientation):0}checkViewportSize(){this._measureViewportSize(),this._scrollStrategy.onDataLengthChanged()}_measureViewportSize(){this._viewportSize=this.scrollable.measureViewportSize(this.orientation)}_markChangeDetectionNeeded(e){e&&this._runAfterChangeDetection.push(e),this._isChangeDetectionPending||(this._isChangeDetectionPending=!0,this.ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>{this._doChangeDetection()})))}_doChangeDetection(){this._isChangeDetectionPending=!1,this._contentWrapper.nativeElement.style.transform=this._renderedContentTransform,this.ngZone.run(()=>this._changeDetectorRef.markForCheck());const e=this._runAfterChangeDetection;this._runAfterChangeDetection=[];for(const i of e)i()}_calculateSpacerSize(){this._totalContentHeight="horizontal"===this.orientation?"":`${this._totalContentSize}px`,this._totalContentWidth="horizontal"===this.orientation?`${this._totalContentSize}px`:""}}return n.\u0275fac=function(e){return new(e||n)(V(Pt),V(_u),V(Qe),V(noe,8),V(Du,8),V(jb),V(jS),V(S$,8))},n.\u0275cmp=bi({type:n,selectors:[["cdk-virtual-scroll-viewport"]],viewQuery:function(e,i){if(1&e&&pu(eoe,7),2&e){let r;Ms(r=Ns())&&(i._contentWrapper=r.first)}},hostAttrs:[1,"cdk-virtual-scroll-viewport"],hostVars:4,hostBindings:function(e,i){2&e&&ar("cdk-virtual-scroll-orientation-horizontal","horizontal"===i.orientation)("cdk-virtual-scroll-orientation-vertical","horizontal"!==i.orientation)},inputs:{orientation:"orientation",appendOnly:"appendOnly"},outputs:{scrolledIndexChange:"scrolledIndexChange"},standalone:!0,features:[rn([{provide:D$,useFactory:(t,e)=>t||e,deps:[[new Is,new T_(S$)],n]}]),ct,ED],ngContentSelectors:toe,decls:4,vars:4,consts:[[1,"cdk-virtual-scroll-content-wrapper"],["contentWrapper",""],[1,"cdk-virtual-scroll-spacer"]],template:function(e,i){1&e&&(rl(),kt(0,"div",0,1),Vi(2),Lt(),Ci(3,"div",2)),2&e&&(xi(3),_D("width",i._totalContentWidth)("height",i._totalContentHeight))},styles:["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"],encapsulation:2,changeDetection:0}),n})(),Su=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({}),n})(),k$=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[qp,Su,loe,qp,Su]}),n})();class WS{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class GS extends WS{constructor(t,e,i,r,s){super(),this.component=t,this.viewContainerRef=e,this.injector=i,this.componentFactoryResolver=r,this.projectableNodes=s}}class E$ extends WS{constructor(t,e,i,r){super(),this.templateRef=t,this.viewContainerRef=e,this.context=i,this.injector=r}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class coe extends WS{constructor(t){super(),this.element=t instanceof Pt?t.nativeElement:t}}class qS{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof GS?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof E$?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof coe?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class doe extends qS{constructor(t,e,i,r,s){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=i,this._defaultInjector=r,this.attachDomPortal=o=>{const a=o.element,l=this._document.createComment("dom-portal");a.parentNode.insertBefore(l,a),this.outletElement.appendChild(a),this._attachedPortal=o,super.setDisposeFn(()=>{l.parentNode&&l.parentNode.replaceChild(a,l)})},this._document=s}attachComponentPortal(t){const i=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let r;return t.viewContainerRef?(r=t.viewContainerRef.createComponent(i,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector,t.projectableNodes||void 0),this.setDisposeFn(()=>r.destroy())):(r=i.create(t.injector||this._defaultInjector||Li.NULL),this._appRef.attachView(r.hostView),this.setDisposeFn(()=>{this._appRef.viewCount>0&&this._appRef.detachView(r.hostView),r.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(r)),this._attachedPortal=t,r}attachTemplatePortal(t){let e=t.viewContainerRef,i=e.createEmbeddedView(t.templateRef,t.context,{injector:t.injector});return i.rootNodes.forEach(r=>this.outletElement.appendChild(r)),i.detectChanges(),this.setDisposeFn(()=>{let r=e.indexOf(i);-1!==r&&e.remove(r)}),this._attachedPortal=t,i}dispose(){super.dispose(),this.outletElement.remove()}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let YS=(()=>{class n extends qS{constructor(e,i,r){super(),this._componentFactoryResolver=e,this._viewContainerRef=i,this._isInitialized=!1,this.attached=new $t,this.attachDomPortal=s=>{const o=s.element,a=this._document.createComment("dom-portal");s.setAttachedHost(this),o.parentNode.insertBefore(a,o),this._getRootNode().appendChild(o),this._attachedPortal=s,super.setDisposeFn(()=>{a.parentNode&&a.parentNode.replaceChild(o,a)})},this._document=r}get portal(){return this._attachedPortal}set portal(e){this.hasAttached()&&!e&&!this._isInitialized||(this.hasAttached()&&super.detach(),e&&super.attach(e),this._attachedPortal=e||null)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedRef=this._attachedPortal=null}attachComponentPortal(e){e.setAttachedHost(this);const i=null!=e.viewContainerRef?e.viewContainerRef:this._viewContainerRef,s=(e.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(e.component),o=i.createComponent(s,i.length,e.injector||i.injector,e.projectableNodes||void 0);return i!==this._viewContainerRef&&this._getRootNode().appendChild(o.hostView.rootNodes[0]),super.setDisposeFn(()=>o.destroy()),this._attachedPortal=e,this._attachedRef=o,this.attached.emit(o),o}attachTemplatePortal(e){e.setAttachedHost(this);const i=this._viewContainerRef.createEmbeddedView(e.templateRef,e.context,{injector:e.injector});return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=e,this._attachedRef=i,this.attached.emit(i),i}_getRootNode(){const e=this._viewContainerRef.element.nativeElement;return e.nodeType===e.ELEMENT_NODE?e:e.parentNode}}return n.\u0275fac=function(e){return new(e||n)(V(yc),V(As),V(bt))},n.\u0275dir=we({type:n,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[ct]}),n})(),Ac=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({}),n})();const I$=JL();class uoe{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=ui(-this._previousScrollPosition.left),t.style.top=ui(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,i=t.style,r=this._document.body.style,s=i.scrollBehavior||"",o=r.scrollBehavior||"";this._isEnabled=!1,i.left=this._previousHTMLStyles.left,i.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),I$&&(i.scrollBehavior=r.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),I$&&(i.scrollBehavior=s,r.scrollBehavior=o)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const e=this._document.body,i=this._viewportRuler.getViewportSize();return e.scrollHeight>i.height||e.scrollWidth>i.width}}class hoe{constructor(t,e,i,r){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=i,this._config=r,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const e=this._viewportRuler.getViewportScrollPosition().top;Math.abs(e-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class T${enable(){}disable(){}attach(){}}function KS(n,t){return t.some(e=>n.bottom<e.top||n.top>e.bottom||n.right<e.left||n.left>e.right)}function A$(n,t){return t.some(e=>n.top<e.top||n.bottom>e.bottom||n.left<e.left||n.right>e.right)}class poe{constructor(t,e,i,r){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=i,this._config=r,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const e=this._overlayRef.overlayElement.getBoundingClientRect(),{width:i,height:r}=this._viewportRuler.getViewportSize();KS(e,[{width:i,height:r,bottom:r,right:i,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let foe=(()=>{class n{constructor(e,i,r,s){this._scrollDispatcher=e,this._viewportRuler=i,this._ngZone=r,this.noop=()=>new T$,this.close=o=>new hoe(this._scrollDispatcher,this._ngZone,this._viewportRuler,o),this.block=()=>new uoe(this._viewportRuler,this._document),this.reposition=o=>new poe(this._scrollDispatcher,this._viewportRuler,this._ngZone,o),this._document=s}}return n.\u0275fac=function(e){return new(e||n)(Y(jb),Y(jS),Y(Qe),Y(bt))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class M${constructor(t){if(this.scrollStrategy=new T$,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const i of e)void 0!==t[i]&&(this[i]=t[i])}}}class moe{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let N$=(()=>{class n{constructor(e){this._attachedOverlays=[],this._document=e}ngOnDestroy(){this.detach()}add(e){this.remove(e),this._attachedOverlays.push(e)}remove(e){const i=this._attachedOverlays.indexOf(e);i>-1&&this._attachedOverlays.splice(i,1),0===this._attachedOverlays.length&&this.detach()}}return n.\u0275fac=function(e){return new(e||n)(Y(bt))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),goe=(()=>{class n extends N${constructor(e,i){super(e),this._ngZone=i,this._keydownListener=r=>{const s=this._attachedOverlays;for(let o=s.length-1;o>-1;o--)if(s[o]._keydownEvents.observers.length>0){const a=s[o]._keydownEvents;this._ngZone?this._ngZone.run(()=>a.next(r)):a.next(r);break}}}add(e){super.add(e),this._isAttached||(this._ngZone?this._ngZone.runOutsideAngular(()=>this._document.body.addEventListener("keydown",this._keydownListener)):this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return n.\u0275fac=function(e){return new(e||n)(Y(bt),Y(Qe,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),_oe=(()=>{class n extends N${constructor(e,i,r){super(e),this._platform=i,this._ngZone=r,this._cursorStyleIsSet=!1,this._pointerDownListener=s=>{this._pointerDownEventTarget=ll(s)},this._clickListener=s=>{const o=ll(s),a="click"===s.type&&this._pointerDownEventTarget?this._pointerDownEventTarget:o;this._pointerDownEventTarget=null;const l=this._attachedOverlays.slice();for(let c=l.length-1;c>-1;c--){const d=l[c];if(d._outsidePointerEvents.observers.length<1||!d.hasAttached())continue;if(d.overlayElement.contains(o)||d.overlayElement.contains(a))break;const u=d._outsidePointerEvents;this._ngZone?this._ngZone.run(()=>u.next(s)):u.next(s)}}}add(e){if(super.add(e),!this._isAttached){const i=this._document.body;this._ngZone?this._ngZone.runOutsideAngular(()=>this._addEventListeners(i)):this._addEventListeners(i),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=i.style.cursor,i.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const e=this._document.body;e.removeEventListener("pointerdown",this._pointerDownListener,!0),e.removeEventListener("click",this._clickListener,!0),e.removeEventListener("auxclick",this._clickListener,!0),e.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(e.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}_addEventListeners(e){e.addEventListener("pointerdown",this._pointerDownListener,!0),e.addEventListener("click",this._clickListener,!0),e.addEventListener("auxclick",this._clickListener,!0),e.addEventListener("contextmenu",this._clickListener,!0)}}return n.\u0275fac=function(e){return new(e||n)(Y(bt),Y(Ar),Y(Qe,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Wb=(()=>{class n{constructor(e,i){this._platform=i,this._document=e}ngOnDestroy(){this._containerElement?.remove()}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const e="cdk-overlay-container";if(this._platform.isBrowser||MS()){const r=this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`);for(let s=0;s<r.length;s++)r[s].remove()}const i=this._document.createElement("div");i.classList.add(e),MS()?i.setAttribute("platform","test"):this._platform.isBrowser||i.setAttribute("platform","server"),this._document.body.appendChild(i),this._containerElement=i}}return n.\u0275fac=function(e){return new(e||n)(Y(bt),Y(Ar))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class Yp{constructor(t,e,i,r,s,o,a,l,c,d=!1){this._portalOutlet=t,this._host=e,this._pane=i,this._config=r,this._ngZone=s,this._keyboardDispatcher=o,this._document=a,this._location=l,this._outsideClickDispatcher=c,this._animationsDisabled=d,this._backdropElement=null,this._backdropClick=new dt,this._attachments=new dt,this._detachments=new dt,this._locationChanges=U.EMPTY,this._backdropClickHandler=u=>this._backdropClick.next(u),this._backdropTransitionendHandler=u=>{this._disposeBackdrop(u.target)},this._keydownEvents=new dt,this._outsidePointerEvents=new dt,r.scrollStrategy&&(this._scrollStrategy=r.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=r.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host);const e=this._portalOutlet.attach(t);return this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(fo(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),"function"==typeof e?.onDestroy&&e.onDestroy(()=>{this.hasAttached()&&this._ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>this.detach()))}),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this._disposeBackdrop(this._backdropElement),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host?.remove(),this._previousHostParent=this._pane=this._host=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config={...this._config,...t},this._updateElementSize()}setDirection(t){this._config={...this._config,direction:t},this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=ui(this._config.width),t.height=ui(this._config.height),t.minWidth=ui(this._config.minWidth),t.minHeight=ui(this._config.minHeight),t.maxWidth=ui(this._config.maxWidth),t.maxHeight=ui(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._animationsDisabled&&this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),!this._animationsDisabled&&typeof requestAnimationFrame<"u"?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){const t=this._backdropElement;if(t){if(this._animationsDisabled)return void this._disposeBackdrop(t);t.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{t.addEventListener("transitionend",this._backdropTransitionendHandler)}),t.style.pointerEvents="none",this._backdropTimeout=this._ngZone.runOutsideAngular(()=>setTimeout(()=>{this._disposeBackdrop(t)},500))}}_toggleClasses(t,e,i){const r=Pb(e||[]).filter(s=>!!s);r.length&&(i?t.classList.add(...r):t.classList.remove(...r))}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(Ic(n_(this._attachments,this._detachments))).subscribe(()=>{(!this._pane||!this._host||0===this._pane.children.length)&&(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._host.remove()),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}_disposeBackdrop(t){t&&(t.removeEventListener("click",this._backdropClickHandler),t.removeEventListener("transitionend",this._backdropTransitionendHandler),t.remove(),this._backdropElement===t&&(this._backdropElement=null)),this._backdropTimeout&&(clearTimeout(this._backdropTimeout),this._backdropTimeout=void 0)}}const R$="cdk-overlay-connected-position-bounding-box",boe=/([A-Za-z%]+)$/;class yoe{get positions(){return this._preferredPositions}constructor(t,e,i,r,s){this._viewportRuler=e,this._document=i,this._platform=r,this._overlayContainer=s,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new dt,this._resizeSubscription=U.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}attach(t){this._validatePositions(),t.hostElement.classList.add(R$),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const t=this._originRect,e=this._overlayRect,i=this._viewportRect,r=this._containerRect,s=[];let o;for(let a of this._preferredPositions){let l=this._getOriginPoint(t,r,a),c=this._getOverlayPoint(l,e,a),d=this._getOverlayFit(c,e,i,a);if(d.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(a,l);this._canFitWithFlexibleDimensions(d,c,i)?s.push({position:a,origin:l,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(l,a)}):(!o||o.overlayFit.visibleArea<d.visibleArea)&&(o={overlayFit:d,overlayPoint:c,originPoint:l,position:a,overlayRect:e})}if(s.length){let a=null,l=-1;for(const c of s){const d=c.boundingBoxRect.width*c.boundingBoxRect.height*(c.position.weight||1);d>l&&(l=d,a=c)}return this._isPushed=!1,void this._applyPosition(a.position,a.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(o.position,o.originPoint);this._applyPosition(o.position,o.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&Mc(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(R$),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(this._isDisposed||!this._platform.isBrowser)return;const t=this._lastPosition;if(t){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const e=this._getOriginPoint(this._originRect,this._containerRect,t);this._applyPosition(t,e)}else this.apply()}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e,i){let r,s;if("center"==i.originX)r=t.left+t.width/2;else{const o=this._isRtl()?t.right:t.left,a=this._isRtl()?t.left:t.right;r="start"==i.originX?o:a}return e.left<0&&(r-=e.left),s="center"==i.originY?t.top+t.height/2:"top"==i.originY?t.top:t.bottom,e.top<0&&(s-=e.top),{x:r,y:s}}_getOverlayPoint(t,e,i){let r,s;return r="center"==i.overlayX?-e.width/2:"start"===i.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,s="center"==i.overlayY?-e.height/2:"top"==i.overlayY?0:-e.height,{x:t.x+r,y:t.y+s}}_getOverlayFit(t,e,i,r){const s=F$(e);let{x:o,y:a}=t,l=this._getOffset(r,"x"),c=this._getOffset(r,"y");l&&(o+=l),c&&(a+=c);let h=0-a,p=a+s.height-i.height,f=this._subtractOverflows(s.width,0-o,o+s.width-i.width),m=this._subtractOverflows(s.height,h,p),g=f*m;return{visibleArea:g,isCompletelyWithinViewport:s.width*s.height===g,fitsInViewportVertically:m===s.height,fitsInViewportHorizontally:f==s.width}}_canFitWithFlexibleDimensions(t,e,i){if(this._hasFlexibleDimensions){const r=i.bottom-e.y,s=i.right-e.x,o=O$(this._overlayRef.getConfig().minHeight),a=O$(this._overlayRef.getConfig().minWidth);return(t.fitsInViewportVertically||null!=o&&o<=r)&&(t.fitsInViewportHorizontally||null!=a&&a<=s)}return!1}_pushOverlayOnScreen(t,e,i){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const r=F$(e),s=this._viewportRect,o=Math.max(t.x+r.width-s.width,0),a=Math.max(t.y+r.height-s.height,0),l=Math.max(s.top-i.top-t.y,0),c=Math.max(s.left-i.left-t.x,0);let d=0,u=0;return d=r.width<=s.width?c||-o:t.x<this._viewportMargin?s.left-i.left-t.x:0,u=r.height<=s.height?l||-a:t.y<this._viewportMargin?s.top-i.top-t.y:0,this._previousPushAmount={x:d,y:u},{x:t.x+d,y:t.y+u}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const i=this._getScrollVisibility(),r=new moe(t,i);this._positionChanges.next(r)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let i,r=t.overlayY;i="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let s=0;s<e.length;s++)e[s].style.transformOrigin=`${i} ${r}`}_calculateBoundingBoxRect(t,e){const i=this._viewportRect,r=this._isRtl();let s,o,a,d,u,h;if("top"===e.overlayY)o=t.y,s=i.height-o+this._viewportMargin;else if("bottom"===e.overlayY)a=i.height-t.y+2*this._viewportMargin,s=i.height-a+this._viewportMargin;else{const p=Math.min(i.bottom-t.y+i.top,t.y),f=this._lastBoundingBoxSize.height;s=2*p,o=t.y-p,s>f&&!this._isInitialRender&&!this._growAfterOpen&&(o=t.y-f/2)}if("end"===e.overlayX&&!r||"start"===e.overlayX&&r)h=i.width-t.x+this._viewportMargin,d=t.x-this._viewportMargin;else if("start"===e.overlayX&&!r||"end"===e.overlayX&&r)u=t.x,d=i.right-t.x;else{const p=Math.min(i.right-t.x+i.left,t.x),f=this._lastBoundingBoxSize.width;d=2*p,u=t.x-p,d>f&&!this._isInitialRender&&!this._growAfterOpen&&(u=t.x-f/2)}return{top:o,left:u,bottom:a,right:h,width:d,height:s}}_setBoundingBoxStyles(t,e){const i=this._calculateBoundingBoxRect(t,e);!this._isInitialRender&&!this._growAfterOpen&&(i.height=Math.min(i.height,this._lastBoundingBoxSize.height),i.width=Math.min(i.width,this._lastBoundingBoxSize.width));const r={};if(this._hasExactPosition())r.top=r.left="0",r.bottom=r.right=r.maxHeight=r.maxWidth="",r.width=r.height="100%";else{const s=this._overlayRef.getConfig().maxHeight,o=this._overlayRef.getConfig().maxWidth;r.height=ui(i.height),r.top=ui(i.top),r.bottom=ui(i.bottom),r.width=ui(i.width),r.left=ui(i.left),r.right=ui(i.right),r.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",r.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",s&&(r.maxHeight=ui(s)),o&&(r.maxWidth=ui(o))}this._lastBoundingBoxSize=i,Mc(this._boundingBox.style,r)}_resetBoundingBoxStyles(){Mc(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){Mc(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const i={},r=this._hasExactPosition(),s=this._hasFlexibleDimensions,o=this._overlayRef.getConfig();if(r){const d=this._viewportRuler.getViewportScrollPosition();Mc(i,this._getExactOverlayY(e,t,d)),Mc(i,this._getExactOverlayX(e,t,d))}else i.position="static";let a="",l=this._getOffset(e,"x"),c=this._getOffset(e,"y");l&&(a+=`translateX(${l}px) `),c&&(a+=`translateY(${c}px)`),i.transform=a.trim(),o.maxHeight&&(r?i.maxHeight=ui(o.maxHeight):s&&(i.maxHeight="")),o.maxWidth&&(r?i.maxWidth=ui(o.maxWidth):s&&(i.maxWidth="")),Mc(this._pane.style,i)}_getExactOverlayY(t,e,i){let r={top:"",bottom:""},s=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(s=this._pushOverlayOnScreen(s,this._overlayRect,i)),"bottom"===t.overlayY?r.bottom=this._document.documentElement.clientHeight-(s.y+this._overlayRect.height)+"px":r.top=ui(s.y),r}_getExactOverlayX(t,e,i){let o,r={left:"",right:""},s=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(s=this._pushOverlayOnScreen(s,this._overlayRect,i)),o=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===o?r.right=this._document.documentElement.clientWidth-(s.x+this._overlayRect.width)+"px":r.left=ui(s.x),r}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),i=this._scrollables.map(r=>r.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:A$(t,i),isOriginOutsideView:KS(t,i),isOverlayClipped:A$(e,i),isOverlayOutsideView:KS(e,i)}}_subtractOverflows(t,...e){return e.reduce((i,r)=>i-Math.max(r,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,i=this._viewportRuler.getViewportScrollPosition();return{top:i.top+this._viewportMargin,left:i.left+this._viewportMargin,right:i.left+t-this._viewportMargin,bottom:i.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&Pb(t).forEach(e=>{""!==e&&-1===this._appliedPanelClasses.indexOf(e)&&(this._appliedPanelClasses.push(e),this._pane.classList.add(e))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof Pt)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,i=t.height||0;return{top:t.y,bottom:t.y+i,left:t.x,right:t.x+e,height:i,width:e}}}function Mc(n,t){for(let e in t)t.hasOwnProperty(e)&&(n[e]=t[e]);return n}function O$(n){if("number"!=typeof n&&null!=n){const[t,e]=n.split(boe);return e&&"px"!==e?null:parseFloat(t)}return n||null}function F$(n){return{top:Math.floor(n.top),right:Math.floor(n.right),bottom:Math.floor(n.bottom),left:Math.floor(n.left),width:Math.floor(n.width),height:Math.floor(n.height)}}const P$="cdk-global-overlay-wrapper";class voe{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._alignItems="",this._xPosition="",this._xOffset="",this._width="",this._height="",this._isDisposed=!1}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(P$),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._xOffset=t,this._xPosition="left",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._xOffset=t,this._xPosition="right",this}start(t=""){return this._xOffset=t,this._xPosition="start",this}end(t=""){return this._xOffset=t,this._xPosition="end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._xPosition="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,i=this._overlayRef.getConfig(),{width:r,height:s,maxWidth:o,maxHeight:a}=i,l=!("100%"!==r&&"100vw"!==r||o&&"100%"!==o&&"100vw"!==o),c=!("100%"!==s&&"100vh"!==s||a&&"100%"!==a&&"100vh"!==a),d=this._xPosition,u=this._xOffset,h="rtl"===this._overlayRef.getConfig().direction;let p="",f="",m="";l?m="flex-start":"center"===d?(m="center",h?f=u:p=u):h?"left"===d||"end"===d?(m="flex-end",p=u):("right"===d||"start"===d)&&(m="flex-start",f=u):"left"===d||"start"===d?(m="flex-start",p=u):("right"===d||"end"===d)&&(m="flex-end",f=u),t.position=this._cssPosition,t.marginLeft=l?"0":p,t.marginTop=c?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=l?"0":f,e.justifyContent=m,e.alignItems=c?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,i=e.style;e.classList.remove(P$),i.justifyContent=i.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let xoe=(()=>{class n{constructor(e,i,r,s){this._viewportRuler=e,this._document=i,this._platform=r,this._overlayContainer=s}global(){return new voe}flexibleConnectedTo(e){return new yoe(e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return n.\u0275fac=function(e){return new(e||n)(Y(jS),Y(bt),Y(Ar),Y(Wb))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),woe=0,cl=(()=>{class n{constructor(e,i,r,s,o,a,l,c,d,u,h,p){this.scrollStrategies=e,this._overlayContainer=i,this._componentFactoryResolver=r,this._positionBuilder=s,this._keyboardDispatcher=o,this._injector=a,this._ngZone=l,this._document=c,this._directionality=d,this._location=u,this._outsideClickDispatcher=h,this._animationsModuleType=p}create(e){const i=this._createHostElement(),r=this._createPaneElement(i),s=this._createPortalOutlet(r),o=new M$(e);return o.direction=o.direction||this._directionality.value,new Yp(s,i,r,o,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher,"NoopAnimations"===this._animationsModuleType)}position(){return this._positionBuilder}_createPaneElement(e){const i=this._document.createElement("div");return i.id="cdk-overlay-"+woe++,i.classList.add("cdk-overlay-pane"),e.appendChild(i),i}_createHostElement(){const e=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(e),e}_createPortalOutlet(e){return this._appRef||(this._appRef=this._injector.get(gu)),new doe(e,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return n.\u0275fac=function(e){return new(e||n)(Y(foe),Y(Wb),Y(yc),Y(xoe),Y(goe),Y(Li),Y(Qe),Y(bt),Y(Du),Y(Pp),Y(_oe),Y(Da,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Soe={provide:new ne("cdk-connected-overlay-scroll-strategy"),deps:[cl],useFactory:function Doe(n){return()=>n.scrollStrategies.reposition()}};let Kp=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({providers:[cl,Soe],imports:[qp,Ac,k$,k$]}),n})();function Gb(n){return new Ze(t=>{Cr(n()).subscribe(t)})}function koe(n,t){}class qb{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.ariaModal=!0,this.autoFocus="first-tabbable",this.restoreFocus=!0,this.closeOnNavigation=!0,this.closeOnDestroy=!0,this.closeOnOverlayDetachments=!0}}let L$=(()=>{class n extends qS{constructor(e,i,r,s,o,a,l,c){super(),this._elementRef=e,this._focusTrapFactory=i,this._config=s,this._interactivityChecker=o,this._ngZone=a,this._overlayRef=l,this._focusMonitor=c,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this.attachDomPortal=d=>{this._portalOutlet.hasAttached();const u=this._portalOutlet.attachDomPortal(d);return this._contentAttached(),u},this._ariaLabelledBy=this._config.ariaLabelledBy||null,this._document=r}_contentAttached(){this._initializeFocusTrap(),this._handleBackdropClicks(),this._captureInitialFocus()}_captureInitialFocus(){this._trapFocus()}ngOnDestroy(){this._restoreFocus()}attachComponentPortal(e){this._portalOutlet.hasAttached();const i=this._portalOutlet.attachComponentPortal(e);return this._contentAttached(),i}attachTemplatePortal(e){this._portalOutlet.hasAttached();const i=this._portalOutlet.attachTemplatePortal(e);return this._contentAttached(),i}_recaptureFocus(){this._containsFocus()||this._trapFocus()}_forceFocus(e,i){this._interactivityChecker.isFocusable(e)||(e.tabIndex=-1,this._ngZone.runOutsideAngular(()=>{const r=()=>{e.removeEventListener("blur",r),e.removeEventListener("mousedown",r),e.removeAttribute("tabindex")};e.addEventListener("blur",r),e.addEventListener("mousedown",r)})),e.focus(i)}_focusByCssSelector(e,i){let r=this._elementRef.nativeElement.querySelector(e);r&&this._forceFocus(r,i)}_trapFocus(){const e=this._elementRef.nativeElement;switch(this._config.autoFocus){case!1:case"dialog":this._containsFocus()||e.focus();break;case!0:case"first-tabbable":this._focusTrap.focusInitialElementWhenReady().then(i=>{i||this._focusDialogContainer()});break;case"first-heading":this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');break;default:this._focusByCssSelector(this._config.autoFocus)}}_restoreFocus(){const e=this._config.restoreFocus;let i=null;if("string"==typeof e?i=this._document.querySelector(e):"boolean"==typeof e?i=e?this._elementFocusedBeforeDialogWasOpened:null:e&&(i=e),this._config.restoreFocus&&i&&"function"==typeof i.focus){const r=Rb(),s=this._elementRef.nativeElement;(!r||r===this._document.body||r===s||s.contains(r))&&(this._focusMonitor?(this._focusMonitor.focusVia(i,this._closeInteractionType),this._closeInteractionType=null):i.focus())}this._focusTrap&&this._focusTrap.destroy()}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const e=this._elementRef.nativeElement,i=Rb();return e===i||e.contains(i)}_initializeFocusTrap(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._document&&(this._elementFocusedBeforeDialogWasOpened=Rb())}_handleBackdropClicks(){this._overlayRef.backdropClick().subscribe(()=>{this._config.disableClose&&this._recaptureFocus()})}}return n.\u0275fac=function(e){return new(e||n)(V(Pt),V(VS),V(bt,8),V(qb),V($b),V(Qe),V(Yp),V(Bb))},n.\u0275cmp=bi({type:n,selectors:[["cdk-dialog-container"]],viewQuery:function(e,i){if(1&e&&pu(YS,7),2&e){let r;Ms(r=Ns())&&(i._portalOutlet=r.first)}},hostAttrs:["tabindex","-1",1,"cdk-dialog-container"],hostVars:6,hostBindings:function(e,i){2&e&&$i("id",i._config.id||null)("role",i._config.role)("aria-modal",i._config.ariaModal)("aria-labelledby",i._config.ariaLabel?null:i._ariaLabelledBy)("aria-label",i._config.ariaLabel)("aria-describedby",i._config.ariaDescribedBy||null)},features:[ct],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(e,i){1&e&&wi(0,koe,0,0,"ng-template",0)},dependencies:[YS],styles:[".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"],encapsulation:2}),n})();class XS{constructor(t,e){this.overlayRef=t,this.config=e,this.closed=new dt,this.disableClose=e.disableClose,this.backdropClick=t.backdropClick(),this.keydownEvents=t.keydownEvents(),this.outsidePointerEvents=t.outsidePointerEvents(),this.id=e.id,this.keydownEvents.subscribe(i=>{27===i.keyCode&&!this.disableClose&&!xu(i)&&(i.preventDefault(),this.close(void 0,{focusOrigin:"keyboard"}))}),this.backdropClick.subscribe(()=>{this.disableClose||this.close(void 0,{focusOrigin:"mouse"})}),this._detachSubscription=t.detachments().subscribe(()=>{!1!==e.closeOnOverlayDetachments&&this.close()})}close(t,e){if(this.containerInstance){const i=this.closed;this.containerInstance._closeInteractionType=e?.focusOrigin||"program",this._detachSubscription.unsubscribe(),this.overlayRef.dispose(),i.next(t),i.complete(),this.componentInstance=this.containerInstance=null}}updatePosition(){return this.overlayRef.updatePosition(),this}updateSize(t="",e=""){return this.overlayRef.updateSize({width:t,height:e}),this}addPanelClass(t){return this.overlayRef.addPanelClass(t),this}removePanelClass(t){return this.overlayRef.removePanelClass(t),this}}const $$=new ne("DialogScrollStrategy"),Eoe=new ne("DialogData"),Ioe=new ne("DefaultDialogConfig"),Aoe={provide:$$,deps:[cl],useFactory:function Toe(n){return()=>n.scrollStrategies.block()}};let Moe=0,V$=(()=>{class n{get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}constructor(e,i,r,s,o,a){this._overlay=e,this._injector=i,this._defaultOptions=r,this._parentDialog=s,this._overlayContainer=o,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new dt,this._afterOpenedAtThisLevel=new dt,this._ariaHiddenElements=new Map,this.afterAllClosed=Gb(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Wp(void 0))),this._scrollStrategy=a}open(e,i){(i={...this._defaultOptions||new qb,...i}).id=i.id||"cdk-dialog-"+Moe++,i.id&&this.getDialogById(i.id);const s=this._getOverlayConfig(i),o=this._overlay.create(s),a=new XS(o,i),l=this._attachContainer(o,a,i);return a.containerInstance=l,this._attachDialogContent(e,a,l,i),this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(a),a.closed.subscribe(()=>this._removeOpenDialog(a,!0)),this.afterOpened.next(a),a}closeAll(){ZS(this.openDialogs,e=>e.close())}getDialogById(e){return this.openDialogs.find(i=>i.id===e)}ngOnDestroy(){ZS(this._openDialogsAtThisLevel,e=>{!1===e.config.closeOnDestroy&&this._removeOpenDialog(e,!1)}),ZS(this._openDialogsAtThisLevel,e=>e.close()),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete(),this._openDialogsAtThisLevel=[]}_getOverlayConfig(e){const i=new M$({positionStrategy:e.positionStrategy||this._overlay.position().global().centerHorizontally().centerVertically(),scrollStrategy:e.scrollStrategy||this._scrollStrategy(),panelClass:e.panelClass,hasBackdrop:e.hasBackdrop,direction:e.direction,minWidth:e.minWidth,minHeight:e.minHeight,maxWidth:e.maxWidth,maxHeight:e.maxHeight,width:e.width,height:e.height,disposeOnNavigation:e.closeOnNavigation});return e.backdropClass&&(i.backdropClass=e.backdropClass),i}_attachContainer(e,i,r){const s=r.injector||r.viewContainerRef?.injector,o=[{provide:qb,useValue:r},{provide:XS,useValue:i},{provide:Yp,useValue:e}];let a;r.container?"function"==typeof r.container?a=r.container:(a=r.container.type,o.push(...r.container.providers(r))):a=L$;const l=new GS(a,r.viewContainerRef,Li.create({parent:s||this._injector,providers:o}),r.componentFactoryResolver);return e.attach(l).instance}_attachDialogContent(e,i,r,s){if(e instanceof zo){const o=this._createInjector(s,i,r,void 0);let a={$implicit:s.data,dialogRef:i};s.templateContext&&(a={...a,..."function"==typeof s.templateContext?s.templateContext():s.templateContext}),r.attachTemplatePortal(new E$(e,null,a,o))}else{const o=this._createInjector(s,i,r,this._injector),a=r.attachComponentPortal(new GS(e,s.viewContainerRef,o,s.componentFactoryResolver));i.componentInstance=a.instance}}_createInjector(e,i,r,s){const o=e.injector||e.viewContainerRef?.injector,a=[{provide:Eoe,useValue:e.data},{provide:XS,useValue:i}];return e.providers&&("function"==typeof e.providers?a.push(...e.providers(i,e,r)):a.push(...e.providers)),e.direction&&(!o||!o.get(Du,null,{optional:!0}))&&a.push({provide:Du,useValue:{value:e.direction,change:Fe()}}),Li.create({parent:o||s,providers:a})}_removeOpenDialog(e,i){const r=this.openDialogs.indexOf(e);r>-1&&(this.openDialogs.splice(r,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((s,o)=>{s?o.setAttribute("aria-hidden",s):o.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),i&&this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const e=this._overlayContainer.getContainerElement();if(e.parentElement){const i=e.parentElement.children;for(let r=i.length-1;r>-1;r--){const s=i[r];s!==e&&"SCRIPT"!==s.nodeName&&"STYLE"!==s.nodeName&&!s.hasAttribute("aria-live")&&(this._ariaHiddenElements.set(s,s.getAttribute("aria-hidden")),s.setAttribute("aria-hidden","true"))}}}_getAfterAllClosed(){const e=this._parentDialog;return e?e._getAfterAllClosed():this._afterAllClosedAtThisLevel}}return n.\u0275fac=function(e){return new(e||n)(Y(cl),Y(Li),Y(Ioe,8),Y(n,12),Y(Wb),Y($$))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();function ZS(n,t){let e=n.length;for(;e--;)t(n[e])}let B$=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({providers:[V$,Aoe],imports:[Kp,Ac,zS,Ac]}),n})();const Rc=new ne("CallSetDisabledState",{providedIn:"root",factory:()=>Qp}),Qp="always";let IV=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({}),n})();const pk=new ne("NgModelWithFormControlWarning");let WV=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[IV]}),n})(),Oae=(()=>{class n{static withConfig(e){return{ngModule:n,providers:[{provide:Rc,useValue:e.callSetDisabledState??Qp}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[WV]}),n})(),Fae=(()=>{class n{static withConfig(e){return{ngModule:n,providers:[{provide:pk,useValue:e.warnOnNgModelWithFormControl??"always"},{provide:Rc,useValue:e.callSetDisabledState??Qp}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[WV]}),n})();function Aa(){}const Pae=function(){let n=0;return function(){return n++}}();function Vt(n){return null===n||typeof n>"u"}function bn(n){if(Array.isArray&&Array.isArray(n))return!0;const t=Object.prototype.toString.call(n);return"[object"===t.slice(0,7)&&"Array]"===t.slice(-6)}function Tt(n){return null!==n&&"[object Object]"===Object.prototype.toString.call(n)}const ni=n=>("number"==typeof n||n instanceof Number)&&isFinite(+n);function Ps(n,t){return ni(n)?n:t}function ft(n,t){return typeof n>"u"?t:n}const GV=(n,t)=>"string"==typeof n&&n.endsWith("%")?parseFloat(n)/100*t:+n;function yn(n,t,e){if(n&&"function"==typeof n.call)return n.apply(e,t)}function en(n,t,e,i){let r,s,o;if(bn(n))if(s=n.length,i)for(r=s-1;r>=0;r--)t.call(e,n[r],r);else for(r=0;r<s;r++)t.call(e,n[r],r);else if(Tt(n))for(o=Object.keys(n),s=o.length,r=0;r<s;r++)t.call(e,n[o[r]],o[r])}function iy(n,t){let e,i,r,s;if(!n||!t||n.length!==t.length)return!1;for(e=0,i=n.length;e<i;++e)if(r=n[e],s=t[e],r.datasetIndex!==s.datasetIndex||r.index!==s.index)return!1;return!0}function ry(n){if(bn(n))return n.map(ry);if(Tt(n)){const t=Object.create(null),e=Object.keys(n),i=e.length;let r=0;for(;r<i;++r)t[e[r]]=ry(n[e[r]]);return t}return n}function qV(n){return-1===["__proto__","prototype","constructor"].indexOf(n)}function $ae(n,t,e,i){if(!qV(n))return;const r=t[n],s=e[n];Tt(r)&&Tt(s)?nf(r,s,i):t[n]=ry(s)}function nf(n,t,e){const i=bn(t)?t:[t],r=i.length;if(!Tt(n))return n;const s=(e=e||{}).merger||$ae;for(let o=0;o<r;++o){if(!Tt(t=i[o]))continue;const a=Object.keys(t);for(let l=0,c=a.length;l<c;++l)s(a[l],n,t,e)}return n}function rf(n,t){return nf(n,t,{merger:Vae})}function Vae(n,t,e){if(!qV(n))return;const i=t[n],r=e[n];Tt(i)&&Tt(r)?rf(i,r):Object.prototype.hasOwnProperty.call(t,n)||(t[n]=ry(r))}const YV={"":n=>n,x:n=>n.x,y:n=>n.y};function pl(n,t){return(YV[t]||(YV[t]=function Bae(n){const t=function zae(n){const t=n.split("."),e=[];let i="";for(const r of t)i+=r,i.endsWith("\\")?i=i.slice(0,-1)+".":(e.push(i),i="");return e}(n);return e=>{for(const i of t){if(""===i)break;e=e&&e[i]}return e}}(t)))(n)}function vk(n){return n.charAt(0).toUpperCase()+n.slice(1)}const Ls=n=>typeof n<"u",fl=n=>"function"==typeof n,KV=(n,t)=>{if(n.size!==t.size)return!1;for(const e of n)if(!t.has(e))return!1;return!0},Mn=Math.PI,sn=2*Mn,Hae=sn+Mn,sy=Number.POSITIVE_INFINITY,jae=Mn/180,Gn=Mn/2,sf=Mn/4,XV=2*Mn/3,$s=Math.log10,Ho=Math.sign;function ZV(n){const t=Math.round(n);n=af(n,t,n/1e3)?t:n;const e=Math.pow(10,Math.floor($s(n))),i=n/e;return(i<=1?1:i<=2?2:i<=5?5:10)*e}function Eu(n){return!isNaN(parseFloat(n))&&isFinite(n)}function af(n,t,e){return Math.abs(n-t)<e}function QV(n,t,e){let i,r,s;for(i=0,r=n.length;i<r;i++)s=n[i][e],isNaN(s)||(t.min=Math.min(t.min,s),t.max=Math.max(t.max,s))}function mo(n){return n*(Mn/180)}function xk(n){return n*(180/Mn)}function JV(n){if(!ni(n))return;let t=1,e=0;for(;Math.round(n*t)/t!==n;)t*=10,e++;return e}function eB(n,t){const e=t.x-n.x,i=t.y-n.y,r=Math.sqrt(e*e+i*i);let s=Math.atan2(i,e);return s<-.5*Mn&&(s+=sn),{angle:s,distance:r}}function wk(n,t){return Math.sqrt(Math.pow(t.x-n.x,2)+Math.pow(t.y-n.y,2))}function qae(n,t){return(n-t+Hae)%sn-Mn}function ds(n){return(n%sn+sn)%sn}function lf(n,t,e,i){const r=ds(n),s=ds(t),o=ds(e),a=ds(s-r),l=ds(o-r),c=ds(r-s),d=ds(r-o);return r===s||r===o||i&&s===o||a>l&&c<d}function Bi(n,t,e){return Math.max(t,Math.min(e,n))}function Ma(n,t,e,i=1e-6){return n>=Math.min(t,e)-i&&n<=Math.max(t,e)+i}function Ck(n,t,e){e=e||(o=>n[o]<t);let s,i=n.length-1,r=0;for(;i-r>1;)s=r+i>>1,e(s)?r=s:i=s;return{lo:r,hi:i}}const Na=(n,t,e,i)=>Ck(n,e,i?r=>n[r][t]<=e:r=>n[r][t]<e),Kae=(n,t,e)=>Ck(n,e,i=>n[i][t]>=e),tB=["push","pop","shift","splice","unshift"];function nB(n,t){const e=n._chartjs;if(!e)return;const i=e.listeners,r=i.indexOf(t);-1!==r&&i.splice(r,1),!(i.length>0)&&(tB.forEach(s=>{delete n[s]}),delete n._chartjs)}function iB(n){const t=new Set;let e,i;for(e=0,i=n.length;e<i;++e)t.add(n[e]);return t.size===i?n:Array.from(t)}const rB=typeof window>"u"?function(n){return n()}:window.requestAnimationFrame;function sB(n,t,e){const i=e||(o=>Array.prototype.slice.call(o));let r=!1,s=[];return function(...o){s=i(o),r||(r=!0,rB.call(window,()=>{r=!1,n.apply(t,s)}))}}const Dk=n=>"start"===n?"left":"end"===n?"right":"center",cr=(n,t,e)=>"start"===n?t:"end"===n?e:(t+e)/2;function oB(n,t,e){const i=t.length;let r=0,s=i;if(n._sorted){const{iScale:o,_parsed:a}=n,l=o.axis,{min:c,max:d,minDefined:u,maxDefined:h}=o.getUserBounds();u&&(r=Bi(Math.min(Na(a,o.axis,c).lo,e?i:Na(t,l,o.getPixelForValue(c)).lo),0,i-1)),s=h?Bi(Math.max(Na(a,o.axis,d,!0).hi+1,e?0:Na(t,l,o.getPixelForValue(d),!0).hi+1),r,i)-r:i-r}return{start:r,count:s}}function aB(n){const{xScale:t,yScale:e,_scaleRanges:i}=n,r={xmin:t.min,xmax:t.max,ymin:e.min,ymax:e.max};if(!i)return n._scaleRanges=r,!0;const s=i.xmin!==t.min||i.xmax!==t.max||i.ymin!==e.min||i.ymax!==e.max;return Object.assign(i,r),s}const oy=n=>0===n||1===n,lB=(n,t,e)=>-Math.pow(2,10*(n-=1))*Math.sin((n-t)*sn/e),cB=(n,t,e)=>Math.pow(2,-10*n)*Math.sin((n-t)*sn/e)+1,cf={linear:n=>n,easeInQuad:n=>n*n,easeOutQuad:n=>-n*(n-2),easeInOutQuad:n=>(n/=.5)<1?.5*n*n:-.5*(--n*(n-2)-1),easeInCubic:n=>n*n*n,easeOutCubic:n=>(n-=1)*n*n+1,easeInOutCubic:n=>(n/=.5)<1?.5*n*n*n:.5*((n-=2)*n*n+2),easeInQuart:n=>n*n*n*n,easeOutQuart:n=>-((n-=1)*n*n*n-1),easeInOutQuart:n=>(n/=.5)<1?.5*n*n*n*n:-.5*((n-=2)*n*n*n-2),easeInQuint:n=>n*n*n*n*n,easeOutQuint:n=>(n-=1)*n*n*n*n+1,easeInOutQuint:n=>(n/=.5)<1?.5*n*n*n*n*n:.5*((n-=2)*n*n*n*n+2),easeInSine:n=>1-Math.cos(n*Gn),easeOutSine:n=>Math.sin(n*Gn),easeInOutSine:n=>-.5*(Math.cos(Mn*n)-1),easeInExpo:n=>0===n?0:Math.pow(2,10*(n-1)),easeOutExpo:n=>1===n?1:1-Math.pow(2,-10*n),easeInOutExpo:n=>oy(n)?n:n<.5?.5*Math.pow(2,10*(2*n-1)):.5*(2-Math.pow(2,-10*(2*n-1))),easeInCirc:n=>n>=1?n:-(Math.sqrt(1-n*n)-1),easeOutCirc:n=>Math.sqrt(1-(n-=1)*n),easeInOutCirc:n=>(n/=.5)<1?-.5*(Math.sqrt(1-n*n)-1):.5*(Math.sqrt(1-(n-=2)*n)+1),easeInElastic:n=>oy(n)?n:lB(n,.075,.3),easeOutElastic:n=>oy(n)?n:cB(n,.075,.3),easeInOutElastic:n=>oy(n)?n:n<.5?.5*lB(2*n,.1125,.45):.5+.5*cB(2*n-1,.1125,.45),easeInBack:n=>n*n*(2.70158*n-1.70158),easeOutBack:n=>(n-=1)*n*(2.70158*n+1.70158)+1,easeInOutBack(n){let t=1.70158;return(n/=.5)<1?n*n*((1+(t*=1.525))*n-t)*.5:.5*((n-=2)*n*((1+(t*=1.525))*n+t)+2)},easeInBounce:n=>1-cf.easeOutBounce(1-n),easeOutBounce:n=>n<1/2.75?7.5625*n*n:n<2/2.75?7.5625*(n-=1.5/2.75)*n+.75:n<2.5/2.75?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375,easeInOutBounce:n=>n<.5?.5*cf.easeInBounce(2*n):.5*cf.easeOutBounce(2*n-1)+.5};function df(n){return n+.5|0}const ml=(n,t,e)=>Math.max(Math.min(n,e),t);function uf(n){return ml(df(2.55*n),0,255)}function gl(n){return ml(df(255*n),0,255)}function Ra(n){return ml(df(n/2.55)/100,0,1)}function dB(n){return ml(df(100*n),0,100)}const Vs={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},Sk=[..."0123456789ABCDEF"],ele=n=>Sk[15&n],tle=n=>Sk[(240&n)>>4]+Sk[15&n],ay=n=>(240&n)>>4==(15&n),ole=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function uB(n,t,e){const i=t*Math.min(e,1-e),r=(s,o=(s+n/30)%12)=>e-i*Math.max(Math.min(o-3,9-o,1),-1);return[r(0),r(8),r(4)]}function ale(n,t,e){const i=(r,s=(r+n/60)%6)=>e-e*t*Math.max(Math.min(s,4-s,1),0);return[i(5),i(3),i(1)]}function lle(n,t,e){const i=uB(n,1,.5);let r;for(t+e>1&&(r=1/(t+e),t*=r,e*=r),r=0;r<3;r++)i[r]*=1-t-e,i[r]+=t;return i}function kk(n){const e=n.r/255,i=n.g/255,r=n.b/255,s=Math.max(e,i,r),o=Math.min(e,i,r),a=(s+o)/2;let l,c,d;return s!==o&&(d=s-o,c=a>.5?d/(2-s-o):d/(s+o),l=function cle(n,t,e,i,r){return n===r?(t-e)/i+(t<e?6:0):t===r?(e-n)/i+2:(n-t)/i+4}(e,i,r,d,s),l=60*l+.5),[0|l,c||0,a]}function Ek(n,t,e,i){return(Array.isArray(t)?n(t[0],t[1],t[2]):n(t,e,i)).map(gl)}function Ik(n,t,e){return Ek(uB,n,t,e)}function hB(n){return(n%360+360)%360}const pB={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},fB={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};let ly;const _le=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/,Tk=n=>n<=.0031308?12.92*n:1.055*Math.pow(n,1/2.4)-.055,Iu=n=>n<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4);function cy(n,t,e){if(n){let i=kk(n);i[t]=Math.max(0,Math.min(i[t]+i[t]*e,0===t?360:1)),i=Ik(i),n.r=i[0],n.g=i[1],n.b=i[2]}}function mB(n,t){return n&&Object.assign(t||{},n)}function gB(n){var t={r:0,g:0,b:0,a:255};return Array.isArray(n)?n.length>=3&&(t={r:n[0],g:n[1],b:n[2],a:255},n.length>3&&(t.a=gl(n[3]))):(t=mB(n,{r:0,g:0,b:0,a:1})).a=gl(t.a),t}function xle(n){return"r"===n.charAt(0)?function ble(n){const t=_le.exec(n);let i,r,s,e=255;if(t){if(t[7]!==i){const o=+t[7];e=t[8]?uf(o):ml(255*o,0,255)}return i=+t[1],r=+t[3],s=+t[5],i=255&(t[2]?uf(i):ml(i,0,255)),r=255&(t[4]?uf(r):ml(r,0,255)),s=255&(t[6]?uf(s):ml(s,0,255)),{r:i,g:r,b:s,a:e}}}(n):function hle(n){const t=ole.exec(n);let i,e=255;if(!t)return;t[5]!==i&&(e=t[6]?uf(+t[5]):gl(+t[5]));const r=hB(+t[2]),s=+t[3]/100,o=+t[4]/100;return i="hwb"===t[1]?function dle(n,t,e){return Ek(lle,n,t,e)}(r,s,o):"hsv"===t[1]?function ule(n,t,e){return Ek(ale,n,t,e)}(r,s,o):Ik(r,s,o),{r:i[0],g:i[1],b:i[2],a:e}}(n)}class dy{constructor(t){if(t instanceof dy)return t;const e=typeof t;let i;"object"===e?i=gB(t):"string"===e&&(i=function ile(n){var e,t=n.length;return"#"===n[0]&&(4===t||5===t?e={r:255&17*Vs[n[1]],g:255&17*Vs[n[2]],b:255&17*Vs[n[3]],a:5===t?17*Vs[n[4]]:255}:(7===t||9===t)&&(e={r:Vs[n[1]]<<4|Vs[n[2]],g:Vs[n[3]]<<4|Vs[n[4]],b:Vs[n[5]]<<4|Vs[n[6]],a:9===t?Vs[n[7]]<<4|Vs[n[8]]:255})),e}(t)||function gle(n){ly||(ly=function mle(){const n={},t=Object.keys(fB),e=Object.keys(pB);let i,r,s,o,a;for(i=0;i<t.length;i++){for(o=a=t[i],r=0;r<e.length;r++)s=e[r],a=a.replace(s,pB[s]);s=parseInt(fB[o],16),n[a]=[s>>16&255,s>>8&255,255&s]}return n}(),ly.transparent=[0,0,0,0]);const t=ly[n.toLowerCase()];return t&&{r:t[0],g:t[1],b:t[2],a:4===t.length?t[3]:255}}(t)||xle(t)),this._rgb=i,this._valid=!!i}get valid(){return this._valid}get rgb(){var t=mB(this._rgb);return t&&(t.a=Ra(t.a)),t}set rgb(t){this._rgb=gB(t)}rgbString(){return this._valid?function yle(n){return n&&(n.a<255?`rgba(${n.r}, ${n.g}, ${n.b}, ${Ra(n.a)})`:`rgb(${n.r}, ${n.g}, ${n.b})`)}(this._rgb):void 0}hexString(){return this._valid?function sle(n){var t=(n=>ay(n.r)&&ay(n.g)&&ay(n.b)&&ay(n.a))(n)?ele:tle;return n?"#"+t(n.r)+t(n.g)+t(n.b)+((n,t)=>n<255?t(n):"")(n.a,t):void 0}(this._rgb):void 0}hslString(){return this._valid?function fle(n){if(!n)return;const t=kk(n),e=t[0],i=dB(t[1]),r=dB(t[2]);return n.a<255?`hsla(${e}, ${i}%, ${r}%, ${Ra(n.a)})`:`hsl(${e}, ${i}%, ${r}%)`}(this._rgb):void 0}mix(t,e){if(t){const i=this.rgb,r=t.rgb;let s;const o=e===s?.5:e,a=2*o-1,l=i.a-r.a,c=((a*l==-1?a:(a+l)/(1+a*l))+1)/2;s=1-c,i.r=255&c*i.r+s*r.r+.5,i.g=255&c*i.g+s*r.g+.5,i.b=255&c*i.b+s*r.b+.5,i.a=o*i.a+(1-o)*r.a,this.rgb=i}return this}interpolate(t,e){return t&&(this._rgb=function vle(n,t,e){const i=Iu(Ra(n.r)),r=Iu(Ra(n.g)),s=Iu(Ra(n.b));return{r:gl(Tk(i+e*(Iu(Ra(t.r))-i))),g:gl(Tk(r+e*(Iu(Ra(t.g))-r))),b:gl(Tk(s+e*(Iu(Ra(t.b))-s))),a:n.a+e*(t.a-n.a)}}(this._rgb,t._rgb,e)),this}clone(){return new dy(this.rgb)}alpha(t){return this._rgb.a=gl(t),this}clearer(t){return this._rgb.a*=1-t,this}greyscale(){const t=this._rgb,e=df(.3*t.r+.59*t.g+.11*t.b);return t.r=t.g=t.b=e,this}opaquer(t){return this._rgb.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return cy(this._rgb,2,t),this}darken(t){return cy(this._rgb,2,-t),this}saturate(t){return cy(this._rgb,1,t),this}desaturate(t){return cy(this._rgb,1,-t),this}rotate(t){return function ple(n,t){var e=kk(n);e[0]=hB(e[0]+t),e=Ik(e),n.r=e[0],n.g=e[1],n.b=e[2]}(this._rgb,t),this}}function _B(n){return new dy(n)}function bB(n){if(n&&"object"==typeof n){const t=n.toString();return"[object CanvasPattern]"===t||"[object CanvasGradient]"===t}return!1}function yB(n){return bB(n)?n:_B(n)}function Ak(n){return bB(n)?n:_B(n).saturate(.5).darken(.1).hexString()}const Fc=Object.create(null),Mk=Object.create(null);function hf(n,t){if(!t)return n;const e=t.split(".");for(let i=0,r=e.length;i<r;++i){const s=e[i];n=n[s]||(n[s]=Object.create(null))}return n}function Nk(n,t,e){return"string"==typeof t?nf(hf(n,t),e):nf(hf(n,""),t)}var At=new class wle{constructor(t){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=e=>e.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(e,i)=>Ak(i.backgroundColor),this.hoverBorderColor=(e,i)=>Ak(i.borderColor),this.hoverColor=(e,i)=>Ak(i.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t)}set(t,e){return Nk(this,t,e)}get(t){return hf(this,t)}describe(t,e){return Nk(Mk,t,e)}override(t,e){return Nk(Fc,t,e)}route(t,e,i,r){const s=hf(this,t),o=hf(this,i),a="_"+e;Object.defineProperties(s,{[a]:{value:s[e],writable:!0},[e]:{enumerable:!0,get(){const l=this[a],c=o[r];return Tt(l)?Object.assign({},c,l):ft(l,c)},set(l){this[a]=l}}})}}({_scriptable:n=>!n.startsWith("on"),_indexable:n=>"events"!==n,hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}});function uy(n,t,e,i,r){let s=t[r];return s||(s=t[r]=n.measureText(r).width,e.push(r)),s>i&&(i=s),i}function Dle(n,t,e,i){let r=(i=i||{}).data=i.data||{},s=i.garbageCollect=i.garbageCollect||[];i.font!==t&&(r=i.data={},s=i.garbageCollect=[],i.font=t),n.save(),n.font=t;let o=0;const a=e.length;let l,c,d,u,h;for(l=0;l<a;l++)if(u=e[l],null!=u&&!0!==bn(u))o=uy(n,r,s,o,u);else if(bn(u))for(c=0,d=u.length;c<d;c++)h=u[c],null!=h&&!bn(h)&&(o=uy(n,r,s,o,h));n.restore();const p=s.length/2;if(p>e.length){for(l=0;l<p;l++)delete r[s[l]];s.splice(0,p)}return o}function Pc(n,t,e){const i=n.currentDevicePixelRatio,r=0!==e?Math.max(e/2,.5):0;return Math.round((t-r)*i)/i+r}function vB(n,t){(t=t||n.getContext("2d")).save(),t.resetTransform(),t.clearRect(0,0,n.width,n.height),t.restore()}function Rk(n,t,e,i){xB(n,t,e,i,null)}function xB(n,t,e,i,r){let s,o,a,l,c,d;const u=t.pointStyle,h=t.rotation,p=t.radius;let f=(h||0)*jae;if(u&&"object"==typeof u&&(s=u.toString(),"[object HTMLImageElement]"===s||"[object HTMLCanvasElement]"===s))return n.save(),n.translate(e,i),n.rotate(f),n.drawImage(u,-u.width/2,-u.height/2,u.width,u.height),void n.restore();if(!(isNaN(p)||p<=0)){switch(n.beginPath(),u){default:r?n.ellipse(e,i,r/2,p,0,0,sn):n.arc(e,i,p,0,sn),n.closePath();break;case"triangle":n.moveTo(e+Math.sin(f)*p,i-Math.cos(f)*p),f+=XV,n.lineTo(e+Math.sin(f)*p,i-Math.cos(f)*p),f+=XV,n.lineTo(e+Math.sin(f)*p,i-Math.cos(f)*p),n.closePath();break;case"rectRounded":c=.516*p,l=p-c,o=Math.cos(f+sf)*l,a=Math.sin(f+sf)*l,n.arc(e-o,i-a,c,f-Mn,f-Gn),n.arc(e+a,i-o,c,f-Gn,f),n.arc(e+o,i+a,c,f,f+Gn),n.arc(e-a,i+o,c,f+Gn,f+Mn),n.closePath();break;case"rect":if(!h){l=Math.SQRT1_2*p,d=r?r/2:l,n.rect(e-d,i-l,2*d,2*l);break}f+=sf;case"rectRot":o=Math.cos(f)*p,a=Math.sin(f)*p,n.moveTo(e-o,i-a),n.lineTo(e+a,i-o),n.lineTo(e+o,i+a),n.lineTo(e-a,i+o),n.closePath();break;case"crossRot":f+=sf;case"cross":o=Math.cos(f)*p,a=Math.sin(f)*p,n.moveTo(e-o,i-a),n.lineTo(e+o,i+a),n.moveTo(e+a,i-o),n.lineTo(e-a,i+o);break;case"star":o=Math.cos(f)*p,a=Math.sin(f)*p,n.moveTo(e-o,i-a),n.lineTo(e+o,i+a),n.moveTo(e+a,i-o),n.lineTo(e-a,i+o),f+=sf,o=Math.cos(f)*p,a=Math.sin(f)*p,n.moveTo(e-o,i-a),n.lineTo(e+o,i+a),n.moveTo(e+a,i-o),n.lineTo(e-a,i+o);break;case"line":o=r?r/2:Math.cos(f)*p,a=Math.sin(f)*p,n.moveTo(e-o,i-a),n.lineTo(e+o,i+a);break;case"dash":n.moveTo(e,i),n.lineTo(e+Math.cos(f)*p,i+Math.sin(f)*p)}n.fill(),t.borderWidth>0&&n.stroke()}}function pf(n,t,e){return e=e||.5,!t||n&&n.x>t.left-e&&n.x<t.right+e&&n.y>t.top-e&&n.y<t.bottom+e}function hy(n,t){n.save(),n.beginPath(),n.rect(t.left,t.top,t.right-t.left,t.bottom-t.top),n.clip()}function py(n){n.restore()}function Sle(n,t,e,i,r){if(!t)return n.lineTo(e.x,e.y);if("middle"===r){const s=(t.x+e.x)/2;n.lineTo(s,t.y),n.lineTo(s,e.y)}else"after"===r!=!!i?n.lineTo(t.x,e.y):n.lineTo(e.x,t.y);n.lineTo(e.x,e.y)}function kle(n,t,e,i){if(!t)return n.lineTo(e.x,e.y);n.bezierCurveTo(i?t.cp1x:t.cp2x,i?t.cp1y:t.cp2y,i?e.cp2x:e.cp1x,i?e.cp2y:e.cp1y,e.x,e.y)}function Lc(n,t,e,i,r,s={}){const o=bn(t)?t:[t],a=s.strokeWidth>0&&""!==s.strokeColor;let l,c;for(n.save(),n.font=r.string,function Ele(n,t){t.translation&&n.translate(t.translation[0],t.translation[1]),Vt(t.rotation)||n.rotate(t.rotation),t.color&&(n.fillStyle=t.color),t.textAlign&&(n.textAlign=t.textAlign),t.textBaseline&&(n.textBaseline=t.textBaseline)}(n,s),l=0;l<o.length;++l)c=o[l],a&&(s.strokeColor&&(n.strokeStyle=s.strokeColor),Vt(s.strokeWidth)||(n.lineWidth=s.strokeWidth),n.strokeText(c,e,i,s.maxWidth)),n.fillText(c,e,i,s.maxWidth),Ile(n,e,i,c,s),i+=r.lineHeight;n.restore()}function Ile(n,t,e,i,r){if(r.strikethrough||r.underline){const s=n.measureText(i),o=t-s.actualBoundingBoxLeft,a=t+s.actualBoundingBoxRight,c=e+s.actualBoundingBoxDescent,d=r.strikethrough?(e-s.actualBoundingBoxAscent+c)/2:c;n.strokeStyle=n.fillStyle,n.beginPath(),n.lineWidth=r.decorationWidth||2,n.moveTo(o,d),n.lineTo(a,d),n.stroke()}}function ff(n,t){const{x:e,y:i,w:r,h:s,radius:o}=t;n.arc(e+o.topLeft,i+o.topLeft,o.topLeft,-Gn,Mn,!0),n.lineTo(e,i+s-o.bottomLeft),n.arc(e+o.bottomLeft,i+s-o.bottomLeft,o.bottomLeft,Mn,Gn,!0),n.lineTo(e+r-o.bottomRight,i+s),n.arc(e+r-o.bottomRight,i+s-o.bottomRight,o.bottomRight,Gn,0,!0),n.lineTo(e+r,i+o.topRight),n.arc(e+r-o.topRight,i+o.topRight,o.topRight,0,-Gn,!0),n.lineTo(e+o.topLeft,i)}const Tle=new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/),Ale=new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);function Mle(n,t){const e=(""+n).match(Tle);if(!e||"normal"===e[1])return 1.2*t;switch(n=+e[2],e[3]){case"px":return n;case"%":n/=100}return t*n}const Nle=n=>+n||0;function Ok(n,t){const e={},i=Tt(t),r=i?Object.keys(t):t,s=Tt(n)?i?o=>ft(n[o],n[t[o]]):o=>n[o]:()=>n;for(const o of r)e[o]=Nle(s(o));return e}function wB(n){return Ok(n,{top:"y",right:"x",bottom:"y",left:"x"})}function $c(n){return Ok(n,["topLeft","topRight","bottomLeft","bottomRight"])}function dr(n){const t=wB(n);return t.width=t.left+t.right,t.height=t.top+t.bottom,t}function ki(n,t){let e=ft((n=n||{}).size,(t=t||At.font).size);"string"==typeof e&&(e=parseInt(e,10));let i=ft(n.style,t.style);i&&!(""+i).match(Ale)&&(console.warn('Invalid font style specified: "'+i+'"'),i="");const r={family:ft(n.family,t.family),lineHeight:Mle(ft(n.lineHeight,t.lineHeight),e),size:e,style:i,weight:ft(n.weight,t.weight),string:""};return r.string=function Cle(n){return!n||Vt(n.size)||Vt(n.family)?null:(n.style?n.style+" ":"")+(n.weight?n.weight+" ":"")+n.size+"px "+n.family}(r),r}function mf(n,t,e,i){let s,o,a,r=!0;for(s=0,o=n.length;s<o;++s)if(a=n[s],void 0!==a&&(void 0!==t&&"function"==typeof a&&(a=a(t),r=!1),void 0!==e&&bn(a)&&(a=a[e%a.length],r=!1),void 0!==a))return i&&!r&&(i.cacheable=!1),a}function _l(n,t){return Object.assign(Object.create(n),t)}function Fk(n,t=[""],e=n,i,r=(()=>n[0])){Ls(i)||(i=EB("_fallback",n));const s={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:n,_rootScopes:e,_fallback:i,_getTarget:r,override:o=>Fk([o,...n],t,e,i)};return new Proxy(s,{deleteProperty:(o,a)=>(delete o[a],delete o._keys,delete n[0][a],!0),get:(o,a)=>DB(o,a,()=>function zle(n,t,e,i){let r;for(const s of t)if(r=EB(Ole(s,n),e),Ls(r))return Pk(n,r)?Lk(e,i,n,r):r}(a,t,n,o)),getOwnPropertyDescriptor:(o,a)=>Reflect.getOwnPropertyDescriptor(o._scopes[0],a),getPrototypeOf:()=>Reflect.getPrototypeOf(n[0]),has:(o,a)=>IB(o).includes(a),ownKeys:o=>IB(o),set(o,a,l){const c=o._storage||(o._storage=r());return o[a]=c[a]=l,delete o._keys,!0}})}function Tu(n,t,e,i){const r={_cacheable:!1,_proxy:n,_context:t,_subProxy:e,_stack:new Set,_descriptors:CB(n,i),setContext:s=>Tu(n,s,e,i),override:s=>Tu(n.override(s),t,e,i)};return new Proxy(r,{deleteProperty:(s,o)=>(delete s[o],delete n[o],!0),get:(s,o,a)=>DB(s,o,()=>function Fle(n,t,e){const{_proxy:i,_context:r,_subProxy:s,_descriptors:o}=n;let a=i[t];return fl(a)&&o.isScriptable(t)&&(a=function Ple(n,t,e,i){const{_proxy:r,_context:s,_subProxy:o,_stack:a}=e;if(a.has(n))throw new Error("Recursion detected: "+Array.from(a).join("->")+"->"+n);return a.add(n),t=t(s,o||i),a.delete(n),Pk(n,t)&&(t=Lk(r._scopes,r,n,t)),t}(t,a,n,e)),bn(a)&&a.length&&(a=function Lle(n,t,e,i){const{_proxy:r,_context:s,_subProxy:o,_descriptors:a}=e;if(Ls(s.index)&&i(n))t=t[s.index%t.length];else if(Tt(t[0])){const l=t,c=r._scopes.filter(d=>d!==l);t=[];for(const d of l){const u=Lk(c,r,n,d);t.push(Tu(u,s,o&&o[n],a))}}return t}(t,a,n,o.isIndexable)),Pk(t,a)&&(a=Tu(a,r,s&&s[t],o)),a}(s,o,a)),getOwnPropertyDescriptor:(s,o)=>s._descriptors.allKeys?Reflect.has(n,o)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(n,o),getPrototypeOf:()=>Reflect.getPrototypeOf(n),has:(s,o)=>Reflect.has(n,o),ownKeys:()=>Reflect.ownKeys(n),set:(s,o,a)=>(n[o]=a,delete s[o],!0)})}function CB(n,t={scriptable:!0,indexable:!0}){const{_scriptable:e=t.scriptable,_indexable:i=t.indexable,_allKeys:r=t.allKeys}=n;return{allKeys:r,scriptable:e,indexable:i,isScriptable:fl(e)?e:()=>e,isIndexable:fl(i)?i:()=>i}}const Ole=(n,t)=>n?n+vk(t):t,Pk=(n,t)=>Tt(t)&&"adapters"!==n&&(null===Object.getPrototypeOf(t)||t.constructor===Object);function DB(n,t,e){if(Object.prototype.hasOwnProperty.call(n,t))return n[t];const i=e();return n[t]=i,i}function SB(n,t,e){return fl(n)?n(t,e):n}const $le=(n,t)=>!0===n?t:"string"==typeof n?pl(t,n):void 0;function Vle(n,t,e,i,r){for(const s of t){const o=$le(e,s);if(o){n.add(o);const a=SB(o._fallback,e,r);if(Ls(a)&&a!==e&&a!==i)return a}else if(!1===o&&Ls(i)&&e!==i)return null}return!1}function Lk(n,t,e,i){const r=t._rootScopes,s=SB(t._fallback,e,i),o=[...n,...r],a=new Set;a.add(i);let l=kB(a,o,e,s||e,i);return!(null===l||Ls(s)&&s!==e&&(l=kB(a,o,s,l,i),null===l))&&Fk(Array.from(a),[""],r,s,()=>function Ble(n,t,e){const i=n._getTarget();t in i||(i[t]={});const r=i[t];return bn(r)&&Tt(e)?e:r}(t,e,i))}function kB(n,t,e,i,r){for(;e;)e=Vle(n,t,e,i,r);return e}function EB(n,t){for(const e of t){if(!e)continue;const i=e[n];if(Ls(i))return i}}function IB(n){let t=n._keys;return t||(t=n._keys=function Ule(n){const t=new Set;for(const e of n)for(const i of Object.keys(e).filter(r=>!r.startsWith("_")))t.add(i);return Array.from(t)}(n._scopes)),t}function TB(n,t,e,i){const{iScale:r}=n,{key:s="r"}=this._parsing,o=new Array(i);let a,l,c,d;for(a=0,l=i;a<l;++a)c=a+e,d=t[c],o[a]={r:r.parse(pl(d,s),c)};return o}const Hle=Number.EPSILON||1e-14,Au=(n,t)=>t<n.length&&!n[t].skip&&n[t],AB=n=>"x"===n?"y":"x";function jle(n,t,e,i){const r=n.skip?t:n,s=t,o=e.skip?t:e,a=wk(s,r),l=wk(o,s);let c=a/(a+l),d=l/(a+l);c=isNaN(c)?0:c,d=isNaN(d)?0:d;const u=i*c,h=i*d;return{previous:{x:s.x-u*(o.x-r.x),y:s.y-u*(o.y-r.y)},next:{x:s.x+h*(o.x-r.x),y:s.y+h*(o.y-r.y)}}}function fy(n,t,e){return Math.max(Math.min(n,e),t)}function Kle(n,t,e,i,r){let s,o,a,l;if(t.spanGaps&&(n=n.filter(c=>!c.skip)),"monotone"===t.cubicInterpolationMode)!function qle(n,t="x"){const e=AB(t),i=n.length,r=Array(i).fill(0),s=Array(i);let o,a,l,c=Au(n,0);for(o=0;o<i;++o)if(a=l,l=c,c=Au(n,o+1),l){if(c){const d=c[t]-l[t];r[o]=0!==d?(c[e]-l[e])/d:0}s[o]=a?c?Ho(r[o-1])!==Ho(r[o])?0:(r[o-1]+r[o])/2:r[o-1]:r[o]}(function Wle(n,t,e){const i=n.length;let r,s,o,a,l,c=Au(n,0);for(let d=0;d<i-1;++d)if(l=c,c=Au(n,d+1),l&&c){if(af(t[d],0,Hle)){e[d]=e[d+1]=0;continue}r=e[d]/t[d],s=e[d+1]/t[d],a=Math.pow(r,2)+Math.pow(s,2),!(a<=9)&&(o=3/Math.sqrt(a),e[d]=r*o*t[d],e[d+1]=s*o*t[d])}})(n,r,s),function Gle(n,t,e="x"){const i=AB(e),r=n.length;let s,o,a,l=Au(n,0);for(let c=0;c<r;++c){if(o=a,a=l,l=Au(n,c+1),!a)continue;const d=a[e],u=a[i];o&&(s=(d-o[e])/3,a[`cp1${e}`]=d-s,a[`cp1${i}`]=u-s*t[c]),l&&(s=(l[e]-d)/3,a[`cp2${e}`]=d+s,a[`cp2${i}`]=u+s*t[c])}}(n,s,t)}(n,r);else{let c=i?n[n.length-1]:n[0];for(s=0,o=n.length;s<o;++s)a=n[s],l=jle(c,a,n[Math.min(s+1,o-(i?0:1))%o],t.tension),a.cp1x=l.previous.x,a.cp1y=l.previous.y,a.cp2x=l.next.x,a.cp2y=l.next.y,c=a}t.capBezierPoints&&function Yle(n,t){let e,i,r,s,o,a=pf(n[0],t);for(e=0,i=n.length;e<i;++e)o=s,s=a,a=e<i-1&&pf(n[e+1],t),s&&(r=n[e],o&&(r.cp1x=fy(r.cp1x,t.left,t.right),r.cp1y=fy(r.cp1y,t.top,t.bottom)),a&&(r.cp2x=fy(r.cp2x,t.left,t.right),r.cp2y=fy(r.cp2y,t.top,t.bottom)))}(n,e)}function MB(){return typeof window<"u"&&typeof document<"u"}function $k(n){let t=n.parentNode;return t&&"[object ShadowRoot]"===t.toString()&&(t=t.host),t}function my(n,t,e){let i;return"string"==typeof n?(i=parseInt(n,10),-1!==n.indexOf("%")&&(i=i/100*t.parentNode[e])):i=n,i}const gy=n=>window.getComputedStyle(n,null),Zle=["top","right","bottom","left"];function Vc(n,t,e){const i={};e=e?"-"+e:"";for(let r=0;r<4;r++){const s=Zle[r];i[s]=parseFloat(n[t+"-"+s+e])||0}return i.width=i.left+i.right,i.height=i.top+i.bottom,i}const Qle=(n,t,e)=>(n>0||t>0)&&(!e||!e.shadowRoot);function Bc(n,t){if("native"in n)return n;const{canvas:e,currentDevicePixelRatio:i}=t,r=gy(e),s="border-box"===r.boxSizing,o=Vc(r,"padding"),a=Vc(r,"border","width"),{x:l,y:c,box:d}=function Jle(n,t){const e=n.touches,i=e&&e.length?e[0]:n,{offsetX:r,offsetY:s}=i;let a,l,o=!1;if(Qle(r,s,n.target))a=r,l=s;else{const c=t.getBoundingClientRect();a=i.clientX-c.left,l=i.clientY-c.top,o=!0}return{x:a,y:l,box:o}}(n,e),u=o.left+(d&&a.left),h=o.top+(d&&a.top);let{width:p,height:f}=t;return s&&(p-=o.width+a.width,f-=o.height+a.height),{x:Math.round((l-u)/p*e.width/i),y:Math.round((c-h)/f*e.height/i)}}const Vk=n=>Math.round(10*n)/10;function NB(n,t,e){const i=t||1,r=Math.floor(n.height*i),s=Math.floor(n.width*i);n.height=r/i,n.width=s/i;const o=n.canvas;return o.style&&(e||!o.style.height&&!o.style.width)&&(o.style.height=`${n.height}px`,o.style.width=`${n.width}px`),(n.currentDevicePixelRatio!==i||o.height!==r||o.width!==s)&&(n.currentDevicePixelRatio=i,o.height=r,o.width=s,n.ctx.setTransform(i,0,0,i,0,0),!0)}const nce=function(){let n=!1;try{const t={get passive(){return n=!0,!1}};window.addEventListener("test",null,t),window.removeEventListener("test",null,t)}catch{}return n}();function RB(n,t){const e=function Xle(n,t){return gy(n).getPropertyValue(t)}(n,t),i=e&&e.match(/^(\d+)(\.\d+)?px$/);return i?+i[1]:void 0}function zc(n,t,e,i){return{x:n.x+e*(t.x-n.x),y:n.y+e*(t.y-n.y)}}function ice(n,t,e,i){return{x:n.x+e*(t.x-n.x),y:"middle"===i?e<.5?n.y:t.y:"after"===i?e<1?n.y:t.y:e>0?t.y:n.y}}function rce(n,t,e,i){const r={x:n.cp2x,y:n.cp2y},s={x:t.cp1x,y:t.cp1y},o=zc(n,r,e),a=zc(r,s,e),l=zc(s,t,e),c=zc(o,a,e),d=zc(a,l,e);return zc(c,d,e)}const OB=new Map;function gf(n,t,e){return function sce(n,t){t=t||{};const e=n+JSON.stringify(t);let i=OB.get(e);return i||(i=new Intl.NumberFormat(n,t),OB.set(e,i)),i}(t,e).format(n)}const oce=function(n,t){return{x:e=>n+n+t-e,setWidth(e){t=e},textAlign:e=>"center"===e?e:"right"===e?"left":"right",xPlus:(e,i)=>e-i,leftForLtr:(e,i)=>e-i}},ace=function(){return{x:n=>n,setWidth(n){},textAlign:n=>n,xPlus:(n,t)=>n+t,leftForLtr:(n,t)=>n}};function Mu(n,t,e){return n?oce(t,e):ace()}function FB(n,t){let e,i;("ltr"===t||"rtl"===t)&&(e=n.canvas.style,i=[e.getPropertyValue("direction"),e.getPropertyPriority("direction")],e.setProperty("direction",t,"important"),n.prevTextDirection=i)}function PB(n,t){void 0!==t&&(delete n.prevTextDirection,n.canvas.style.setProperty("direction",t[0],t[1]))}function LB(n){return"angle"===n?{between:lf,compare:qae,normalize:ds}:{between:Ma,compare:(t,e)=>t-e,normalize:t=>t}}function $B({start:n,end:t,count:e,loop:i,style:r}){return{start:n%e,end:t%e,loop:i&&(t-n+1)%e==0,style:r}}function VB(n,t,e){if(!e)return[n];const{property:i,start:r,end:s}=e,o=t.length,{compare:a,between:l,normalize:c}=LB(i),{start:d,end:u,loop:h,style:p}=function lce(n,t,e){const{property:i,start:r,end:s}=e,{between:o,normalize:a}=LB(i),l=t.length;let h,p,{start:c,end:d,loop:u}=n;if(u){for(c+=l,d+=l,h=0,p=l;h<p&&o(a(t[c%l][i]),r,s);++h)c--,d--;c%=l,d%=l}return d<c&&(d+=l),{start:c,end:d,loop:u,style:n.style}}(n,t,e),f=[];let _,b,y,m=!1,g=null;for(let D=d,k=d;D<=u;++D)b=t[D%o],!b.skip&&(_=c(b[i]),_!==y&&(m=l(_,r,s),null===g&&(m||l(r,y,_)&&0!==a(r,y))&&(g=0===a(_,r)?D:k),null!==g&&(!m||0===a(s,_)||l(s,y,_))&&(f.push($B({start:g,end:D,loop:h,count:o,style:p})),g=null),k=D,y=_));return null!==g&&f.push($B({start:g,end:u,loop:h,count:o,style:p})),f}function BB(n,t){const e=[],i=n.segments;for(let r=0;r<i.length;r++){const s=VB(i[r],n.points,t);s.length&&e.push(...s)}return e}function UB(n){return{backgroundColor:n.backgroundColor,borderCapStyle:n.borderCapStyle,borderDash:n.borderDash,borderDashOffset:n.borderDashOffset,borderJoinStyle:n.borderJoinStyle,borderWidth:n.borderWidth,borderColor:n.borderColor}}function pce(n,t){return t&&JSON.stringify(n)!==JSON.stringify(t)}var Oa=new class fce{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,i,r){const o=e.duration;e.listeners[r].forEach(a=>a({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(i-e.start,o)}))}_refresh(){this._request||(this._running=!0,this._request=rB.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(t=Date.now()){let e=0;this._charts.forEach((i,r)=>{if(!i.running||!i.items.length)return;const s=i.items;let l,o=s.length-1,a=!1;for(;o>=0;--o)l=s[o],l._active?(l._total>i.duration&&(i.duration=l._total),l.tick(t),a=!0):(s[o]=s[s.length-1],s.pop());a&&(r.draw(),this._notify(r,i,t,"progress")),s.length||(i.running=!1,this._notify(r,i,t,"complete"),i.initial=!1),e+=s.length}),this._lastDate=t,0===e&&(this._running=!1)}_getAnims(t){const e=this._charts;let i=e.get(t);return i||(i={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}listen(t,e,i){this._getAnims(t).listeners[e].push(i)}add(t,e){!e||!e.length||this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce((i,r)=>Math.max(i,r._duration),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!(!e||!e.running||!e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const i=e.items;let r=i.length-1;for(;r>=0;--r)i[r].cancel();e.items=[],this._notify(t,e,Date.now(),"complete")}remove(t){return this._charts.delete(t)}};const HB="transparent",mce={boolean:(n,t,e)=>e>.5?t:n,color(n,t,e){const i=yB(n||HB),r=i.valid&&yB(t||HB);return r&&r.valid?r.mix(i,e).hexString():t},number:(n,t,e)=>n+(t-n)*e};class gce{constructor(t,e,i,r){const s=e[i];r=mf([t.to,r,s,t.from]);const o=mf([t.from,s,r]);this._active=!0,this._fn=t.fn||mce[t.type||typeof o],this._easing=cf[t.easing]||cf.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=o,this._to=r,this._promises=void 0}active(){return this._active}update(t,e,i){if(this._active){this._notify(!1);const r=this._target[this._prop],s=i-this._start,o=this._duration-s;this._start=i,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=s,this._loop=!!t.loop,this._to=mf([t.to,e,r,t.from]),this._from=mf([t.from,r,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,i=this._duration,r=this._prop,s=this._from,o=this._loop,a=this._to;let l;if(this._active=s!==a&&(o||e<i),!this._active)return this._target[r]=a,void this._notify(!0);e<0?this._target[r]=s:(l=e/i%2,l=o&&l>1?2-l:l,l=this._easing(Math.min(1,Math.max(0,l))),this._target[r]=this._fn(s,a,l))}wait(){const t=this._promises||(this._promises=[]);return new Promise((e,i)=>{t.push({res:e,rej:i})})}_notify(t){const e=t?"res":"rej",i=this._promises||[];for(let r=0;r<i.length;r++)i[r][e]()}}At.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0});const yce=Object.keys(At.animation);At.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:n=>"onProgress"!==n&&"onComplete"!==n&&"fn"!==n}),At.set("animations",{colors:{type:"color",properties:["color","borderColor","backgroundColor"]},numbers:{type:"number",properties:["x","y","borderWidth","radius","tension"]}}),At.describe("animations",{_fallback:"animation"}),At.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:n=>0|n}}}});class jB{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!Tt(t))return;const e=this._properties;Object.getOwnPropertyNames(t).forEach(i=>{const r=t[i];if(!Tt(r))return;const s={};for(const o of yce)s[o]=r[o];(bn(r.properties)&&r.properties||[i]).forEach(o=>{(o===i||!e.has(o))&&e.set(o,s)})})}_animateOptions(t,e){const i=e.options,r=function xce(n,t){if(!t)return;let e=n.options;if(e)return e.$shared&&(n.options=e=Object.assign({},e,{$shared:!1,$animations:{}})),e;n.options=t}(t,i);if(!r)return[];const s=this._createAnimations(r,i);return i.$shared&&function vce(n,t){const e=[],i=Object.keys(t);for(let r=0;r<i.length;r++){const s=n[i[r]];s&&s.active()&&e.push(s.wait())}return Promise.all(e)}(t.options.$animations,i).then(()=>{t.options=i},()=>{}),s}_createAnimations(t,e){const i=this._properties,r=[],s=t.$animations||(t.$animations={}),o=Object.keys(e),a=Date.now();let l;for(l=o.length-1;l>=0;--l){const c=o[l];if("$"===c.charAt(0))continue;if("options"===c){r.push(...this._animateOptions(t,e));continue}const d=e[c];let u=s[c];const h=i.get(c);if(u){if(h&&u.active()){u.update(h,d,a);continue}u.cancel()}h&&h.duration?(s[c]=u=new gce(h,t,c,d),r.push(u)):t[c]=d}return r}update(t,e){if(0===this._properties.size)return void Object.assign(t,e);const i=this._createAnimations(t,e);return i.length?(Oa.add(this._chart,i),!0):void 0}}function WB(n,t){const e=n&&n.options||{},i=e.reverse,r=void 0===e.min?t:0,s=void 0===e.max?t:0;return{start:i?s:r,end:i?r:s}}function GB(n,t){const e=[],i=n._getSortedDatasetMetas(t);let r,s;for(r=0,s=i.length;r<s;++r)e.push(i[r].index);return e}function qB(n,t,e,i={}){const r=n.keys,s="single"===i.mode;let o,a,l,c;if(null!==t){for(o=0,a=r.length;o<a;++o){if(l=+r[o],l===e){if(i.all)continue;break}c=n.values[l],ni(c)&&(s||0===t||Ho(t)===Ho(c))&&(t+=c)}return t}}function YB(n,t){const e=n&&n.options.stacked;return e||void 0===e&&void 0!==t.stack}function Ece(n,t,e){const i=n[t]||(n[t]={});return i[e]||(i[e]={})}function KB(n,t,e,i){for(const r of t.getMatchingVisibleMetas(i).reverse()){const s=n[r.index];if(e&&s>0||!e&&s<0)return r.index}return null}function XB(n,t){const{chart:e,_cachedMeta:i}=n,r=e._stacks||(e._stacks={}),{iScale:s,vScale:o,index:a}=i,l=s.axis,c=o.axis,d=function Sce(n,t,e){return`${n.id}.${t.id}.${e.stack||e.type}`}(s,o,i),u=t.length;let h;for(let p=0;p<u;++p){const f=t[p],{[l]:m,[c]:g}=f;h=(f._stacks||(f._stacks={}))[c]=Ece(r,d,m),h[a]=g,h._top=KB(h,o,!0,i.type),h._bottom=KB(h,o,!1,i.type)}}function Bk(n,t){const e=n.scales;return Object.keys(e).filter(i=>e[i].axis===t).shift()}function _f(n,t){const e=n.controller.index,i=n.vScale&&n.vScale.axis;if(i){t=t||n._parsed;for(const r of t){const s=r._stacks;if(!s||void 0===s[i]||void 0===s[i][e])return;delete s[i][e]}}}const zk=n=>"reset"===n||"none"===n,ZB=(n,t)=>t?n:Object.assign({},n);let jo=(()=>{class n{constructor(e,i){this.chart=e,this._ctx=e.ctx,this.index=i,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.initialize()}initialize(){const e=this._cachedMeta;this.configure(),this.linkScales(),e._stacked=YB(e.vScale,e),this.addElements()}updateIndex(e){this.index!==e&&_f(this._cachedMeta),this.index=e}linkScales(){const e=this.chart,i=this._cachedMeta,r=this.getDataset(),s=(h,p,f,m)=>"x"===h?p:"r"===h?m:f,o=i.xAxisID=ft(r.xAxisID,Bk(e,"x")),a=i.yAxisID=ft(r.yAxisID,Bk(e,"y")),l=i.rAxisID=ft(r.rAxisID,Bk(e,"r")),c=i.indexAxis,d=i.iAxisID=s(c,o,a,l),u=i.vAxisID=s(c,a,o,l);i.xScale=this.getScaleForId(o),i.yScale=this.getScaleForId(a),i.rScale=this.getScaleForId(l),i.iScale=this.getScaleForId(d),i.vScale=this.getScaleForId(u)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(e){return this.chart.scales[e]}_getOtherScale(e){const i=this._cachedMeta;return e===i.iScale?i.vScale:i.iScale}reset(){this._update("reset")}_destroy(){const e=this._cachedMeta;this._data&&nB(this._data,this),e._stacked&&_f(e)}_dataCheck(){const e=this.getDataset(),i=e.data||(e.data=[]),r=this._data;if(Tt(i))this._data=function Dce(n){const t=Object.keys(n),e=new Array(t.length);let i,r,s;for(i=0,r=t.length;i<r;++i)s=t[i],e[i]={x:s,y:n[s]};return e}(i);else if(r!==i){if(r){nB(r,this);const s=this._cachedMeta;_f(s),s._parsed=[]}i&&Object.isExtensible(i)&&function Zae(n,t){n._chartjs?n._chartjs.listeners.push(t):(Object.defineProperty(n,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),tB.forEach(e=>{const i="_onData"+vk(e),r=n[e];Object.defineProperty(n,e,{configurable:!0,enumerable:!1,value(...s){const o=r.apply(this,s);return n._chartjs.listeners.forEach(a=>{"function"==typeof a[i]&&a[i](...s)}),o}})}))}(i,this),this._syncList=[],this._data=i}}addElements(){const e=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(e.dataset=new this.datasetElementType)}buildOrUpdateElements(e){const i=this._cachedMeta,r=this.getDataset();let s=!1;this._dataCheck();const o=i._stacked;i._stacked=YB(i.vScale,i),i.stack!==r.stack&&(s=!0,_f(i),i.stack=r.stack),this._resyncElements(e),(s||o!==i._stacked)&&XB(this,i._parsed)}configure(){const e=this.chart.config,i=e.datasetScopeKeys(this._type),r=e.getOptionScopes(this.getDataset(),i,!0);this.options=e.createResolver(r,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(e,i){const{_cachedMeta:r,_data:s}=this,{iScale:o,_stacked:a}=r,l=o.axis;let u,h,p,c=0===e&&i===s.length||r._sorted,d=e>0&&r._parsed[e-1];if(!1===this._parsing)r._parsed=s,r._sorted=!0,p=s;else{p=bn(s[e])?this.parseArrayData(r,s,e,i):Tt(s[e])?this.parseObjectData(r,s,e,i):this.parsePrimitiveData(r,s,e,i);const f=()=>null===h[l]||d&&h[l]<d[l];for(u=0;u<i;++u)r._parsed[u+e]=h=p[u],c&&(f()&&(c=!1),d=h);r._sorted=c}a&&XB(this,p)}parsePrimitiveData(e,i,r,s){const{iScale:o,vScale:a}=e,l=o.axis,c=a.axis,d=o.getLabels(),u=o===a,h=new Array(s);let p,f,m;for(p=0,f=s;p<f;++p)m=p+r,h[p]={[l]:u||o.parse(d[m],m),[c]:a.parse(i[m],m)};return h}parseArrayData(e,i,r,s){const{xScale:o,yScale:a}=e,l=new Array(s);let c,d,u,h;for(c=0,d=s;c<d;++c)u=c+r,h=i[u],l[c]={x:o.parse(h[0],u),y:a.parse(h[1],u)};return l}parseObjectData(e,i,r,s){const{xScale:o,yScale:a}=e,{xAxisKey:l="x",yAxisKey:c="y"}=this._parsing,d=new Array(s);let u,h,p,f;for(u=0,h=s;u<h;++u)p=u+r,f=i[p],d[u]={x:o.parse(pl(f,l),p),y:a.parse(pl(f,c),p)};return d}getParsed(e){return this._cachedMeta._parsed[e]}getDataElement(e){return this._cachedMeta.data[e]}applyStack(e,i,r){const o=this._cachedMeta,a=i[e.axis];return qB({keys:GB(this.chart,!0),values:i._stacks[e.axis]},a,o.index,{mode:r})}updateRangeFromParsed(e,i,r,s){const o=r[i.axis];let a=null===o?NaN:o;const l=s&&r._stacks[i.axis];s&&l&&(s.values=l,a=qB(s,o,this._cachedMeta.index)),e.min=Math.min(e.min,a),e.max=Math.max(e.max,a)}getMinMax(e,i){const r=this._cachedMeta,s=r._parsed,o=r._sorted&&e===r.iScale,a=s.length,l=this._getOtherScale(e),c=((n,t,e)=>n&&!t.hidden&&t._stacked&&{keys:GB(this.chart,!0),values:null})(i,r),d={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:u,max:h}=function kce(n){const{min:t,max:e,minDefined:i,maxDefined:r}=n.getUserBounds();return{min:i?t:Number.NEGATIVE_INFINITY,max:r?e:Number.POSITIVE_INFINITY}}(l);let p,f;function m(){f=s[p];const g=f[l.axis];return!ni(f[e.axis])||u>g||h<g}for(p=0;p<a&&(m()||(this.updateRangeFromParsed(d,e,f,c),!o));++p);if(o)for(p=a-1;p>=0;--p)if(!m()){this.updateRangeFromParsed(d,e,f,c);break}return d}getAllParsedValues(e){const i=this._cachedMeta._parsed,r=[];let s,o,a;for(s=0,o=i.length;s<o;++s)a=i[s][e.axis],ni(a)&&r.push(a);return r}getMaxOverflow(){return!1}getLabelAndValue(e){const i=this._cachedMeta,r=i.iScale,s=i.vScale,o=this.getParsed(e);return{label:r?""+r.getLabelForValue(o[r.axis]):"",value:s?""+s.getLabelForValue(o[s.axis]):""}}_update(e){const i=this._cachedMeta;this.update(e||"default"),i._clip=function Cce(n){let t,e,i,r;return Tt(n)?(t=n.top,e=n.right,i=n.bottom,r=n.left):t=e=i=r=n,{top:t,right:e,bottom:i,left:r,disabled:!1===n}}(ft(this.options.clip,function wce(n,t,e){if(!1===e)return!1;const i=WB(n,e),r=WB(t,e);return{top:r.end,right:i.end,bottom:r.start,left:i.start}}(i.xScale,i.yScale,this.getMaxOverflow())))}update(e){}draw(){const e=this._ctx,r=this._cachedMeta,s=r.data||[],o=this.chart.chartArea,a=[],l=this._drawStart||0,c=this._drawCount||s.length-l,d=this.options.drawActiveElementsOnTop;let u;for(r.dataset&&r.dataset.draw(e,o,l,c),u=l;u<l+c;++u){const h=s[u];h.hidden||(h.active&&d?a.push(h):h.draw(e,o))}for(u=0;u<a.length;++u)a[u].draw(e,o)}getStyle(e,i){const r=i?"active":"default";return void 0===e&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(r):this.resolveDataElementOptions(e||0,r)}getContext(e,i,r){const s=this.getDataset();let o;if(e>=0&&e<this._cachedMeta.data.length){const a=this._cachedMeta.data[e];o=a.$context||(a.$context=function Tce(n,t,e){return _l(n,{active:!1,dataIndex:t,parsed:void 0,raw:void 0,element:e,index:t,mode:"default",type:"data"})}(this.getContext(),e,a)),o.parsed=this.getParsed(e),o.raw=s.data[e],o.index=o.dataIndex=e}else o=this.$context||(this.$context=function Ice(n,t){return _l(n,{active:!1,dataset:void 0,datasetIndex:t,index:t,mode:"default",type:"dataset"})}(this.chart.getContext(),this.index)),o.dataset=s,o.index=o.datasetIndex=this.index;return o.active=!!i,o.mode=r,o}resolveDatasetElementOptions(e){return this._resolveElementOptions(this.datasetElementType.id,e)}resolveDataElementOptions(e,i){return this._resolveElementOptions(this.dataElementType.id,i,e)}_resolveElementOptions(e,i="default",r){const s="active"===i,o=this._cachedDataOpts,a=e+"-"+i,l=o[a],c=this.enableOptionSharing&&Ls(r);if(l)return ZB(l,c);const d=this.chart.config,u=d.datasetElementScopeKeys(this._type,e),h=s?[`${e}Hover`,"hover",e,""]:[e,""],p=d.getOptionScopes(this.getDataset(),u),f=Object.keys(At.elements[e]),g=d.resolveNamedOptions(p,f,()=>this.getContext(r,s),h);return g.$shared&&(g.$shared=c,o[a]=Object.freeze(ZB(g,c))),g}_resolveAnimations(e,i,r){const s=this.chart,o=this._cachedDataOpts,a=`animation-${i}`,l=o[a];if(l)return l;let c;if(!1!==s.options.animation){const u=this.chart.config,h=u.datasetAnimationScopeKeys(this._type,i),p=u.getOptionScopes(this.getDataset(),h);c=u.createResolver(p,this.getContext(e,r,i))}const d=new jB(s,c&&c.animations);return c&&c._cacheable&&(o[a]=Object.freeze(d)),d}getSharedOptions(e){if(e.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},e))}includeOptions(e,i){return!i||zk(e)||this.chart._animationsDisabled}_getSharedOptions(e,i){const r=this.resolveDataElementOptions(e,i),s=this._sharedOptions,o=this.getSharedOptions(r),a=this.includeOptions(i,o)||o!==s;return this.updateSharedOptions(o,i,r),{sharedOptions:o,includeOptions:a}}updateElement(e,i,r,s){zk(s)?Object.assign(e,r):this._resolveAnimations(i,s).update(e,r)}updateSharedOptions(e,i,r){e&&!zk(i)&&this._resolveAnimations(void 0,i).update(e,r)}_setStyle(e,i,r,s){e.active=s;const o=this.getStyle(i,s);this._resolveAnimations(i,r,s).update(e,{options:!s&&this.getSharedOptions(o)||o})}removeHoverStyle(e,i,r){this._setStyle(e,r,"active",!1)}setHoverStyle(e,i,r){this._setStyle(e,r,"active",!0)}_removeDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!1)}_setDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!0)}_resyncElements(e){const i=this._data,r=this._cachedMeta.data;for(const[l,c,d]of this._syncList)this[l](c,d);this._syncList=[];const s=r.length,o=i.length,a=Math.min(o,s);a&&this.parse(0,a),o>s?this._insertElements(s,o-s,e):o<s&&this._removeElements(o,s-o)}_insertElements(e,i,r=!0){const s=this._cachedMeta,o=s.data,a=e+i;let l;const c=d=>{for(d.length+=i,l=d.length-1;l>=a;l--)d[l]=d[l-i]};for(c(o),l=e;l<a;++l)o[l]=new this.dataElementType;this._parsing&&c(s._parsed),this.parse(e,i),r&&this.updateElements(o,e,i,"reset")}updateElements(e,i,r,s){}_removeElements(e,i){const r=this._cachedMeta;if(this._parsing){const s=r._parsed.splice(e,i);r._stacked&&_f(r,s)}r.data.splice(e,i)}_sync(e){if(this._parsing)this._syncList.push(e);else{const[i,r,s]=e;this[i](r,s)}this.chart._dataChanges.push([this.index,...e])}_onDataPush(){const e=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-e,e])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(e,i){i&&this._sync(["_removeElements",e,i]);const r=arguments.length-2;r&&this._sync(["_insertElements",e,r])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}return n.defaults={},n})();function Nce(n){const t=n.iScale,e=function Mce(n,t){if(!n._cache.$bar){const e=n.getMatchingVisibleMetas(t);let i=[];for(let r=0,s=e.length;r<s;r++)i=i.concat(e[r].controller.getAllParsedValues(n));n._cache.$bar=iB(i.sort((r,s)=>r-s))}return n._cache.$bar}(t,n.type);let r,s,o,a,i=t._length;const l=()=>{32767===o||-32768===o||(Ls(a)&&(i=Math.min(i,Math.abs(o-a)||i)),a=o)};for(r=0,s=e.length;r<s;++r)o=t.getPixelForValue(e[r]),l();for(a=void 0,r=0,s=t.ticks.length;r<s;++r)o=t.getPixelForTick(r),l();return i}function QB(n,t,e,i){return bn(n)?function Fce(n,t,e,i){const r=e.parse(n[0],i),s=e.parse(n[1],i),o=Math.min(r,s),a=Math.max(r,s);let l=o,c=a;Math.abs(o)>Math.abs(a)&&(l=a,c=o),t[e.axis]=c,t._custom={barStart:l,barEnd:c,start:r,end:s,min:o,max:a}}(n,t,e,i):t[e.axis]=e.parse(n,i),t}function JB(n,t,e,i){const r=n.iScale,s=n.vScale,o=r.getLabels(),a=r===s,l=[];let c,d,u,h;for(c=e,d=e+i;c<d;++c)h=t[c],u={},u[r.axis]=a||r.parse(o[c],c),l.push(QB(h,u,s,c));return l}function Uk(n){return n&&void 0!==n.barStart&&void 0!==n.barEnd}function $ce(n,t,e,i){let r=t.borderSkipped;const s={};if(!r)return void(n.borderSkipped=s);if(!0===r)return void(n.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});const{start:o,end:a,reverse:l,top:c,bottom:d}=function Lce(n){let t,e,i,r,s;return n.horizontal?(t=n.base>n.x,e="left",i="right"):(t=n.base<n.y,e="bottom",i="top"),t?(r="end",s="start"):(r="start",s="end"),{start:e,end:i,reverse:t,top:r,bottom:s}}(n);"middle"===r&&e&&(n.enableBorderRadius=!0,(e._top||0)===i?r=c:(e._bottom||0)===i?r=d:(s[ez(d,o,a,l)]=!0,r=c)),s[ez(r,o,a,l)]=!0,n.borderSkipped=s}function ez(n,t,e,i){return i?(n=function Vce(n,t,e){return n===t?e:n===e?t:n}(n,t,e),n=tz(n,e,t)):n=tz(n,t,e),n}function tz(n,t,e){return"start"===n?t:"end"===n?e:n}function Bce(n,{inflateAmount:t},e){n.inflateAmount="auto"===t?1===e?.33:0:t}jo.prototype.datasetElementType=null,jo.prototype.dataElementType=null;let zce=(()=>{class n extends jo{parsePrimitiveData(e,i,r,s){return JB(e,i,r,s)}parseArrayData(e,i,r,s){return JB(e,i,r,s)}parseObjectData(e,i,r,s){const{iScale:o,vScale:a}=e,{xAxisKey:l="x",yAxisKey:c="y"}=this._parsing,d="x"===o.axis?l:c,u="x"===a.axis?l:c,h=[];let p,f,m,g;for(p=r,f=r+s;p<f;++p)g=i[p],m={},m[o.axis]=o.parse(pl(g,d),p),h.push(QB(pl(g,u),m,a,p));return h}updateRangeFromParsed(e,i,r,s){super.updateRangeFromParsed(e,i,r,s);const o=r._custom;o&&i===this._cachedMeta.vScale&&(e.min=Math.min(e.min,o.min),e.max=Math.max(e.max,o.max))}getMaxOverflow(){return 0}getLabelAndValue(e){const i=this._cachedMeta,{iScale:r,vScale:s}=i,o=this.getParsed(e),a=o._custom,l=Uk(a)?"["+a.start+", "+a.end+"]":""+s.getLabelForValue(o[s.axis]);return{label:""+r.getLabelForValue(o[r.axis]),value:l}}initialize(){this.enableOptionSharing=!0,super.initialize(),this._cachedMeta.stack=this.getDataset().stack}update(e){const i=this._cachedMeta;this.updateElements(i.data,0,i.data.length,e)}updateElements(e,i,r,s){const o="reset"===s,{index:a,_cachedMeta:{vScale:l}}=this,c=l.getBasePixel(),d=l.isHorizontal(),u=this._getRuler(),{sharedOptions:h,includeOptions:p}=this._getSharedOptions(i,s);for(let f=i;f<i+r;f++){const m=this.getParsed(f),g=o||Vt(m[l.axis])?{base:c,head:c}:this._calculateBarValuePixels(f),_=this._calculateBarIndexPixels(f,u),b=(m._stacks||{})[l.axis],y={horizontal:d,base:g.base,enableBorderRadius:!b||Uk(m._custom)||a===b._top||a===b._bottom,x:d?g.head:_.center,y:d?_.center:g.head,height:d?_.size:Math.abs(g.size),width:d?Math.abs(g.size):_.size};p&&(y.options=h||this.resolveDataElementOptions(f,e[f].active?"active":s));const v=y.options||e[f].options;$ce(y,v,b,a),Bce(y,v,u.ratio),this.updateElement(e[f],f,y,s)}}_getStacks(e,i){const{iScale:r}=this._cachedMeta,s=r.getMatchingVisibleMetas(this._type).filter(c=>c.controller.options.grouped),o=r.options.stacked,a=[],l=c=>{const d=c.controller.getParsed(i),u=d&&d[c.vScale.axis];if(Vt(u)||isNaN(u))return!0};for(const c of s)if((void 0===i||!l(c))&&((!1===o||-1===a.indexOf(c.stack)||void 0===o&&void 0===c.stack)&&a.push(c.stack),c.index===e))break;return a.length||a.push(void 0),a}_getStackCount(e){return this._getStacks(void 0,e).length}_getStackIndex(e,i,r){const s=this._getStacks(e,r),o=void 0!==i?s.indexOf(i):-1;return-1===o?s.length-1:o}_getRuler(){const e=this.options,i=this._cachedMeta,r=i.iScale,s=[];let o,a;for(o=0,a=i.data.length;o<a;++o)s.push(r.getPixelForValue(this.getParsed(o)[r.axis],o));const l=e.barThickness;return{min:l||Nce(i),pixels:s,start:r._startPixel,end:r._endPixel,stackCount:this._getStackCount(),scale:r,grouped:e.grouped,ratio:l?1:e.categoryPercentage*e.barPercentage}}_calculateBarValuePixels(e){const{_cachedMeta:{vScale:i,_stacked:r},options:{base:s,minBarLength:o}}=this,a=s||0,l=this.getParsed(e),c=l._custom,d=Uk(c);let f,m,u=l[i.axis],h=0,p=r?this.applyStack(i,l,r):u;p!==u&&(h=p-u,p=u),d&&(u=c.barStart,p=c.barEnd-c.barStart,0!==u&&Ho(u)!==Ho(c.barEnd)&&(h=0),h+=u);const g=Vt(s)||d?h:s;let _=i.getPixelForValue(g);if(f=this.chart.getDataVisibility(e)?i.getPixelForValue(h+p):_,m=f-_,Math.abs(m)<o){m=function Pce(n,t,e){return 0!==n?Ho(n):(t.isHorizontal()?1:-1)*(t.min>=e?1:-1)}(m,i,a)*o,u===a&&(_-=m/2);const b=i.getPixelForDecimal(0),y=i.getPixelForDecimal(1),v=Math.min(b,y),x=Math.max(b,y);_=Math.max(Math.min(_,x),v),f=_+m}if(_===i.getPixelForValue(a)){const b=Ho(m)*i.getLineWidthForValue(a)/2;_+=b,m-=b}return{size:m,base:_,head:f,center:f+m/2}}_calculateBarIndexPixels(e,i){const r=i.scale,s=this.options,o=s.skipNull,a=ft(s.maxBarThickness,1/0);let l,c;if(i.grouped){const d=o?this._getStackCount(e):i.stackCount,u="flex"===s.barThickness?function Oce(n,t,e,i){const r=t.pixels,s=r[n];let o=n>0?r[n-1]:null,a=n<r.length-1?r[n+1]:null;const l=e.categoryPercentage;null===o&&(o=s-(null===a?t.end-t.start:a-s)),null===a&&(a=s+s-o);const c=s-(s-Math.min(o,a))/2*l;return{chunk:Math.abs(a-o)/2*l/i,ratio:e.barPercentage,start:c}}(e,i,s,d):function Rce(n,t,e,i){const r=e.barThickness;let s,o;return Vt(r)?(s=t.min*e.categoryPercentage,o=e.barPercentage):(s=r*i,o=1),{chunk:s/i,ratio:o,start:t.pixels[n]-s/2}}(e,i,s,d),h=this._getStackIndex(this.index,this._cachedMeta.stack,o?e:void 0);l=u.start+u.chunk*h+u.chunk/2,c=Math.min(a,u.chunk*u.ratio)}else l=r.getPixelForValue(this.getParsed(e)[r.axis],e),c=Math.min(a,i.min*i.ratio);return{base:l-c/2,head:l+c/2,center:l,size:c}}draw(){const e=this._cachedMeta,i=e.vScale,r=e.data,s=r.length;let o=0;for(;o<s;++o)null!==this.getParsed(o)[i.axis]&&r[o].draw(this._ctx)}}return n.id="bar",n.defaults={datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}},n.overrides={scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}},n})(),Uce=(()=>{class n extends jo{initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(e,i,r,s){const o=super.parsePrimitiveData(e,i,r,s);for(let a=0;a<o.length;a++)o[a]._custom=this.resolveDataElementOptions(a+r).radius;return o}parseArrayData(e,i,r,s){const o=super.parseArrayData(e,i,r,s);for(let a=0;a<o.length;a++)o[a]._custom=ft(i[r+a][2],this.resolveDataElementOptions(a+r).radius);return o}parseObjectData(e,i,r,s){const o=super.parseObjectData(e,i,r,s);for(let a=0;a<o.length;a++){const l=i[r+a];o[a]._custom=ft(l&&l.r&&+l.r,this.resolveDataElementOptions(a+r).radius)}return o}getMaxOverflow(){const e=this._cachedMeta.data;let i=0;for(let r=e.length-1;r>=0;--r)i=Math.max(i,e[r].size(this.resolveDataElementOptions(r))/2);return i>0&&i}getLabelAndValue(e){const i=this._cachedMeta,{xScale:r,yScale:s}=i,o=this.getParsed(e),a=r.getLabelForValue(o.x),l=s.getLabelForValue(o.y),c=o._custom;return{label:i.label,value:"("+a+", "+l+(c?", "+c:"")+")"}}update(e){const i=this._cachedMeta.data;this.updateElements(i,0,i.length,e)}updateElements(e,i,r,s){const o="reset"===s,{iScale:a,vScale:l}=this._cachedMeta,{sharedOptions:c,includeOptions:d}=this._getSharedOptions(i,s),u=a.axis,h=l.axis;for(let p=i;p<i+r;p++){const f=e[p],m=!o&&this.getParsed(p),g={},_=g[u]=o?a.getPixelForDecimal(.5):a.getPixelForValue(m[u]),b=g[h]=o?l.getBasePixel():l.getPixelForValue(m[h]);g.skip=isNaN(_)||isNaN(b),d&&(g.options=c||this.resolveDataElementOptions(p,f.active?"active":s),o&&(g.options.radius=0)),this.updateElement(f,p,g,s)}}resolveDataElementOptions(e,i){const r=this.getParsed(e);let s=super.resolveDataElementOptions(e,i);s.$shared&&(s=Object.assign({},s,{$shared:!1}));const o=s.radius;return"active"!==i&&(s.radius=0),s.radius+=ft(r&&r._custom,o),s}}return n.id="bubble",n.defaults={datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}},n.overrides={scales:{x:{type:"linear"},y:{type:"linear"}},plugins:{tooltip:{callbacks:{title:()=>""}}}},n})(),nz=(()=>{class n extends jo{constructor(e,i){super(e,i),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(e,i){const r=this.getDataset().data,s=this._cachedMeta;if(!1===this._parsing)s._parsed=r;else{let a,l,o=c=>+r[c];if(Tt(r[e])){const{key:c="value"}=this._parsing;o=d=>+pl(r[d],c)}for(a=e,l=e+i;a<l;++a)s._parsed[a]=o(a)}}_getRotation(){return mo(this.options.rotation-90)}_getCircumference(){return mo(this.options.circumference)}_getRotationExtents(){let e=sn,i=-sn;for(let r=0;r<this.chart.data.datasets.length;++r)if(this.chart.isDatasetVisible(r)){const s=this.chart.getDatasetMeta(r).controller,o=s._getRotation(),a=s._getCircumference();e=Math.min(e,o),i=Math.max(i,o+a)}return{rotation:e,circumference:i-e}}update(e){const i=this.chart,{chartArea:r}=i,s=this._cachedMeta,o=s.data,a=this.getMaxBorderWidth()+this.getMaxOffset(o)+this.options.spacing,l=Math.max((Math.min(r.width,r.height)-a)/2,0),c=Math.min(((n,t)=>"string"==typeof n&&n.endsWith("%")?parseFloat(n)/100:n/t)(this.options.cutout,l),1),d=this._getRingWeight(this.index),{circumference:u,rotation:h}=this._getRotationExtents(),{ratioX:p,ratioY:f,offsetX:m,offsetY:g}=function Hce(n,t,e){let i=1,r=1,s=0,o=0;if(t<sn){const a=n,l=a+t,c=Math.cos(a),d=Math.sin(a),u=Math.cos(l),h=Math.sin(l),p=(y,v,x)=>lf(y,a,l,!0)?1:Math.max(v,v*e,x,x*e),f=(y,v,x)=>lf(y,a,l,!0)?-1:Math.min(v,v*e,x,x*e),m=p(0,c,u),g=p(Gn,d,h),_=f(Mn,c,u),b=f(Mn+Gn,d,h);i=(m-_)/2,r=(g-b)/2,s=-(m+_)/2,o=-(g+b)/2}return{ratioX:i,ratioY:r,offsetX:s,offsetY:o}}(h,u,c),y=Math.max(Math.min((r.width-a)/p,(r.height-a)/f)/2,0),v=GV(this.options.radius,y),w=(v-Math.max(v*c,0))/this._getVisibleDatasetWeightTotal();this.offsetX=m*v,this.offsetY=g*v,s.total=this.calculateTotal(),this.outerRadius=v-w*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-w*d,0),this.updateElements(o,0,o.length,e)}_circumference(e,i){const r=this.options,s=this._cachedMeta,o=this._getCircumference();return i&&r.animation.animateRotate||!this.chart.getDataVisibility(e)||null===s._parsed[e]||s.data[e].hidden?0:this.calculateCircumference(s._parsed[e]*o/sn)}updateElements(e,i,r,s){const o="reset"===s,a=this.chart,l=a.chartArea,u=(l.left+l.right)/2,h=(l.top+l.bottom)/2,p=o&&a.options.animation.animateScale,f=p?0:this.innerRadius,m=p?0:this.outerRadius,{sharedOptions:g,includeOptions:_}=this._getSharedOptions(i,s);let y,b=this._getRotation();for(y=0;y<i;++y)b+=this._circumference(y,o);for(y=i;y<i+r;++y){const v=this._circumference(y,o),x=e[y],w={x:u+this.offsetX,y:h+this.offsetY,startAngle:b,endAngle:b+v,circumference:v,outerRadius:m,innerRadius:f};_&&(w.options=g||this.resolveDataElementOptions(y,x.active?"active":s)),b+=v,this.updateElement(x,y,w,s)}}calculateTotal(){const e=this._cachedMeta,i=e.data;let s,r=0;for(s=0;s<i.length;s++){const o=e._parsed[s];null!==o&&!isNaN(o)&&this.chart.getDataVisibility(s)&&!i[s].hidden&&(r+=Math.abs(o))}return r}calculateCircumference(e){const i=this._cachedMeta.total;return i>0&&!isNaN(e)?sn*(Math.abs(e)/i):0}getLabelAndValue(e){const r=this.chart,s=r.data.labels||[],o=gf(this._cachedMeta._parsed[e],r.options.locale);return{label:s[e]||"",value:o}}getMaxBorderWidth(e){let i=0;const r=this.chart;let s,o,a,l,c;if(!e)for(s=0,o=r.data.datasets.length;s<o;++s)if(r.isDatasetVisible(s)){a=r.getDatasetMeta(s),e=a.data,l=a.controller;break}if(!e)return 0;for(s=0,o=e.length;s<o;++s)c=l.resolveDataElementOptions(s),"inner"!==c.borderAlign&&(i=Math.max(i,c.borderWidth||0,c.hoverBorderWidth||0));return i}getMaxOffset(e){let i=0;for(let r=0,s=e.length;r<s;++r){const o=this.resolveDataElementOptions(r);i=Math.max(i,o.offset||0,o.hoverOffset||0)}return i}_getRingWeightOffset(e){let i=0;for(let r=0;r<e;++r)this.chart.isDatasetVisible(r)&&(i+=this._getRingWeight(r));return i}_getRingWeight(e){return Math.max(ft(this.chart.data.datasets[e].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}return n.id="doughnut",n.defaults={datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"},n.descriptors={_scriptable:t=>"spacing"!==t,_indexable:t=>"spacing"!==t},n.overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:i}}=t.legend.options;return e.labels.map((r,s)=>{const a=t.getDatasetMeta(0).controller.getStyle(s);return{text:r,fillStyle:a.backgroundColor,strokeStyle:a.borderColor,lineWidth:a.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(s),index:s}})}return[]}},onClick(t,e,i){i.chart.toggleDataVisibility(e.index),i.chart.update()}},tooltip:{callbacks:{title:()=>"",label(t){let e=t.label;const i=": "+t.formattedValue;return bn(e)?(e=e.slice(),e[0]+=i):e+=i,e}}}}},n})(),jce=(()=>{class n extends jo{initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(e){const i=this._cachedMeta,{dataset:r,data:s=[],_dataset:o}=i,a=this.chart._animationsDisabled;let{start:l,count:c}=oB(i,s,a);this._drawStart=l,this._drawCount=c,aB(i)&&(l=0,c=s.length),r._chart=this.chart,r._datasetIndex=this.index,r._decimated=!!o._decimated,r.points=s;const d=this.resolveDatasetElementOptions(e);this.options.showLine||(d.borderWidth=0),d.segment=this.options.segment,this.updateElement(r,void 0,{animated:!a,options:d},e),this.updateElements(s,l,c,e)}updateElements(e,i,r,s){const o="reset"===s,{iScale:a,vScale:l,_stacked:c,_dataset:d}=this._cachedMeta,{sharedOptions:u,includeOptions:h}=this._getSharedOptions(i,s),p=a.axis,f=l.axis,{spanGaps:m,segment:g}=this.options,_=Eu(m)?m:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||o||"none"===s;let y=i>0&&this.getParsed(i-1);for(let v=i;v<i+r;++v){const x=e[v],w=this.getParsed(v),C=b?x:{},D=Vt(w[f]),k=C[p]=a.getPixelForValue(w[p],v),I=C[f]=o||D?l.getBasePixel():l.getPixelForValue(c?this.applyStack(l,w,c):w[f],v);C.skip=isNaN(k)||isNaN(I)||D,C.stop=v>0&&Math.abs(w[p]-y[p])>_,g&&(C.parsed=w,C.raw=d.data[v]),h&&(C.options=u||this.resolveDataElementOptions(v,x.active?"active":s)),b||this.updateElement(x,v,C,s),y=w}}getMaxOverflow(){const e=this._cachedMeta,i=e.dataset,r=i.options&&i.options.borderWidth||0,s=e.data||[];if(!s.length)return r;const o=s[0].size(this.resolveDataElementOptions(0)),a=s[s.length-1].size(this.resolveDataElementOptions(s.length-1));return Math.max(r,o,a)/2}draw(){const e=this._cachedMeta;e.dataset.updateControlPoints(this.chart.chartArea,e.iScale.axis),super.draw()}}return n.id="line",n.defaults={datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1},n.overrides={scales:{_index_:{type:"category"},_value_:{type:"linear"}}},n})(),Wce=(()=>{class n extends jo{constructor(e,i){super(e,i),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(e){const r=this.chart,s=r.data.labels||[],o=gf(this._cachedMeta._parsed[e].r,r.options.locale);return{label:s[e]||"",value:o}}parseObjectData(e,i,r,s){return TB.bind(this)(e,i,r,s)}update(e){const i=this._cachedMeta.data;this._updateRadius(),this.updateElements(i,0,i.length,e)}getMinMax(){const i={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return this._cachedMeta.data.forEach((r,s)=>{const o=this.getParsed(s).r;!isNaN(o)&&this.chart.getDataVisibility(s)&&(o<i.min&&(i.min=o),o>i.max&&(i.max=o))}),i}_updateRadius(){const e=this.chart,i=e.chartArea,r=e.options,s=Math.min(i.right-i.left,i.bottom-i.top),o=Math.max(s/2,0),l=(o-Math.max(r.cutoutPercentage?o/100*r.cutoutPercentage:1,0))/e.getVisibleDatasetCount();this.outerRadius=o-l*this.index,this.innerRadius=this.outerRadius-l}updateElements(e,i,r,s){const o="reset"===s,a=this.chart,c=a.options.animation,d=this._cachedMeta.rScale,u=d.xCenter,h=d.yCenter,p=d.getIndexAngle(0)-.5*Mn;let m,f=p;const g=360/this.countVisibleElements();for(m=0;m<i;++m)f+=this._computeAngle(m,s,g);for(m=i;m<i+r;m++){const _=e[m];let b=f,y=f+this._computeAngle(m,s,g),v=a.getDataVisibility(m)?d.getDistanceFromCenterForValue(this.getParsed(m).r):0;f=y,o&&(c.animateScale&&(v=0),c.animateRotate&&(b=y=p));const x={x:u,y:h,innerRadius:0,outerRadius:v,startAngle:b,endAngle:y,options:this.resolveDataElementOptions(m,_.active?"active":s)};this.updateElement(_,m,x,s)}}countVisibleElements(){let i=0;return this._cachedMeta.data.forEach((r,s)=>{!isNaN(this.getParsed(s).r)&&this.chart.getDataVisibility(s)&&i++}),i}_computeAngle(e,i,r){return this.chart.getDataVisibility(e)?mo(this.resolveDataElementOptions(e,i).angle||r):0}}return n.id="polarArea",n.defaults={dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0},n.overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:i}}=t.legend.options;return e.labels.map((r,s)=>{const a=t.getDatasetMeta(0).controller.getStyle(s);return{text:r,fillStyle:a.backgroundColor,strokeStyle:a.borderColor,lineWidth:a.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(s),index:s}})}return[]}},onClick(t,e,i){i.chart.toggleDataVisibility(e.index),i.chart.update()}},tooltip:{callbacks:{title:()=>"",label:t=>t.chart.data.labels[t.dataIndex]+": "+t.formattedValue}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}},n})(),Gce=(()=>{class n extends nz{}return n.id="pie",n.defaults={cutout:0,rotation:0,circumference:360,radius:"100%"},n})(),qce=(()=>{class n extends jo{getLabelAndValue(e){const i=this._cachedMeta.vScale,r=this.getParsed(e);return{label:i.getLabels()[e],value:""+i.getLabelForValue(r[i.axis])}}parseObjectData(e,i,r,s){return TB.bind(this)(e,i,r,s)}update(e){const i=this._cachedMeta,r=i.dataset,s=i.data||[],o=i.iScale.getLabels();if(r.points=s,"resize"!==e){const a=this.resolveDatasetElementOptions(e);this.options.showLine||(a.borderWidth=0),this.updateElement(r,void 0,{_loop:!0,_fullLoop:o.length===s.length,options:a},e)}this.updateElements(s,0,s.length,e)}updateElements(e,i,r,s){const o=this._cachedMeta.rScale,a="reset"===s;for(let l=i;l<i+r;l++){const c=e[l],d=this.resolveDataElementOptions(l,c.active?"active":s),u=o.getPointPositionForValue(l,this.getParsed(l).r),h=a?o.xCenter:u.x,p=a?o.yCenter:u.y,f={x:h,y:p,angle:u.angle,skip:isNaN(h)||isNaN(p),options:d};this.updateElement(c,l,f,s)}}}return n.id="radar",n.defaults={datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}},n.overrides={aspectRatio:1,scales:{r:{type:"radialLinear"}}},n})();class go{constructor(){this.x=void 0,this.y=void 0,this.active=!1,this.options=void 0,this.$animations=void 0}tooltipPosition(t){const{x:e,y:i}=this.getProps(["x","y"],t);return{x:e,y:i}}hasValue(){return Eu(this.x)&&Eu(this.y)}getProps(t,e){const i=this.$animations;if(!e||!i)return this;const r={};return t.forEach(s=>{r[s]=i[s]&&i[s].active()?i[s]._to:this[s]}),r}}go.defaults={},go.defaultRoutes=void 0;const iz={values:n=>bn(n)?n:""+n,numeric(n,t,e){if(0===n)return"0";const i=this.chart.options.locale;let r,s=n;if(e.length>1){const c=Math.max(Math.abs(e[0].value),Math.abs(e[e.length-1].value));(c<1e-4||c>1e15)&&(r="scientific"),s=function Yce(n,t){let e=t.length>3?t[2].value-t[1].value:t[1].value-t[0].value;return Math.abs(e)>=1&&n!==Math.floor(n)&&(e=n-Math.floor(n)),e}(n,e)}const o=$s(Math.abs(s)),a=Math.max(Math.min(-1*Math.floor(o),20),0),l={notation:r,minimumFractionDigits:a,maximumFractionDigits:a};return Object.assign(l,this.options.ticks.format),gf(n,i,l)},logarithmic(n,t,e){if(0===n)return"0";const i=n/Math.pow(10,Math.floor($s(n)));return 1===i||2===i||5===i?iz.numeric.call(this,n,t,e):""}};var _y={formatters:iz};function by(n,t,e,i,r){const s=ft(i,0),o=Math.min(ft(r,n.length),n.length);let l,c,d,a=0;for(e=Math.ceil(e),r&&(l=r-i,e=l/Math.floor(l/e)),d=s;d<0;)a++,d=Math.round(s+a*e);for(c=Math.max(s,0);c<o;c++)c===d&&(t.push(n[c]),a++,d=Math.round(s+a*e))}At.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",grace:0,grid:{display:!0,lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(n,t)=>t.lineWidth,tickColor:(n,t)=>t.color,offset:!1,borderDash:[],borderDashOffset:0,borderWidth:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:_y.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),At.route("scale.ticks","color","","color"),At.route("scale.grid","color","","borderColor"),At.route("scale.grid","borderColor","","borderColor"),At.route("scale.title","color","","color"),At.describe("scale",{_fallback:!1,_scriptable:n=>!n.startsWith("before")&&!n.startsWith("after")&&"callback"!==n&&"parser"!==n,_indexable:n=>"borderDash"!==n&&"tickBorderDash"!==n}),At.describe("scales",{_fallback:"scale"}),At.describe("scale.ticks",{_scriptable:n=>"backdropPadding"!==n&&"callback"!==n,_indexable:n=>"backdropPadding"!==n});const tde=n=>"left"===n?"right":"right"===n?"left":n,rz=(n,t,e)=>"top"===t||"left"===t?n[t]+e:n[t]-e;function sz(n,t){const e=[],i=n.length/t,r=n.length;let s=0;for(;s<r;s+=i)e.push(n[Math.floor(s)]);return e}function nde(n,t,e){const i=n.ticks.length,r=Math.min(t,i-1),s=n._startPixel,o=n._endPixel,a=1e-6;let c,l=n.getPixelForTick(r);if(!(e&&(c=1===i?Math.max(l-s,o-l):0===t?(n.getPixelForTick(1)-l)/2:(l-n.getPixelForTick(r-1))/2,l+=r<t?c:-c,l<s-a||l>o+a)))return l}function bf(n){return n.drawTicks?n.tickLength:0}function oz(n,t){if(!n.display)return 0;const e=ki(n.font,t),i=dr(n.padding);return(bn(n.text)?n.text.length:1)*e.lineHeight+i.height}function ode(n,t,e){let i=Dk(n);return(e&&"right"!==t||!e&&"right"===t)&&(i=tde(i)),i}class Uc extends go{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:r}=this;return t=Ps(t,Number.POSITIVE_INFINITY),e=Ps(e,Number.NEGATIVE_INFINITY),i=Ps(i,Number.POSITIVE_INFINITY),r=Ps(r,Number.NEGATIVE_INFINITY),{min:Ps(t,i),max:Ps(e,r),minDefined:ni(t),maxDefined:ni(e)}}getMinMax(t){let o,{min:e,max:i,minDefined:r,maxDefined:s}=this.getUserBounds();if(r&&s)return{min:e,max:i};const a=this.getMatchingVisibleMetas();for(let l=0,c=a.length;l<c;++l)o=a[l].controller.getMinMax(this,t),r||(e=Math.min(e,o.min)),s||(i=Math.max(i,o.max));return e=s&&e>i?i:e,i=r&&e>i?e:i,{min:Ps(e,Ps(i,e)),max:Ps(i,Ps(e,i))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){yn(this.options.beforeUpdate,[this])}update(t,e,i){const{beginAtZero:r,grace:s,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+i.left+i.right:this.height+i.top+i.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=function Rle(n,t,e){const{min:i,max:r}=n,s=GV(t,(r-i)/2),o=(a,l)=>e&&0===a?0:a+l;return{min:o(i,-Math.abs(s)),max:o(r,s)}}(this,s,r),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const l=a<this.ticks.length;this._convertTicksToLabels(l?sz(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||"auto"===o.source)&&(this.ticks=function Kce(n,t){const e=n.options.ticks,i=e.maxTicksLimit||function Xce(n){const t=n.options.offset,e=n._tickSize();return Math.floor(Math.min(n._length/e+(t?0:1),n._maxLength/e))}(n),r=e.major.enabled?function Qce(n){const t=[];let e,i;for(e=0,i=n.length;e<i;e++)n[e].major&&t.push(e);return t}(t):[],s=r.length,o=r[0],a=r[s-1],l=[];if(s>i)return function Jce(n,t,e,i){let o,r=0,s=e[0];for(i=Math.ceil(i),o=0;o<n.length;o++)o===s&&(t.push(n[o]),r++,s=e[r*i])}(t,l,r,s/i),l;const c=function Zce(n,t,e){const i=function ede(n){const t=n.length;let e,i;if(t<2)return!1;for(i=n[0],e=1;e<t;++e)if(n[e]-n[e-1]!==i)return!1;return i}(n),r=t.length/e;if(!i)return Math.max(r,1);const s=function Wae(n){const t=[],e=Math.sqrt(n);let i;for(i=1;i<e;i++)n%i==0&&(t.push(i),t.push(n/i));return e===(0|e)&&t.push(e),t.sort((r,s)=>r-s).pop(),t}(i);for(let o=0,a=s.length-1;o<a;o++){const l=s[o];if(l>r)return l}return Math.max(r,1)}(r,t,i);if(s>0){let d,u;const h=s>1?Math.round((a-o)/(s-1)):null;for(by(t,l,c,Vt(h)?0:o-h,o),d=0,u=s-1;d<u;d++)by(t,l,c,r[d],r[d+1]);return by(t,l,c,a,Vt(h)?t.length:a+h),l}return by(t,l,c),l}(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),l&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let e,i,t=this.options.reverse;this.isHorizontal()?(e=this.left,i=this.right):(e=this.top,i=this.bottom,t=!t),this._startPixel=e,this._endPixel=i,this._reversePixels=t,this._length=i-e,this._alignToPixels=this.options.alignToPixels}afterUpdate(){yn(this.options.afterUpdate,[this])}beforeSetDimensions(){yn(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){yn(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),yn(this.options[t],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){yn(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let i,r,s;for(i=0,r=t.length;i<r;i++)s=t[i],s.label=yn(e.callback,[s.value,i,t],this)}afterTickToLabelConversion(){yn(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){yn(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,i=this.ticks.length,r=e.minRotation||0,s=e.maxRotation;let a,l,c,o=r;if(!this._isVisible()||!e.display||r>=s||i<=1||!this.isHorizontal())return void(this.labelRotation=r);const d=this._getLabelSizes(),u=d.widest.width,h=d.highest.height,p=Bi(this.chart.width-u,0,this.maxWidth);a=t.offset?this.maxWidth/i:p/(i-1),u+6>a&&(a=p/(i-(t.offset?.5:1)),l=this.maxHeight-bf(t.grid)-e.padding-oz(t.title,this.chart.options.font),c=Math.sqrt(u*u+h*h),o=xk(Math.min(Math.asin(Bi((d.highest.height+6)/a,-1,1)),Math.asin(Bi(l/c,-1,1))-Math.asin(Bi(h/c,-1,1)))),o=Math.max(r,Math.min(s,o))),this.labelRotation=o}afterCalculateLabelRotation(){yn(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){yn(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:i,title:r,grid:s}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const l=oz(r,e.options.font);if(a?(t.width=this.maxWidth,t.height=bf(s)+l):(t.height=this.maxHeight,t.width=bf(s)+l),i.display&&this.ticks.length){const{first:c,last:d,widest:u,highest:h}=this._getLabelSizes(),p=2*i.padding,f=mo(this.labelRotation),m=Math.cos(f),g=Math.sin(f);a?t.height=Math.min(this.maxHeight,t.height+(i.mirror?0:g*u.width+m*h.height)+p):t.width=Math.min(this.maxWidth,t.width+(i.mirror?0:m*u.width+g*h.height)+p),this._calculatePadding(c,d,g,m)}}this._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,i,r){const{ticks:{align:s,padding:o},position:a}=this.options,l=0!==this.labelRotation,c="top"!==a&&"x"===this.axis;if(this.isHorizontal()){const d=this.getPixelForTick(0)-this.left,u=this.right-this.getPixelForTick(this.ticks.length-1);let h=0,p=0;l?c?(h=r*t.width,p=i*e.height):(h=i*t.height,p=r*e.width):"start"===s?p=e.width:"end"===s?h=t.width:"inner"!==s&&(h=t.width/2,p=e.width/2),this.paddingLeft=Math.max((h-d+o)*this.width/(this.width-d),0),this.paddingRight=Math.max((p-u+o)*this.width/(this.width-u),0)}else{let d=e.height/2,u=t.height/2;"start"===s?(d=0,u=t.height):"end"===s&&(d=e.height,u=0),this.paddingTop=d+o,this.paddingBottom=u+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){yn(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return"top"===e||"bottom"===e||"x"===t}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){let e,i;for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,i=t.length;e<i;e++)Vt(t[e].label)&&(t.splice(e,1),i--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let i=this.ticks;e<i.length&&(i=sz(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length)}return t}_computeLabelSizes(t,e){const{ctx:i,_longestTextCache:r}=this,s=[],o=[];let c,d,u,h,p,f,m,g,_,b,y,a=0,l=0;for(c=0;c<e;++c){if(h=t[c].label,p=this._resolveTickFontOptions(c),i.font=f=p.string,m=r[f]=r[f]||{data:{},gc:[]},g=p.lineHeight,_=b=0,Vt(h)||bn(h)){if(bn(h))for(d=0,u=h.length;d<u;++d)y=h[d],!Vt(y)&&!bn(y)&&(_=uy(i,m.data,m.gc,_,y),b+=g)}else _=uy(i,m.data,m.gc,_,h),b=g;s.push(_),o.push(b),a=Math.max(_,a),l=Math.max(b,l)}!function ide(n,t){en(n,e=>{const i=e.gc,r=i.length/2;let s;if(r>t){for(s=0;s<r;++s)delete e.data[i[s]];i.splice(0,r)}})}(r,e);const v=s.indexOf(a),x=o.indexOf(l),w=C=>({width:s[C]||0,height:o[C]||0});return{first:w(0),last:w(e-1),widest:w(v),highest:w(x),widths:s,heights:o}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return function Yae(n){return Bi(n,-32768,32767)}(this._alignToPixels?Pc(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const i=e[t];return i.$context||(i.$context=function sde(n,t,e){return _l(n,{tick:e,index:t,type:"tick"})}(this.getContext(),t,i))}return this.$context||(this.$context=function rde(n,t){return _l(n,{scale:t,type:"scale"})}(this.chart.getContext(),this))}_tickSize(){const t=this.options.ticks,e=mo(this.labelRotation),i=Math.abs(Math.cos(e)),r=Math.abs(Math.sin(e)),s=this._getLabelSizes(),o=t.autoSkipPadding||0,a=s?s.widest.width+o:0,l=s?s.highest.height+o:0;return this.isHorizontal()?l*i>a*r?a/i:l/r:l*r<a*i?l/i:a/r}_isVisible(){const t=this.options.display;return"auto"!==t?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,i=this.chart,r=this.options,{grid:s,position:o}=r,a=s.offset,l=this.isHorizontal(),d=this.ticks.length+(a?1:0),u=bf(s),h=[],p=s.setContext(this.getContext()),f=p.drawBorder?p.borderWidth:0,m=f/2,g=function(z){return Pc(i,z,f)};let _,b,y,v,x,w,C,D,k,I,A,$;if("top"===o)_=g(this.bottom),w=this.bottom-u,D=_-m,I=g(t.top)+m,$=t.bottom;else if("bottom"===o)_=g(this.top),I=t.top,$=g(t.bottom)-m,w=_+m,D=this.top+u;else if("left"===o)_=g(this.right),x=this.right-u,C=_-m,k=g(t.left)+m,A=t.right;else if("right"===o)_=g(this.left),k=t.left,A=g(t.right)-m,x=_+m,C=this.left+u;else if("x"===e){if("center"===o)_=g((t.top+t.bottom)/2+.5);else if(Tt(o)){const z=Object.keys(o)[0];_=g(this.chart.scales[z].getPixelForValue(o[z]))}I=t.top,$=t.bottom,w=_+m,D=w+u}else if("y"===e){if("center"===o)_=g((t.left+t.right)/2);else if(Tt(o)){const z=Object.keys(o)[0];_=g(this.chart.scales[z].getPixelForValue(o[z]))}x=_-m,C=x-u,k=t.left,A=t.right}const H=ft(r.ticks.maxTicksLimit,d),W=Math.max(1,Math.ceil(d/H));for(b=0;b<d;b+=W){const z=s.setContext(this.getContext(b)),M=z.lineWidth,F=z.color,L=z.borderDash||[],j=z.borderDashOffset,Z=z.tickWidth,ee=z.tickColor,se=z.tickBorderDash||[],re=z.tickBorderDashOffset;y=nde(this,b,a),void 0!==y&&(v=Pc(i,y,M),l?x=C=k=A=v:w=D=I=$=v,h.push({tx1:x,ty1:w,tx2:C,ty2:D,x1:k,y1:I,x2:A,y2:$,width:M,color:F,borderDash:L,borderDashOffset:j,tickWidth:Z,tickColor:ee,tickBorderDash:se,tickBorderDashOffset:re}))}return this._ticksLength=d,this._borderValue=_,h}_computeLabelItems(t){const e=this.axis,i=this.options,{position:r,ticks:s}=i,o=this.isHorizontal(),a=this.ticks,{align:l,crossAlign:c,padding:d,mirror:u}=s,h=bf(i.grid),p=h+d,f=u?-d:p,m=-mo(this.labelRotation),g=[];let _,b,y,v,x,w,C,D,k,I,A,$,H="middle";if("top"===r)w=this.bottom-f,C=this._getXAxisLabelAlignment();else if("bottom"===r)w=this.top+f,C=this._getXAxisLabelAlignment();else if("left"===r){const z=this._getYAxisLabelAlignment(h);C=z.textAlign,x=z.x}else if("right"===r){const z=this._getYAxisLabelAlignment(h);C=z.textAlign,x=z.x}else if("x"===e){if("center"===r)w=(t.top+t.bottom)/2+p;else if(Tt(r)){const z=Object.keys(r)[0];w=this.chart.scales[z].getPixelForValue(r[z])+p}C=this._getXAxisLabelAlignment()}else if("y"===e){if("center"===r)x=(t.left+t.right)/2-p;else if(Tt(r)){const z=Object.keys(r)[0];x=this.chart.scales[z].getPixelForValue(r[z])}C=this._getYAxisLabelAlignment(h).textAlign}"y"===e&&("start"===l?H="top":"end"===l&&(H="bottom"));const W=this._getLabelSizes();for(_=0,b=a.length;_<b;++_){y=a[_],v=y.label;const z=s.setContext(this.getContext(_));D=this.getPixelForTick(_)+s.labelOffset,k=this._resolveTickFontOptions(_),I=k.lineHeight,A=bn(v)?v.length:1;const M=A/2,F=z.color,L=z.textStrokeColor,j=z.textStrokeWidth;let ee,Z=C;if(o?(x=D,"inner"===C&&(Z=_===b-1?this.options.reverse?"left":"right":0===_?this.options.reverse?"right":"left":"center"),$="top"===r?"near"===c||0!==m?-A*I+I/2:"center"===c?-W.highest.height/2-M*I+I:I/2-W.highest.height:"near"===c||0!==m?I/2:"center"===c?W.highest.height/2-M*I:W.highest.height-A*I,u&&($*=-1)):(w=D,$=(1-A)*I/2),z.showLabelBackdrop){const se=dr(z.backdropPadding),re=W.heights[_],ae=W.widths[_];let pe=w+$-se.top,xe=x-se.left;switch(H){case"middle":pe-=re/2;break;case"bottom":pe-=re}switch(C){case"center":xe-=ae/2;break;case"right":xe-=ae}ee={left:xe,top:pe,width:ae+se.width,height:re+se.height,color:z.backdropColor}}g.push({rotation:m,label:v,font:k,color:F,strokeColor:L,strokeWidth:j,textOffset:$,textAlign:Z,textBaseline:H,translation:[x,w],backdrop:ee})}return g}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-mo(this.labelRotation))return"top"===t?"left":"right";let r="center";return"start"===e.align?r="left":"end"===e.align?r="right":"inner"===e.align&&(r="inner"),r}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:r,padding:s}}=this.options,a=t+s,l=this._getLabelSizes().widest.width;let c,d;return"left"===e?r?(d=this.right+s,"near"===i?c="left":"center"===i?(c="center",d+=l/2):(c="right",d+=l)):(d=this.right-a,"near"===i?c="right":"center"===i?(c="center",d-=l/2):(c="left",d=this.left)):"right"===e?r?(d=this.left+s,"near"===i?c="right":"center"===i?(c="center",d-=l/2):(c="left",d-=l)):(d=this.left+a,"near"===i?c="left":"center"===i?(c="center",d+=l/2):(c="right",d=this.right)):c="right",{textAlign:c,x:d}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;return"left"===e||"right"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:"top"===e||"bottom"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:r,width:s,height:o}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(i,r,s,o),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const r=this.ticks.findIndex(s=>s.value===t);return r>=0?e.setContext(this.getContext(r)).lineWidth:0}drawGrid(t){const e=this.options.grid,i=this.ctx,r=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let s,o;const a=(l,c,d)=>{!d.width||!d.color||(i.save(),i.lineWidth=d.width,i.strokeStyle=d.color,i.setLineDash(d.borderDash||[]),i.lineDashOffset=d.borderDashOffset,i.beginPath(),i.moveTo(l.x,l.y),i.lineTo(c.x,c.y),i.stroke(),i.restore())};if(e.display)for(s=0,o=r.length;s<o;++s){const l=r[s];e.drawOnChartArea&&a({x:l.x1,y:l.y1},{x:l.x2,y:l.y2},l),e.drawTicks&&a({x:l.tx1,y:l.ty1},{x:l.tx2,y:l.ty2},{color:l.tickColor,width:l.tickWidth,borderDash:l.tickBorderDash,borderDashOffset:l.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{grid:i}}=this,r=i.setContext(this.getContext()),s=i.drawBorder?r.borderWidth:0;if(!s)return;const o=i.setContext(this.getContext(0)).lineWidth,a=this._borderValue;let l,c,d,u;this.isHorizontal()?(l=Pc(t,this.left,s)-s/2,c=Pc(t,this.right,o)+o/2,d=u=a):(d=Pc(t,this.top,s)-s/2,u=Pc(t,this.bottom,o)+o/2,l=c=a),e.save(),e.lineWidth=r.borderWidth,e.strokeStyle=r.borderColor,e.beginPath(),e.moveTo(l,d),e.lineTo(c,u),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const i=this.ctx,r=this._computeLabelArea();r&&hy(i,r);const s=this._labelItems||(this._labelItems=this._computeLabelItems(t));let o,a;for(o=0,a=s.length;o<a;++o){const l=s[o],c=l.font,d=l.label;l.backdrop&&(i.fillStyle=l.backdrop.color,i.fillRect(l.backdrop.left,l.backdrop.top,l.backdrop.width,l.backdrop.height)),Lc(i,d,0,l.textOffset,c,l)}r&&py(i)}drawTitle(){const{ctx:t,options:{position:e,title:i,reverse:r}}=this;if(!i.display)return;const s=ki(i.font),o=dr(i.padding),a=i.align;let l=s.lineHeight/2;"bottom"===e||"center"===e||Tt(e)?(l+=o.bottom,bn(i.text)&&(l+=s.lineHeight*(i.text.length-1))):l+=o.top;const{titleX:c,titleY:d,maxWidth:u,rotation:h}=function ade(n,t,e,i){const{top:r,left:s,bottom:o,right:a,chart:l}=n,{chartArea:c,scales:d}=l;let h,p,f,u=0;const m=o-r,g=a-s;if(n.isHorizontal()){if(p=cr(i,s,a),Tt(e)){const _=Object.keys(e)[0];f=d[_].getPixelForValue(e[_])+m-t}else f="center"===e?(c.bottom+c.top)/2+m-t:rz(n,e,t);h=a-s}else{if(Tt(e)){const _=Object.keys(e)[0];p=d[_].getPixelForValue(e[_])-g+t}else p="center"===e?(c.left+c.right)/2-g+t:rz(n,e,t);f=cr(i,o,r),u="left"===e?-Gn:Gn}return{titleX:p,titleY:f,maxWidth:h,rotation:u}}(this,l,e,a);Lc(t,i.text,0,0,s,{color:i.color,maxWidth:u,rotation:h,textAlign:ode(a,e,r),textBaseline:"middle",translation:[c,d]})}draw(t){this._isVisible()&&(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,i=ft(t.grid&&t.grid.z,-1);return this._isVisible()&&this.draw===Uc.prototype.draw?[{z:i,draw:r=>{this.drawBackground(),this.drawGrid(r),this.drawTitle()}},{z:i+1,draw:()=>{this.drawBorder()}},{z:e,draw:r=>{this.drawLabels(r)}}]:[{z:e,draw:r=>{this.draw(r)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),i=this.axis+"AxisID",r=[];let s,o;for(s=0,o=e.length;s<o;++s){const a=e[s];a[i]===this.id&&(!t||a.type===t)&&r.push(a)}return r}_resolveTickFontOptions(t){return ki(this.options.ticks.setContext(this.getContext(t)).font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class yy{constructor(t,e,i){this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let i;(function dde(n){return"id"in n&&"defaults"in n})(e)&&(i=this.register(e));const r=this.items,s=t.id,o=this.scope+"."+s;if(!s)throw new Error("class does not have id: "+t);return s in r||(r[s]=t,function lde(n,t,e){const i=nf(Object.create(null),[e?At.get(e):{},At.get(t),n.defaults]);At.set(t,i),n.defaultRoutes&&function cde(n,t){Object.keys(t).forEach(e=>{const i=e.split("."),r=i.pop(),s=[n].concat(i).join("."),o=t[e].split("."),a=o.pop(),l=o.join(".");At.route(s,r,l,a)})}(t,n.defaultRoutes),n.descriptors&&At.describe(t,n.descriptors)}(t,o,i),this.override&&At.override(t.id,t.overrides)),o}get(t){return this.items[t]}unregister(t){const e=this.items,i=t.id,r=this.scope;i in e&&delete e[i],r&&i in At[r]&&(delete At[r][i],this.override&&delete Fc[i])}}var Wo=new class ude{constructor(){this.controllers=new yy(jo,"datasets",!0),this.elements=new yy(go,"elements"),this.plugins=new yy(Object,"plugins"),this.scales=new yy(Uc,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each("register",t)}remove(...t){this._each("unregister",t)}addControllers(...t){this._each("register",t,this.controllers)}addElements(...t){this._each("register",t,this.elements)}addPlugins(...t){this._each("register",t,this.plugins)}addScales(...t){this._each("register",t,this.scales)}getController(t){return this._get(t,this.controllers,"controller")}getElement(t){return this._get(t,this.elements,"element")}getPlugin(t){return this._get(t,this.plugins,"plugin")}getScale(t){return this._get(t,this.scales,"scale")}removeControllers(...t){this._each("unregister",t,this.controllers)}removeElements(...t){this._each("unregister",t,this.elements)}removePlugins(...t){this._each("unregister",t,this.plugins)}removeScales(...t){this._each("unregister",t,this.scales)}_each(t,e,i){[...e].forEach(r=>{const s=i||this._getRegistryForType(r);i||s.isForType(r)||s===this.plugins&&r.id?this._exec(t,s,r):en(r,o=>{const a=i||this._getRegistryForType(o);this._exec(t,a,o)})})}_exec(t,e,i){const r=vk(t);yn(i["before"+r],[],i),e[t](i),yn(i["after"+r],[],i)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const i=this._typedRegistries[e];if(i.isForType(t))return i}return this.plugins}_get(t,e,i){const r=e.get(t);if(void 0===r)throw new Error('"'+t+'" is not a registered '+i+".");return r}},hde=Object.freeze({__proto__:null,BarController:zce,BubbleController:Uce,DoughnutController:nz,LineController:jce,PolarAreaController:Wce,PieController:Gce,RadarController:qce,ScatterController:(()=>{class n extends jo{update(e){const i=this._cachedMeta,{data:r=[]}=i,s=this.chart._animationsDisabled;let{start:o,count:a}=oB(i,r,s);if(this._drawStart=o,this._drawCount=a,aB(i)&&(o=0,a=r.length),this.options.showLine){const{dataset:l,_dataset:c}=i;l._chart=this.chart,l._datasetIndex=this.index,l._decimated=!!c._decimated,l.points=r;const d=this.resolveDatasetElementOptions(e);d.segment=this.options.segment,this.updateElement(l,void 0,{animated:!s,options:d},e)}this.updateElements(r,o,a,e)}addElements(){const{showLine:e}=this.options;!this.datasetElementType&&e&&(this.datasetElementType=Wo.getElement("line")),super.addElements()}updateElements(e,i,r,s){const o="reset"===s,{iScale:a,vScale:l,_stacked:c,_dataset:d}=this._cachedMeta,u=this.resolveDataElementOptions(i,s),h=this.getSharedOptions(u),p=this.includeOptions(s,h),f=a.axis,m=l.axis,{spanGaps:g,segment:_}=this.options,b=Eu(g)?g:Number.POSITIVE_INFINITY,y=this.chart._animationsDisabled||o||"none"===s;let v=i>0&&this.getParsed(i-1);for(let x=i;x<i+r;++x){const w=e[x],C=this.getParsed(x),D=y?w:{},k=Vt(C[m]),I=D[f]=a.getPixelForValue(C[f],x),A=D[m]=o||k?l.getBasePixel():l.getPixelForValue(c?this.applyStack(l,C,c):C[m],x);D.skip=isNaN(I)||isNaN(A)||k,D.stop=x>0&&Math.abs(C[f]-v[f])>b,_&&(D.parsed=C,D.raw=d.data[x]),p&&(D.options=h||this.resolveDataElementOptions(x,w.active?"active":s)),y||this.updateElement(w,x,D,s),v=C}this.updateSharedOptions(h,s,u)}getMaxOverflow(){const e=this._cachedMeta,i=e.data||[];if(!this.options.showLine){let l=0;for(let c=i.length-1;c>=0;--c)l=Math.max(l,i[c].size(this.resolveDataElementOptions(c))/2);return l>0&&l}const r=e.dataset,s=r.options&&r.options.borderWidth||0;if(!i.length)return s;const o=i[0].size(this.resolveDataElementOptions(0)),a=i[i.length-1].size(this.resolveDataElementOptions(i.length-1));return Math.max(s,o,a)/2}}return n.id="scatter",n.defaults={datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1},n.overrides={interaction:{mode:"point"},plugins:{tooltip:{callbacks:{title:()=>"",label:t=>"("+t.label+", "+t.formattedValue+")"}}},scales:{x:{type:"linear"},y:{type:"linear"}}},n})()});function Hc(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}var pde={_date:(()=>{class n{constructor(e){this.options=e||{}}init(e){}formats(){return Hc()}parse(e,i){return Hc()}format(e,i){return Hc()}add(e,i,r){return Hc()}diff(e,i,r){return Hc()}startOf(e,i,r){return Hc()}endOf(e,i){return Hc()}}return n.override=function(t){Object.assign(n.prototype,t)},n})()};function fde(n,t,e,i){const{controller:r,data:s,_sorted:o}=n,a=r._cachedMeta.iScale;if(a&&t===a.axis&&"r"!==t&&o&&s.length){const l=a._reversePixels?Kae:Na;if(!i)return l(s,t,e);if(r._sharedOptions){const c=s[0],d="function"==typeof c.getRange&&c.getRange(t);if(d){const u=l(s,t,e-d),h=l(s,t,e+d);return{lo:u.lo,hi:h.hi}}}}return{lo:0,hi:s.length-1}}function yf(n,t,e,i,r){const s=n.getSortedVisibleDatasetMetas(),o=e[t];for(let a=0,l=s.length;a<l;++a){const{index:c,data:d}=s[a],{lo:u,hi:h}=fde(s[a],t,o,r);for(let p=u;p<=h;++p){const f=d[p];f.skip||i(f,c,p)}}}function Hk(n,t,e,i,r){const s=[];return!r&&!n.isPointInArea(t)||yf(n,e,t,function(a,l,c){!r&&!pf(a,n.chartArea,0)||a.inRange(t.x,t.y,i)&&s.push({element:a,datasetIndex:l,index:c})},!0),s}function jk(n,t,e,i,r,s){return s||n.isPointInArea(t)?"r"!==e||i?function _de(n,t,e,i,r,s){let o=[];const a=function mde(n){const t=-1!==n.indexOf("x"),e=-1!==n.indexOf("y");return function(i,r){const s=t?Math.abs(i.x-r.x):0,o=e?Math.abs(i.y-r.y):0;return Math.sqrt(Math.pow(s,2)+Math.pow(o,2))}}(e);let l=Number.POSITIVE_INFINITY;return yf(n,e,t,function c(d,u,h){const p=d.inRange(t.x,t.y,r);if(i&&!p)return;const f=d.getCenterPoint(r);if(!s&&!n.isPointInArea(f)&&!p)return;const g=a(t,f);g<l?(o=[{element:d,datasetIndex:u,index:h}],l=g):g===l&&o.push({element:d,datasetIndex:u,index:h})}),o}(n,t,e,i,r,s):function gde(n,t,e,i){let r=[];return yf(n,e,t,function s(o,a,l){const{startAngle:c,endAngle:d}=o.getProps(["startAngle","endAngle"],i),{angle:u}=eB(o,{x:t.x,y:t.y});lf(u,c,d)&&r.push({element:o,datasetIndex:a,index:l})}),r}(n,t,e,r):[]}function az(n,t,e,i,r){const s=[],o="x"===e?"inXRange":"inYRange";let a=!1;return yf(n,e,t,(l,c,d)=>{l[o](t[e],r)&&(s.push({element:l,datasetIndex:c,index:d}),a=a||l.inRange(t.x,t.y,r))}),i&&!a?[]:s}var bde={evaluateInteractionItems:yf,modes:{index(n,t,e,i){const r=Bc(t,n),s=e.axis||"x",o=e.includeInvisible||!1,a=e.intersect?Hk(n,r,s,i,o):jk(n,r,s,!1,i,o),l=[];return a.length?(n.getSortedVisibleDatasetMetas().forEach(c=>{const d=a[0].index,u=c.data[d];u&&!u.skip&&l.push({element:u,datasetIndex:c.index,index:d})}),l):[]},dataset(n,t,e,i){const r=Bc(t,n),s=e.axis||"xy",o=e.includeInvisible||!1;let a=e.intersect?Hk(n,r,s,i,o):jk(n,r,s,!1,i,o);if(a.length>0){const l=a[0].datasetIndex,c=n.getDatasetMeta(l).data;a=[];for(let d=0;d<c.length;++d)a.push({element:c[d],datasetIndex:l,index:d})}return a},point:(n,t,e,i)=>Hk(n,Bc(t,n),e.axis||"xy",i,e.includeInvisible||!1),nearest:(n,t,e,i)=>jk(n,Bc(t,n),e.axis||"xy",e.intersect,i,e.includeInvisible||!1),x:(n,t,e,i)=>az(n,Bc(t,n),"x",e.intersect,i),y:(n,t,e,i)=>az(n,Bc(t,n),"y",e.intersect,i)}};const lz=["left","top","right","bottom"];function vf(n,t){return n.filter(e=>e.pos===t)}function cz(n,t){return n.filter(e=>-1===lz.indexOf(e.pos)&&e.box.axis===t)}function xf(n,t){return n.sort((e,i)=>{const r=t?i:e,s=t?e:i;return r.weight===s.weight?r.index-s.index:r.weight-s.weight})}function dz(n,t,e,i){return Math.max(n[e],t[e])+Math.max(n[i],t[i])}function uz(n,t){n.top=Math.max(n.top,t.top),n.left=Math.max(n.left,t.left),n.bottom=Math.max(n.bottom,t.bottom),n.right=Math.max(n.right,t.right)}function Cde(n,t,e,i){const{pos:r,box:s}=e,o=n.maxPadding;if(!Tt(r)){e.size&&(n[r]-=e.size);const u=i[e.stack]||{size:0,count:1};u.size=Math.max(u.size,e.horizontal?s.height:s.width),e.size=u.size/u.count,n[r]+=e.size}s.getPadding&&uz(o,s.getPadding());const a=Math.max(0,t.outerWidth-dz(o,n,"left","right")),l=Math.max(0,t.outerHeight-dz(o,n,"top","bottom")),c=a!==n.w,d=l!==n.h;return n.w=a,n.h=l,e.horizontal?{same:c,other:d}:{same:d,other:c}}function Sde(n,t){const e=t.maxPadding;return function i(r){const s={left:0,top:0,right:0,bottom:0};return r.forEach(o=>{s[o]=Math.max(t[o],e[o])}),s}(n?["left","right"]:["top","bottom"])}function wf(n,t,e,i){const r=[];let s,o,a,l,c,d;for(s=0,o=n.length,c=0;s<o;++s){a=n[s],l=a.box,l.update(a.width||t.w,a.height||t.h,Sde(a.horizontal,t));const{same:u,other:h}=Cde(t,e,a,i);c|=u&&r.length,d=d||h,l.fullSize||r.push(a)}return c&&wf(r,t,e,i)||d}function vy(n,t,e,i,r){n.top=e,n.left=t,n.right=t+i,n.bottom=e+r,n.width=i,n.height=r}function hz(n,t,e,i){const r=e.padding;let{x:s,y:o}=t;for(const a of n){const l=a.box,c=i[a.stack]||{count:1,placed:0,weight:1},d=a.stackWeight/c.weight||1;if(a.horizontal){const u=t.w*d,h=c.size||l.height;Ls(c.start)&&(o=c.start),l.fullSize?vy(l,r.left,o,e.outerWidth-r.right-r.left,h):vy(l,t.left+c.placed,o,u,h),c.start=o,c.placed+=u,o=l.bottom}else{const u=t.h*d,h=c.size||l.width;Ls(c.start)&&(s=c.start),l.fullSize?vy(l,s,r.top,h,e.outerHeight-r.bottom-r.top):vy(l,s,t.top+c.placed,h,u),c.start=s,c.placed+=u,s=l.right}}t.x=s,t.y=o}At.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}});var ur={addBox(n,t){n.boxes||(n.boxes=[]),t.fullSize=t.fullSize||!1,t.position=t.position||"top",t.weight=t.weight||0,t._layers=t._layers||function(){return[{z:0,draw(e){t.draw(e)}}]},n.boxes.push(t)},removeBox(n,t){const e=n.boxes?n.boxes.indexOf(t):-1;-1!==e&&n.boxes.splice(e,1)},configure(n,t,e){t.fullSize=e.fullSize,t.position=e.position,t.weight=e.weight},update(n,t,e,i){if(!n)return;const r=dr(n.options.layout.padding),s=Math.max(t-r.width,0),o=Math.max(e-r.height,0),a=function wde(n){const t=function yde(n){const t=[];let e,i,r,s,o,a;for(e=0,i=(n||[]).length;e<i;++e)r=n[e],({position:s,options:{stack:o,stackWeight:a=1}}=r),t.push({index:e,box:r,pos:s,horizontal:r.isHorizontal(),weight:r.weight,stack:o&&s+o,stackWeight:a});return t}(n),e=xf(t.filter(c=>c.box.fullSize),!0),i=xf(vf(t,"left"),!0),r=xf(vf(t,"right")),s=xf(vf(t,"top"),!0),o=xf(vf(t,"bottom")),a=cz(t,"x"),l=cz(t,"y");return{fullSize:e,leftAndTop:i.concat(s),rightAndBottom:r.concat(l).concat(o).concat(a),chartArea:vf(t,"chartArea"),vertical:i.concat(r).concat(l),horizontal:s.concat(o).concat(a)}}(n.boxes),l=a.vertical,c=a.horizontal;en(n.boxes,m=>{"function"==typeof m.beforeLayout&&m.beforeLayout()});const d=l.reduce((m,g)=>g.box.options&&!1===g.box.options.display?m:m+1,0)||1,u=Object.freeze({outerWidth:t,outerHeight:e,padding:r,availableWidth:s,availableHeight:o,vBoxMaxWidth:s/2/d,hBoxMaxHeight:o/2}),h=Object.assign({},r);uz(h,dr(i));const p=Object.assign({maxPadding:h,w:s,h:o,x:r.left,y:r.top},r),f=function xde(n,t){const e=function vde(n){const t={};for(const e of n){const{stack:i,pos:r,stackWeight:s}=e;if(!i||!lz.includes(r))continue;const o=t[i]||(t[i]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=s}return t}(n),{vBoxMaxWidth:i,hBoxMaxHeight:r}=t;let s,o,a;for(s=0,o=n.length;s<o;++s){a=n[s];const{fullSize:l}=a.box,c=e[a.stack],d=c&&a.stackWeight/c.weight;a.horizontal?(a.width=d?d*i:l&&t.availableWidth,a.height=r):(a.width=i,a.height=d?d*r:l&&t.availableHeight)}return e}(l.concat(c),u);wf(a.fullSize,p,u,f),wf(l,p,u,f),wf(c,p,u,f)&&wf(l,p,u,f),function Dde(n){const t=n.maxPadding;function e(i){const r=Math.max(t[i]-n[i],0);return n[i]+=r,r}n.y+=e("top"),n.x+=e("left"),e("right"),e("bottom")}(p),hz(a.leftAndTop,p,u,f),p.x+=p.w,p.y+=p.h,hz(a.rightAndBottom,p,u,f),n.chartArea={left:p.left,top:p.top,right:p.left+p.w,bottom:p.top+p.h,height:p.h,width:p.w},en(a.chartArea,m=>{const g=m.box;Object.assign(g,n.chartArea),g.update(p.w,p.h,{left:0,top:0,right:0,bottom:0})})}};class pz{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,i){}removeEventListener(t,e,i){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,i,r){return e=Math.max(0,e||t.width),i=i||t.height,{width:e,height:Math.max(0,r?Math.floor(e/r):i)}}isAttached(t){return!0}updateConfig(t){}}class kde extends pz{acquireContext(t){return t&&t.getContext&&t.getContext("2d")||null}updateConfig(t){t.options.animation=!1}}const xy="$chartjs",Ede={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},fz=n=>null===n||""===n,mz=!!nce&&{passive:!0};function Ade(n,t,e){n.canvas.removeEventListener(t,e,mz)}function wy(n,t){for(const e of n)if(e===t||e.contains(t))return!0}function Nde(n,t,e){const i=n.canvas,r=new MutationObserver(s=>{let o=!1;for(const a of s)o=o||wy(a.addedNodes,i),o=o&&!wy(a.removedNodes,i);o&&e()});return r.observe(document,{childList:!0,subtree:!0}),r}function Rde(n,t,e){const i=n.canvas,r=new MutationObserver(s=>{let o=!1;for(const a of s)o=o||wy(a.removedNodes,i),o=o&&!wy(a.addedNodes,i);o&&e()});return r.observe(document,{childList:!0,subtree:!0}),r}const Cf=new Map;let gz=0;function _z(){const n=window.devicePixelRatio;n!==gz&&(gz=n,Cf.forEach((t,e)=>{e.currentDevicePixelRatio!==n&&t()}))}function Pde(n,t,e){const i=n.canvas,r=i&&$k(i);if(!r)return;const s=sB((a,l)=>{const c=r.clientWidth;e(a,l),c<r.clientWidth&&e()},window),o=new ResizeObserver(a=>{const l=a[0],c=l.contentRect.width,d=l.contentRect.height;0===c&&0===d||s(c,d)});return o.observe(r),function Ode(n,t){Cf.size||window.addEventListener("resize",_z),Cf.set(n,t)}(n,s),o}function Wk(n,t,e){e&&e.disconnect(),"resize"===t&&function Fde(n){Cf.delete(n),Cf.size||window.removeEventListener("resize",_z)}(n)}function Lde(n,t,e){const i=n.canvas,r=sB(s=>{null!==n.ctx&&e(function Mde(n,t){const e=Ede[n.type]||n.type,{x:i,y:r}=Bc(n,t);return{type:e,chart:t,native:n,x:void 0!==i?i:null,y:void 0!==r?r:null}}(s,n))},n,s=>{const o=s[0];return[o,o.offsetX,o.offsetY]});return function Tde(n,t,e){n.addEventListener(t,e,mz)}(i,t,r),r}class $de extends pz{acquireContext(t,e){const i=t&&t.getContext&&t.getContext("2d");return i&&i.canvas===t?(function Ide(n,t){const e=n.style,i=n.getAttribute("height"),r=n.getAttribute("width");if(n[xy]={initial:{height:i,width:r,style:{display:e.display,height:e.height,width:e.width}}},e.display=e.display||"block",e.boxSizing=e.boxSizing||"border-box",fz(r)){const s=RB(n,"width");void 0!==s&&(n.width=s)}if(fz(i))if(""===n.style.height)n.height=n.width/(t||2);else{const s=RB(n,"height");void 0!==s&&(n.height=s)}}(t,e),i):null}releaseContext(t){const e=t.canvas;if(!e[xy])return!1;const i=e[xy].initial;["height","width"].forEach(s=>{const o=i[s];Vt(o)?e.removeAttribute(s):e.setAttribute(s,o)});const r=i.style||{};return Object.keys(r).forEach(s=>{e.style[s]=r[s]}),e.width=e.width,delete e[xy],!0}addEventListener(t,e,i){this.removeEventListener(t,e),(t.$proxies||(t.$proxies={}))[e]=({attach:Nde,detach:Rde,resize:Pde}[e]||Lde)(t,e,i)}removeEventListener(t,e){const i=t.$proxies||(t.$proxies={}),r=i[e];r&&(({attach:Wk,detach:Wk,resize:Wk}[e]||Ade)(t,e,r),i[e]=void 0)}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,i,r){return function tce(n,t,e,i){const r=gy(n),s=Vc(r,"margin"),o=my(r.maxWidth,n,"clientWidth")||sy,a=my(r.maxHeight,n,"clientHeight")||sy,l=function ece(n,t,e){let i,r;if(void 0===t||void 0===e){const s=$k(n);if(s){const o=s.getBoundingClientRect(),a=gy(s),l=Vc(a,"border","width"),c=Vc(a,"padding");t=o.width-c.width-l.width,e=o.height-c.height-l.height,i=my(a.maxWidth,s,"clientWidth"),r=my(a.maxHeight,s,"clientHeight")}else t=n.clientWidth,e=n.clientHeight}return{width:t,height:e,maxWidth:i||sy,maxHeight:r||sy}}(n,t,e);let{width:c,height:d}=l;if("content-box"===r.boxSizing){const u=Vc(r,"border","width"),h=Vc(r,"padding");c-=h.width+u.width,d-=h.height+u.height}return c=Math.max(0,c-s.width),d=Math.max(0,i?Math.floor(c/i):d-s.height),c=Vk(Math.min(c,o,l.maxWidth)),d=Vk(Math.min(d,a,l.maxHeight)),c&&!d&&(d=Vk(c/2)),{width:c,height:d}}(t,e,i,r)}isAttached(t){const e=$k(t);return!(!e||!e.isConnected)}}class Bde{constructor(){this._init=[]}notify(t,e,i,r){"beforeInit"===e&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install"));const s=r?this._descriptors(t).filter(r):this._descriptors(t),o=this._notify(s,t,e,i);return"afterDestroy"===e&&(this._notify(s,t,"stop"),this._notify(this._init,t,"uninstall")),o}_notify(t,e,i,r){r=r||{};for(const s of t){const o=s.plugin;if(!1===yn(o[i],[e,r,s.options],o)&&r.cancelable)return!1}return!0}invalidate(){Vt(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const i=t&&t.config,r=ft(i.options&&i.options.plugins,{}),s=function zde(n){const t={},e=[],i=Object.keys(Wo.plugins.items);for(let s=0;s<i.length;s++)e.push(Wo.getPlugin(i[s]));const r=n.plugins||[];for(let s=0;s<r.length;s++){const o=r[s];-1===e.indexOf(o)&&(e.push(o),t[o.id]=!0)}return{plugins:e,localIds:t}}(i);return!1!==r||e?function Hde(n,{plugins:t,localIds:e},i,r){const s=[],o=n.getContext();for(const a of t){const l=a.id,c=Ude(i[l],r);null!==c&&s.push({plugin:a,options:jde(n.config,{plugin:a,local:e[l]},c,o)})}return s}(t,s,r,e):[]}_notifyStateChanges(t){const e=this._oldCache||[],i=this._cache,r=(s,o)=>s.filter(a=>!o.some(l=>a.plugin.id===l.plugin.id));this._notify(r(e,i),t,"stop"),this._notify(r(i,e),t,"start")}}function Ude(n,t){return t||!1!==n?!0===n?{}:n:null}function jde(n,{plugin:t,local:e},i,r){const s=n.pluginScopeKeys(t),o=n.getOptionScopes(i,s);return e&&t.defaults&&o.push(t.defaults),n.createResolver(o,r,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function Gk(n,t){return((t.datasets||{})[n]||{}).indexAxis||t.indexAxis||(At.datasets[n]||{}).indexAxis||"x"}function qk(n,t){return"x"===n||"y"===n?n:t.axis||function qde(n){return"top"===n||"bottom"===n?"x":"left"===n||"right"===n?"y":void 0}(t.position)||n.charAt(0).toLowerCase()}function bz(n){const t=n.options||(n.options={});t.plugins=ft(t.plugins,{}),t.scales=function Yde(n,t){const e=Fc[n.type]||{scales:{}},i=t.scales||{},r=Gk(n.type,t),s=Object.create(null),o=Object.create(null);return Object.keys(i).forEach(a=>{const l=i[a];if(!Tt(l))return console.error(`Invalid scale configuration for scale: ${a}`);if(l._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${a}`);const c=qk(a,l),d=function Gde(n,t){return n===t?"_index_":"_value_"}(c,r),u=e.scales||{};s[c]=s[c]||a,o[a]=rf(Object.create(null),[{axis:c},l,u[c],u[d]])}),n.data.datasets.forEach(a=>{const l=a.type||n.type,c=a.indexAxis||Gk(l,t),u=(Fc[l]||{}).scales||{};Object.keys(u).forEach(h=>{const p=function Wde(n,t){let e=n;return"_index_"===n?e=t:"_value_"===n&&(e="x"===t?"y":"x"),e}(h,c),f=a[p+"AxisID"]||s[p]||p;o[f]=o[f]||Object.create(null),rf(o[f],[{axis:p},i[f],u[h]])})}),Object.keys(o).forEach(a=>{const l=o[a];rf(l,[At.scales[l.type],At.scale])}),o}(n,t)}function yz(n){return(n=n||{}).datasets=n.datasets||[],n.labels=n.labels||[],n}const vz=new Map,xz=new Set;function Cy(n,t){let e=vz.get(n);return e||(e=t(),vz.set(n,e),xz.add(e)),e}const Df=(n,t,e)=>{const i=pl(t,e);void 0!==i&&n.add(i)};class Xde{constructor(t){this._config=function Kde(n){return(n=n||{}).data=yz(n.data),bz(n),n}(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=yz(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),bz(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return Cy(t,()=>[[`datasets.${t}`,""]])}datasetAnimationScopeKeys(t,e){return Cy(`${t}.transition.${e}`,()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]])}datasetElementScopeKeys(t,e){return Cy(`${t}-${e}`,()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]])}pluginScopeKeys(t){const e=t.id;return Cy(`${this.type}-plugin-${e}`,()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]])}_cachedScopes(t,e){const i=this._scopeCache;let r=i.get(t);return(!r||e)&&(r=new Map,i.set(t,r)),r}getOptionScopes(t,e,i){const{options:r,type:s}=this,o=this._cachedScopes(t,i),a=o.get(e);if(a)return a;const l=new Set;e.forEach(d=>{t&&(l.add(t),d.forEach(u=>Df(l,t,u))),d.forEach(u=>Df(l,r,u)),d.forEach(u=>Df(l,Fc[s]||{},u)),d.forEach(u=>Df(l,At,u)),d.forEach(u=>Df(l,Mk,u))});const c=Array.from(l);return 0===c.length&&c.push(Object.create(null)),xz.has(e)&&o.set(e,c),c}chartOptionScopes(){const{options:t,type:e}=this;return[t,Fc[e]||{},At.datasets[e]||{},{type:e},At,Mk]}resolveNamedOptions(t,e,i,r=[""]){const s={$shared:!0},{resolver:o,subPrefixes:a}=wz(this._resolverCache,t,r);let l=o;(function Qde(n,t){const{isScriptable:e,isIndexable:i}=CB(n);for(const r of t){const s=e(r),o=i(r),a=(o||s)&&n[r];if(s&&(fl(a)||Zde(a))||o&&bn(a))return!0}return!1})(o,e)&&(s.$shared=!1,l=Tu(o,i=fl(i)?i():i,this.createResolver(t,i,a)));for(const c of e)s[c]=l[c];return s}createResolver(t,e,i=[""],r){const{resolver:s}=wz(this._resolverCache,t,i);return Tt(e)?Tu(s,e,void 0,r):s}}function wz(n,t,e){let i=n.get(t);i||(i=new Map,n.set(t,i));const r=e.join();let s=i.get(r);return s||(s={resolver:Fk(t,e),subPrefixes:e.filter(a=>!a.toLowerCase().includes("hover"))},i.set(r,s)),s}const Zde=n=>Tt(n)&&Object.getOwnPropertyNames(n).reduce((t,e)=>t||fl(n[e]),!1),eue=["top","bottom","left","right","chartArea"];function Cz(n,t){return"top"===n||"bottom"===n||-1===eue.indexOf(n)&&"x"===t}function Dz(n,t){return function(e,i){return e[n]===i[n]?e[t]-i[t]:e[n]-i[n]}}function Sz(n){const t=n.chart,e=t.options.animation;t.notifyPlugins("afterRender"),yn(e&&e.onComplete,[n],t)}function tue(n){const t=n.chart,e=t.options.animation;yn(e&&e.onProgress,[n],t)}function kz(n){return MB()&&"string"==typeof n?n=document.getElementById(n):n&&n.length&&(n=n[0]),n&&n.canvas&&(n=n.canvas),n}const Dy={},Ez=n=>{const t=kz(n);return Object.values(Dy).filter(e=>e.canvas===t).pop()};function nue(n,t,e){const i=Object.keys(n);for(const r of i){const s=+r;if(s>=t){const o=n[r];delete n[r],(e>0||s>t)&&(n[s+e]=o)}}}class Sf{constructor(t,e){const i=this.config=new Xde(e),r=kz(t),s=Ez(r);if(s)throw new Error("Canvas is already in use. Chart with ID '"+s.id+"' must be destroyed before the canvas with ID '"+s.canvas.id+"' can be reused.");const o=i.createResolver(i.chartOptionScopes(),this.getContext());this.platform=new(i.platform||function Vde(n){return!MB()||typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas?kde:$de}(r)),this.platform.updateConfig(i);const a=this.platform.acquireContext(r,o.aspectRatio),l=a&&a.canvas,c=l&&l.height,d=l&&l.width;this.id=Pae(),this.ctx=a,this.canvas=l,this.width=d,this.height=c,this._options=o,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new Bde,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=function Qae(n,t){let e;return function(...i){return t?(clearTimeout(e),e=setTimeout(n,t,i)):n.apply(this,i),t}}(u=>this.update(u),o.resizeDelay||0),this._dataChanges=[],Dy[this.id]=this,a&&l?(Oa.listen(this,"complete",Sz),Oa.listen(this,"progress",tue),this._initialize(),this.attached&&this.update()):console.error("Failed to create chart: can't acquire context from the given item")}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:i,height:r,_aspectRatio:s}=this;return Vt(t)?e&&s?s:r?i/r:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():NB(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return vB(this.canvas,this.ctx),this}stop(){return Oa.stop(this),this}resize(t,e){Oa.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const i=this.options,o=this.platform.getMaximumSize(this.canvas,t,e,i.maintainAspectRatio&&this.aspectRatio),a=i.devicePixelRatio||this.platform.getDevicePixelRatio(),l=this.width?"resize":"attach";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,NB(this,a,!0)&&(this.notifyPlugins("resize",{size:o}),yn(i.onResize,[this,o],this),this.attached&&this._doResize(l)&&this.render())}ensureScalesHaveIDs(){en(this.options.scales||{},(i,r)=>{i.id=r})}buildOrUpdateScales(){const t=this.options,e=t.scales,i=this.scales,r=Object.keys(i).reduce((o,a)=>(o[a]=!1,o),{});let s=[];e&&(s=s.concat(Object.keys(e).map(o=>{const a=e[o],l=qk(o,a),c="r"===l,d="x"===l;return{options:a,dposition:c?"chartArea":d?"bottom":"left",dtype:c?"radialLinear":d?"category":"linear"}}))),en(s,o=>{const a=o.options,l=a.id,c=qk(l,a),d=ft(a.type,o.dtype);(void 0===a.position||Cz(a.position,c)!==Cz(o.dposition))&&(a.position=o.dposition),r[l]=!0;let u=null;l in i&&i[l].type===d?u=i[l]:(u=new(Wo.getScale(d))({id:l,type:d,ctx:this.ctx,chart:this}),i[u.id]=u),u.init(a,t)}),en(r,(o,a)=>{o||delete i[a]}),en(i,o=>{ur.configure(this,o,o.options),ur.addBox(this,o)})}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,i=t.length;if(t.sort((r,s)=>r.index-s.index),i>e){for(let r=e;r<i;++r)this._destroyDatasetMeta(r);t.splice(e,i-e)}this._sortedMetasets=t.slice(0).sort(Dz("order","index"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach((i,r)=>{0===e.filter(s=>s===i._dataset).length&&this._destroyDatasetMeta(r)})}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let i,r;for(this._removeUnreferencedMetasets(),i=0,r=e.length;i<r;i++){const s=e[i];let o=this.getDatasetMeta(i);const a=s.type||this.config.type;if(o.type&&o.type!==a&&(this._destroyDatasetMeta(i),o=this.getDatasetMeta(i)),o.type=a,o.indexAxis=s.indexAxis||Gk(a,this.options),o.order=s.order||0,o.index=i,o.label=""+s.label,o.visible=this.isDatasetVisible(i),o.controller)o.controller.updateIndex(i),o.controller.linkScales();else{const l=Wo.getController(a),{datasetElementType:c,dataElementType:d}=At.datasets[a];Object.assign(l.prototype,{dataElementType:Wo.getElement(d),datasetElementType:c&&Wo.getElement(c)}),o.controller=new l(this,i),t.push(o.controller)}}return this._updateMetasets(),t}_resetElements(){en(this.data.datasets,(t,e)=>{this.getDatasetMeta(e).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(t){const e=this.config;e.update();const i=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),r=this._animationsDisabled=!i.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0}))return;const s=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let o=0;for(let c=0,d=this.data.datasets.length;c<d;c++){const{controller:u}=this.getDatasetMeta(c),h=!r&&-1===s.indexOf(u);u.buildOrUpdateElements(h),o=Math.max(+u.getMaxOverflow(),o)}o=this._minPadding=i.layout.autoPadding?o:0,this._updateLayout(o),r||en(s,c=>{c.reset()}),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(Dz("z","_idx"));const{_active:a,_lastEvent:l}=this;l?this._eventHandler(l,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){en(this.scales,t=>{ur.removeBox(this,t)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),i=new Set(t.events);(!KV(e,i)||!!this._responsiveListeners!==t.responsive)&&(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:i,start:r,count:s}of e)nue(t,r,"_removeElements"===i?-s:s)}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,i=s=>new Set(t.filter(o=>o[0]===s).map((o,a)=>a+","+o.splice(1).join(","))),r=i(0);for(let s=1;s<e;s++)if(!KV(r,i(s)))return;return Array.from(r).map(s=>s.split(",")).map(s=>({method:s[1],start:+s[2],count:+s[3]}))}_updateLayout(t){if(!1===this.notifyPlugins("beforeLayout",{cancelable:!0}))return;ur.update(this,this.width,this.height,t);const e=this.chartArea,i=e.width<=0||e.height<=0;this._layers=[],en(this.boxes,r=>{i&&"chartArea"===r.position||(r.configure&&r.configure(),this._layers.push(...r._layers()))},this),this._layers.forEach((r,s)=>{r._idx=s}),this.notifyPlugins("afterLayout")}_updateDatasets(t){if(!1!==this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})){for(let e=0,i=this.data.datasets.length;e<i;++e)this.getDatasetMeta(e).controller.configure();for(let e=0,i=this.data.datasets.length;e<i;++e)this._updateDataset(e,fl(t)?t({datasetIndex:e}):t);this.notifyPlugins("afterDatasetsUpdate",{mode:t})}}_updateDataset(t,e){const i=this.getDatasetMeta(t),r={meta:i,index:t,mode:e,cancelable:!0};!1!==this.notifyPlugins("beforeDatasetUpdate",r)&&(i.controller._update(e),r.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",r))}render(){!1!==this.notifyPlugins("beforeRender",{cancelable:!0})&&(Oa.has(this)?this.attached&&!Oa.running(this)&&Oa.start(this):(this.draw(),Sz({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:i,height:r}=this._resizeBeforeDraw;this._resize(i,r),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0||!1===this.notifyPlugins("beforeDraw",{cancelable:!0}))return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,i=[];let r,s;for(r=0,s=e.length;r<s;++r){const o=e[r];(!t||o.visible)&&i.push(o)}return i}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(!1===this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0}))return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(t){const e=this.ctx,i=t._clip,r=!i.disabled,s=this.chartArea,o={meta:t,index:t.index,cancelable:!0};!1!==this.notifyPlugins("beforeDatasetDraw",o)&&(r&&hy(e,{left:!1===i.left?0:s.left-i.left,right:!1===i.right?this.width:s.right+i.right,top:!1===i.top?0:s.top-i.top,bottom:!1===i.bottom?this.height:s.bottom+i.bottom}),t.controller.draw(),r&&py(e),o.cancelable=!1,this.notifyPlugins("afterDatasetDraw",o))}isPointInArea(t){return pf(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,i,r){const s=bde.modes[e];return"function"==typeof s?s(this,t,i,r):[]}getDatasetMeta(t){const e=this.data.datasets[t],i=this._metasets;let r=i.filter(s=>s&&s._dataset===e).pop();return r||(r={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},i.push(r)),r}getContext(){return this.$context||(this.$context=_l(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const i=this.getDatasetMeta(t);return"boolean"==typeof i.hidden?!i.hidden:!e.hidden}setDatasetVisibility(t,e){this.getDatasetMeta(t).hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,i){const r=i?"show":"hide",s=this.getDatasetMeta(t),o=s.controller._resolveAnimations(void 0,r);Ls(e)?(s.data[e].hidden=!i,this.update()):(this.setDatasetVisibility(t,i),o.update(s,{visible:i}),this.update(a=>a.datasetIndex===t?r:void 0))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),Oa.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),vB(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),this.notifyPlugins("destroy"),delete Dy[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,i=(s,o)=>{e.addEventListener(this,s,o),t[s]=o},r=(s,o,a)=>{s.offsetX=o,s.offsetY=a,this._eventHandler(s)};en(this.options.events,s=>i(s,r))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,i=(l,c)=>{e.addEventListener(this,l,c),t[l]=c},r=(l,c)=>{t[l]&&(e.removeEventListener(this,l,c),delete t[l])},s=(l,c)=>{this.canvas&&this.resize(l,c)};let o;const a=()=>{r("attach",a),this.attached=!0,this.resize(),i("resize",s),i("detach",o)};o=()=>{this.attached=!1,r("resize",s),this._stop(),this._resize(0,0),i("attach",a)},e.isAttached(this.canvas)?a():o()}unbindEvents(){en(this._listeners,(t,e)=>{this.platform.removeEventListener(this,e,t)}),this._listeners={},en(this._responsiveListeners,(t,e)=>{this.platform.removeEventListener(this,e,t)}),this._responsiveListeners=void 0}updateHoverStyle(t,e,i){const r=i?"set":"remove";let s,o,a,l;for("dataset"===e&&(s=this.getDatasetMeta(t[0].datasetIndex),s.controller["_"+r+"DatasetHoverStyle"]()),a=0,l=t.length;a<l;++a){o=t[a];const c=o&&this.getDatasetMeta(o.datasetIndex).controller;c&&c[r+"HoverStyle"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],i=t.map(({datasetIndex:s,index:o})=>{const a=this.getDatasetMeta(s);if(!a)throw new Error("No dataset found at index "+s);return{datasetIndex:s,element:a.data[o],index:o}});!iy(i,e)&&(this._active=i,this._lastEvent=null,this._updateHoverStyles(i,e))}notifyPlugins(t,e,i){return this._plugins.notify(this,t,e,i)}_updateHoverStyles(t,e,i){const r=this.options.hover,s=(l,c)=>l.filter(d=>!c.some(u=>d.datasetIndex===u.datasetIndex&&d.index===u.index)),o=s(e,t),a=i?t:s(t,e);o.length&&this.updateHoverStyle(o,r.mode,!1),a.length&&r.mode&&this.updateHoverStyle(a,r.mode,!0)}_eventHandler(t,e){const i={event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},r=o=>(o.options.events||this.options.events).includes(t.native.type);if(!1===this.notifyPlugins("beforeEvent",i,r))return;const s=this._handleEvent(t,e,i.inChartArea);return i.cancelable=!1,this.notifyPlugins("afterEvent",i,r),(s||i.changed)&&this.render(),this}_handleEvent(t,e,i){const{_active:r=[],options:s}=this,a=this._getActiveElements(t,r,i,e),l=function Uae(n){return"mouseup"===n.type||"click"===n.type||"contextmenu"===n.type}(t),c=function iue(n,t,e,i){return e&&"mouseout"!==n.type?i?t:n:null}(t,this._lastEvent,i,l);i&&(this._lastEvent=null,yn(s.onHover,[t,a,this],this),l&&yn(s.onClick,[t,a,this],this));const d=!iy(a,r);return(d||e)&&(this._active=a,this._updateHoverStyles(a,r,e)),this._lastEvent=c,d}_getActiveElements(t,e,i,r){if("mouseout"===t.type)return[];if(!i)return e;const s=this.options.hover;return this.getElementsAtEventForMode(t,s.mode,s,r)}}const Iz=()=>en(Sf.instances,n=>n._plugins.invalidate()),bl=!0;function Tz(n,t,e){const{startAngle:i,pixelMargin:r,x:s,y:o,outerRadius:a,innerRadius:l}=t;let c=r/a;n.beginPath(),n.arc(s,o,a,i-c,e+c),l>r?(c=r/l,n.arc(s,o,l,e+c,i-c,!0)):n.arc(s,o,r,e+Gn,i-Gn),n.closePath(),n.clip()}function Nu(n,t,e,i){return{x:e+n*Math.cos(t),y:i+n*Math.sin(t)}}function Yk(n,t,e,i,r,s){const{x:o,y:a,startAngle:l,pixelMargin:c,innerRadius:d}=t,u=Math.max(t.outerRadius+i+e-c,0),h=d>0?d+i+e+c:0;let p=0;const f=r-l;if(i){const F=((d>0?d-i:0)+(u>0?u-i:0))/2;p=(f-(0!==F?f*F/(F+i):f))/2}const g=(f-Math.max(.001,f*u-e/Mn)/u)/2,_=l+g+p,b=r-g-p,{outerStart:y,outerEnd:v,innerStart:x,innerEnd:w}=function sue(n,t,e,i){const r=function rue(n){return Ok(n,["outerStart","outerEnd","innerStart","innerEnd"])}(n.options.borderRadius),s=(e-t)/2,o=Math.min(s,i*t/2),a=l=>{const c=(e-Math.min(s,l))*i/2;return Bi(l,0,Math.min(s,c))};return{outerStart:a(r.outerStart),outerEnd:a(r.outerEnd),innerStart:Bi(r.innerStart,0,o),innerEnd:Bi(r.innerEnd,0,o)}}(t,h,u,b-_),C=u-y,D=u-v,k=_+y/C,I=b-v/D,A=h+x,$=h+w,H=_+x/A,W=b-w/$;if(n.beginPath(),s){if(n.arc(o,a,u,k,I),v>0){const F=Nu(D,I,o,a);n.arc(F.x,F.y,v,I,b+Gn)}const z=Nu($,b,o,a);if(n.lineTo(z.x,z.y),w>0){const F=Nu($,W,o,a);n.arc(F.x,F.y,w,b+Gn,W+Math.PI)}if(n.arc(o,a,h,b-w/h,_+x/h,!0),x>0){const F=Nu(A,H,o,a);n.arc(F.x,F.y,x,H+Math.PI,_-Gn)}const M=Nu(C,_,o,a);if(n.lineTo(M.x,M.y),y>0){const F=Nu(C,k,o,a);n.arc(F.x,F.y,y,_-Gn,k)}}else{n.moveTo(o,a);const z=Math.cos(k)*u+o,M=Math.sin(k)*u+a;n.lineTo(z,M);const F=Math.cos(I)*u+o,L=Math.sin(I)*u+a;n.lineTo(F,L)}n.closePath()}Object.defineProperties(Sf,{defaults:{enumerable:bl,value:At},instances:{enumerable:bl,value:Dy},overrides:{enumerable:bl,value:Fc},registry:{enumerable:bl,value:Wo},version:{enumerable:bl,value:"3.9.1"},getChart:{enumerable:bl,value:Ez},register:{enumerable:bl,value:(...n)=>{Wo.add(...n),Iz()}},unregister:{enumerable:bl,value:(...n)=>{Wo.remove(...n),Iz()}}});class Sy extends go{constructor(t){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&&Object.assign(this,t)}inRange(t,e,i){const r=this.getProps(["x","y"],i),{angle:s,distance:o}=eB(r,{x:t,y:e}),{startAngle:a,endAngle:l,innerRadius:c,outerRadius:d,circumference:u}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],i),h=this.options.spacing/2,f=ft(u,l-a)>=sn||lf(s,a,l),m=Ma(o,c+h,d+h);return f&&m}getCenterPoint(t){const{x:e,y:i,startAngle:r,endAngle:s,innerRadius:o,outerRadius:a}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius","circumference"],t),{offset:l,spacing:c}=this.options,d=(r+s)/2,u=(o+a+c+l)/2;return{x:e+Math.cos(d)*u,y:i+Math.sin(d)*u}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:i}=this,r=(e.offset||0)/2,s=(e.spacing||0)/2,o=e.circular;if(this.pixelMargin="inner"===e.borderAlign?.33:0,this.fullCircles=i>sn?Math.floor(i/sn):0,0===i||this.innerRadius<0||this.outerRadius<0)return;t.save();let a=0;if(r){a=r/2;const c=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(c)*a,Math.sin(c)*a),this.circumference>=Mn&&(a=r)}t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor;const l=function oue(n,t,e,i,r){const{fullCircles:s,startAngle:o,circumference:a}=t;let l=t.endAngle;if(s){Yk(n,t,e,i,o+sn,r);for(let c=0;c<s;++c)n.fill();isNaN(a)||(l=o+a%sn,a%sn==0&&(l+=sn))}return Yk(n,t,e,i,l,r),n.fill(),l}(t,this,a,s,o);(function lue(n,t,e,i,r,s){const{options:o}=t,{borderWidth:a,borderJoinStyle:l}=o,c="inner"===o.borderAlign;a&&(c?(n.lineWidth=2*a,n.lineJoin=l||"round"):(n.lineWidth=a,n.lineJoin=l||"bevel"),t.fullCircles&&function aue(n,t,e){const{x:i,y:r,startAngle:s,pixelMargin:o,fullCircles:a}=t,l=Math.max(t.outerRadius-o,0),c=t.innerRadius+o;let d;for(e&&Tz(n,t,s+sn),n.beginPath(),n.arc(i,r,c,s+sn,s,!0),d=0;d<a;++d)n.stroke();for(n.beginPath(),n.arc(i,r,l,s,s+sn),d=0;d<a;++d)n.stroke()}(n,t,c),c&&Tz(n,t,r),Yk(n,t,e,i,r,s),n.stroke())})(t,this,a,s,l,o),t.restore()}}function Az(n,t,e=t){n.lineCap=ft(e.borderCapStyle,t.borderCapStyle),n.setLineDash(ft(e.borderDash,t.borderDash)),n.lineDashOffset=ft(e.borderDashOffset,t.borderDashOffset),n.lineJoin=ft(e.borderJoinStyle,t.borderJoinStyle),n.lineWidth=ft(e.borderWidth,t.borderWidth),n.strokeStyle=ft(e.borderColor,t.borderColor)}function cue(n,t,e){n.lineTo(e.x,e.y)}function Mz(n,t,e={}){const i=n.length,{start:r=0,end:s=i-1}=e,{start:o,end:a}=t,l=Math.max(r,o),c=Math.min(s,a);return{count:i,start:l,loop:t.loop,ilen:c<l&&!(r<o&&s<o||r>a&&s>a)?i+c-l:c-l}}function uue(n,t,e,i){const{points:r,options:s}=t,{count:o,start:a,loop:l,ilen:c}=Mz(r,e,i),d=function due(n){return n.stepped?Sle:n.tension||"monotone"===n.cubicInterpolationMode?kle:cue}(s);let p,f,m,{move:u=!0,reverse:h}=i||{};for(p=0;p<=c;++p)f=r[(a+(h?c-p:p))%o],!f.skip&&(u?(n.moveTo(f.x,f.y),u=!1):d(n,m,f,h,s.stepped),m=f);return l&&(f=r[(a+(h?c:0))%o],d(n,m,f,h,s.stepped)),!!l}function hue(n,t,e,i){const r=t.points,{count:s,start:o,ilen:a}=Mz(r,e,i),{move:l=!0,reverse:c}=i||{};let h,p,f,m,g,_,d=0,u=0;const b=v=>(o+(c?a-v:v))%s,y=()=>{m!==g&&(n.lineTo(d,g),n.lineTo(d,m),n.lineTo(d,_))};for(l&&(p=r[b(0)],n.moveTo(p.x,p.y)),h=0;h<=a;++h){if(p=r[b(h)],p.skip)continue;const v=p.x,x=p.y,w=0|v;w===f?(x<m?m=x:x>g&&(g=x),d=(u*d+v)/++u):(y(),n.lineTo(v,x),f=w,u=0,m=g=x),_=x}y()}function Kk(n){const t=n.options;return n._decimated||n._loop||t.tension||"monotone"===t.cubicInterpolationMode||t.stepped||t.borderDash&&t.borderDash.length?uue:hue}Sy.id="arc",Sy.defaults={borderAlign:"center",borderColor:"#fff",borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0},Sy.defaultRoutes={backgroundColor:"backgroundColor"};const gue="function"==typeof Path2D;let ky=(()=>{class n extends go{constructor(e){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,e&&Object.assign(this,e)}updateControlPoints(e,i){const r=this.options;!r.tension&&"monotone"!==r.cubicInterpolationMode||r.stepped||this._pointsUpdated||(Kle(this._points,r,e,r.spanGaps?this._loop:this._fullLoop,i),this._pointsUpdated=!0)}set points(e){this._points=e,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=function uce(n,t){const e=n.points,i=n.options.spanGaps,r=e.length;if(!r)return[];const s=!!n._loop,{start:o,end:a}=function cce(n,t,e,i){let r=0,s=t-1;if(e&&!i)for(;r<t&&!n[r].skip;)r++;for(;r<t&&n[r].skip;)r++;for(r%=t,e&&(s+=r);s>r&&n[s%t].skip;)s--;return s%=t,{start:r,end:s}}(e,r,s,i);return function zB(n,t,e,i){return i&&i.setContext&&e?function hce(n,t,e,i){const r=n._chart.getContext(),s=UB(n.options),{_datasetIndex:o,options:{spanGaps:a}}=n,l=e.length,c=[];let d=s,u=t[0].start,h=u;function p(f,m,g,_){const b=a?-1:1;if(f!==m){for(f+=l;e[f%l].skip;)f-=b;for(;e[m%l].skip;)m+=b;f%l!=m%l&&(c.push({start:f%l,end:m%l,loop:g,style:_}),d=_,u=m%l)}}for(const f of t){u=a?u:f.start;let g,m=e[u%l];for(h=u+1;h<=f.end;h++){const _=e[h%l];g=UB(i.setContext(_l(r,{type:"segment",p0:m,p1:_,p0DataIndex:(h-1)%l,p1DataIndex:h%l,datasetIndex:o}))),pce(g,d)&&p(u,h-1,f.loop,d),m=_,d=g}u<h-1&&p(u,h-1,f.loop,d)}return c}(n,t,e,i):t}(n,!0===i?[{start:o,end:a,loop:s}]:function dce(n,t,e,i){const r=n.length,s=[];let l,o=t,a=n[t];for(l=t+1;l<=e;++l){const c=n[l%r];c.skip||c.stop?a.skip||(s.push({start:t%r,end:(l-1)%r,loop:i=!1}),t=o=c.stop?l:null):(o=l,a.skip&&(t=l)),a=c}return null!==o&&s.push({start:t%r,end:o%r,loop:i}),s}(e,o,a<o?a+r:a,!!n._fullLoop&&0===o&&a===r-1),e,t)}(this,this.options.segment))}first(){const e=this.segments;return e.length&&this.points[e[0].start]}last(){const e=this.segments,r=e.length;return r&&this.points[e[r-1].end]}interpolate(e,i){const r=this.options,s=e[i],o=this.points,a=BB(this,{property:i,start:s,end:s});if(!a.length)return;const l=[],c=function pue(n){return n.stepped?ice:n.tension||"monotone"===n.cubicInterpolationMode?rce:zc}(r);let d,u;for(d=0,u=a.length;d<u;++d){const{start:h,end:p}=a[d],f=o[h],m=o[p];if(f===m){l.push(f);continue}const _=c(f,m,Math.abs((s-f[i])/(m[i]-f[i])),r.stepped);_[i]=e[i],l.push(_)}return 1===l.length?l[0]:l}pathSegment(e,i,r){return Kk(this)(e,this,i,r)}path(e,i,r){const s=this.segments,o=Kk(this);let a=this._loop;i=i||0,r=r||this.points.length-i;for(const l of s)a&=o(e,this,l,{start:i,end:i+r-1});return!!a}draw(e,i,r,s){(this.points||[]).length&&(this.options||{}).borderWidth&&(e.save(),function _ue(n,t,e,i){gue&&!t.options.segment?function fue(n,t,e,i){let r=t._path;r||(r=t._path=new Path2D,t.path(r,e,i)&&r.closePath()),Az(n,t.options),n.stroke(r)}(n,t,e,i):function mue(n,t,e,i){const{segments:r,options:s}=t,o=Kk(t);for(const a of r)Az(n,s,a.style),n.beginPath(),o(n,t,a,{start:e,end:e+i-1})&&n.closePath(),n.stroke()}(n,t,e,i)}(e,this,r,s),e.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}return n.id="line",n.defaults={borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0},n.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"},n.descriptors={_scriptable:!0,_indexable:t=>"borderDash"!==t&&"fill"!==t},n})();function Nz(n,t,e,i){const r=n.options,{[e]:s}=n.getProps([e],i);return Math.abs(t-s)<r.radius+r.hitRadius}let bue=(()=>{class n extends go{constructor(e){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,e&&Object.assign(this,e)}inRange(e,i,r){const s=this.options,{x:o,y:a}=this.getProps(["x","y"],r);return Math.pow(e-o,2)+Math.pow(i-a,2)<Math.pow(s.hitRadius+s.radius,2)}inXRange(e,i){return Nz(this,e,"x",i)}inYRange(e,i){return Nz(this,e,"y",i)}getCenterPoint(e){const{x:i,y:r}=this.getProps(["x","y"],e);return{x:i,y:r}}size(e){let i=(e=e||this.options||{}).radius||0;return i=Math.max(i,i&&e.hoverRadius||0),2*(i+(i&&e.borderWidth||0))}draw(e,i){const r=this.options;this.skip||r.radius<.1||!pf(this,i,this.size(r)/2)||(e.strokeStyle=r.borderColor,e.lineWidth=r.borderWidth,e.fillStyle=r.backgroundColor,Rk(e,r,this.x,this.y))}getRange(){const e=this.options||{};return e.radius+e.hitRadius}}return n.id="point",n.defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0},n.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"},n})();function Rz(n,t){const{x:e,y:i,base:r,width:s,height:o}=n.getProps(["x","y","base","width","height"],t);let a,l,c,d,u;return n.horizontal?(u=o/2,a=Math.min(e,r),l=Math.max(e,r),c=i-u,d=i+u):(u=s/2,a=e-u,l=e+u,c=Math.min(i,r),d=Math.max(i,r)),{left:a,top:c,right:l,bottom:d}}function yl(n,t,e,i){return n?0:Bi(t,e,i)}function Xk(n,t,e,i){const r=null===t,s=null===e,a=n&&!(r&&s)&&Rz(n,i);return a&&(r||Ma(t,a.left,a.right))&&(s||Ma(e,a.top,a.bottom))}function Cue(n,t){n.rect(t.x,t.y,t.w,t.h)}function Zk(n,t,e={}){const i=n.x!==e.x?-t:0,r=n.y!==e.y?-t:0;return{x:n.x+i,y:n.y+r,w:n.w+((n.x+n.w!==e.x+e.w?t:0)-i),h:n.h+((n.y+n.h!==e.y+e.h?t:0)-r),radius:n.radius}}class Ey extends go{constructor(t){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:i,backgroundColor:r}}=this,{inner:s,outer:o}=function xue(n){const t=Rz(n),e=t.right-t.left,i=t.bottom-t.top,r=function yue(n,t,e){const r=n.borderSkipped,s=wB(n.options.borderWidth);return{t:yl(r.top,s.top,0,e),r:yl(r.right,s.right,0,t),b:yl(r.bottom,s.bottom,0,e),l:yl(r.left,s.left,0,t)}}(n,e/2,i/2),s=function vue(n,t,e){const{enableBorderRadius:i}=n.getProps(["enableBorderRadius"]),r=n.options.borderRadius,s=$c(r),o=Math.min(t,e),a=n.borderSkipped,l=i||Tt(r);return{topLeft:yl(!l||a.top||a.left,s.topLeft,0,o),topRight:yl(!l||a.top||a.right,s.topRight,0,o),bottomLeft:yl(!l||a.bottom||a.left,s.bottomLeft,0,o),bottomRight:yl(!l||a.bottom||a.right,s.bottomRight,0,o)}}(n,e/2,i/2);return{outer:{x:t.left,y:t.top,w:e,h:i,radius:s},inner:{x:t.left+r.l,y:t.top+r.t,w:e-r.l-r.r,h:i-r.t-r.b,radius:{topLeft:Math.max(0,s.topLeft-Math.max(r.t,r.l)),topRight:Math.max(0,s.topRight-Math.max(r.t,r.r)),bottomLeft:Math.max(0,s.bottomLeft-Math.max(r.b,r.l)),bottomRight:Math.max(0,s.bottomRight-Math.max(r.b,r.r))}}}}(this),a=function wue(n){return n.topLeft||n.topRight||n.bottomLeft||n.bottomRight}(o.radius)?ff:Cue;t.save(),(o.w!==s.w||o.h!==s.h)&&(t.beginPath(),a(t,Zk(o,e,s)),t.clip(),a(t,Zk(s,-e,o)),t.fillStyle=i,t.fill("evenodd")),t.beginPath(),a(t,Zk(s,e)),t.fillStyle=r,t.fill(),t.restore()}inRange(t,e,i){return Xk(this,t,e,i)}inXRange(t,e){return Xk(this,t,null,e)}inYRange(t,e){return Xk(this,null,t,e)}getCenterPoint(t){const{x:e,y:i,base:r,horizontal:s}=this.getProps(["x","y","base","horizontal"],t);return{x:s?(e+r)/2:e,y:s?i:(i+r)/2}}getRange(t){return"x"===t?this.width/2:this.height/2}}Ey.id="bar",Ey.defaults={borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0},Ey.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};var Due=Object.freeze({__proto__:null,ArcElement:Sy,LineElement:ky,PointElement:bue,BarElement:Ey});function Oz(n){if(n._decimated){const t=n._data;delete n._decimated,delete n._data,Object.defineProperty(n,"data",{value:t})}}function Fz(n){n.data.datasets.forEach(t=>{Oz(t)})}var Iue={id:"decimation",defaults:{algorithm:"min-max",enabled:!1},beforeElementsUpdate:(n,t,e)=>{if(!e.enabled)return void Fz(n);const i=n.width;n.data.datasets.forEach((r,s)=>{const{_data:o,indexAxis:a}=r,l=n.getDatasetMeta(s),c=o||r.data;if("y"===mf([a,n.options.indexAxis])||!l.controller.supportsDecimation)return;const d=n.scales[l.xAxisID];if("linear"!==d.type&&"time"!==d.type||n.options.parsing)return;let f,{start:u,count:h}=function Eue(n,t){const e=t.length;let r,i=0;const{iScale:s}=n,{min:o,max:a,minDefined:l,maxDefined:c}=s.getUserBounds();return l&&(i=Bi(Na(t,s.axis,o).lo,0,e-1)),r=c?Bi(Na(t,s.axis,a).hi+1,i,e)-i:e-i,{start:i,count:r}}(l,c);if(h<=(e.threshold||4*i))Oz(r);else{switch(Vt(o)&&(r._data=c,delete r.data,Object.defineProperty(r,"data",{configurable:!0,enumerable:!0,get:function(){return this._decimated},set:function(m){this._data=m}})),e.algorithm){case"lttb":f=function Sue(n,t,e,i,r){const s=r.samples||i;if(s>=e)return n.slice(t,t+e);const o=[],a=(e-2)/(s-2);let l=0;const c=t+e-1;let u,h,p,f,m,d=t;for(o[l++]=n[d],u=0;u<s-2;u++){let b,g=0,_=0;const y=Math.floor((u+1)*a)+1+t,v=Math.min(Math.floor((u+2)*a)+1,e)+t,x=v-y;for(b=y;b<v;b++)g+=n[b].x,_+=n[b].y;g/=x,_/=x;const w=Math.floor(u*a)+1+t,C=Math.min(Math.floor((u+1)*a)+1,e)+t,{x:D,y:k}=n[d];for(p=f=-1,b=w;b<C;b++)f=.5*Math.abs((D-g)*(n[b].y-k)-(D-n[b].x)*(_-k)),f>p&&(p=f,h=n[b],m=b);o[l++]=h,d=m}return o[l++]=n[c],o}(c,u,h,i,e);break;case"min-max":f=function kue(n,t,e,i){let o,a,l,c,d,u,h,p,f,m,r=0,s=0;const g=[],b=n[t].x,v=n[t+e-1].x-b;for(o=t;o<t+e;++o){a=n[o],l=(a.x-b)/v*i,c=a.y;const x=0|l;if(x===d)c<f?(f=c,u=o):c>m&&(m=c,h=o),r=(s*r+a.x)/++s;else{const w=o-1;if(!Vt(u)&&!Vt(h)){const C=Math.min(u,h),D=Math.max(u,h);C!==p&&C!==w&&g.push({...n[C],x:r}),D!==p&&D!==w&&g.push({...n[D],x:r})}o>0&&w!==p&&g.push(n[w]),g.push(a),d=x,s=0,f=m=c,u=h=p=o}}return g}(c,u,h,i);break;default:throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`)}r._decimated=f}})},destroy(n){Fz(n)}};function Qk(n,t,e,i){if(i)return;let r=t[n],s=e[n];return"angle"===n&&(r=ds(r),s=ds(s)),{property:n,start:r,end:s}}function Jk(n,t,e){for(;t>n;t--){const i=e[t];if(!isNaN(i.x)&&!isNaN(i.y))break}return t}function Pz(n,t,e,i){return n&&t?i(n[e],t[e]):n?n[e]:t?t[e]:0}function Lz(n,t){let e=[],i=!1;return bn(n)?(i=!0,e=n):e=function Aue(n,t){const{x:e=null,y:i=null}=n||{},r=t.points,s=[];return t.segments.forEach(({start:o,end:a})=>{a=Jk(o,a,r);const l=r[o],c=r[a];null!==i?(s.push({x:l.x,y:i}),s.push({x:c.x,y:i})):null!==e&&(s.push({x:e,y:l.y}),s.push({x:e,y:c.y}))}),s}(n,t),e.length?new ky({points:e,options:{tension:0},_loop:i,_fullLoop:i}):null}function $z(n){return n&&!1!==n.fill}function Mue(n,t,e){let r=n[t].fill;const s=[t];let o;if(!e)return r;for(;!1!==r&&-1===s.indexOf(r);){if(!ni(r))return r;if(o=n[r],!o)return!1;if(o.visible)return r;s.push(r),r=o.fill}return!1}function Nue(n,t,e){const i=function Pue(n){const t=n.options,e=t.fill;let i=ft(e&&e.target,e);return void 0===i&&(i=!!t.backgroundColor),!1!==i&&null!==i&&(!0===i?"origin":i)}(n);if(Tt(i))return!isNaN(i.value)&&i;let r=parseFloat(i);return ni(r)&&Math.floor(r)===r?function Rue(n,t,e,i){return("-"===n||"+"===n)&&(e=t+e),!(e===t||e<0||e>=i)&&e}(i[0],t,r,e):["origin","start","end","stack","shape"].indexOf(i)>=0&&i}function Vue(n,t,e){const i=[];for(let r=0;r<e.length;r++){const s=e[r],{first:o,last:a,point:l}=Bue(s,t,"x");if(!(!l||o&&a))if(o)i.unshift(l);else if(n.push(l),!a)break}n.push(...i)}function Bue(n,t,e){const i=n.interpolate(t,e);if(!i)return{};const r=i[e],s=n.segments,o=n.points;let a=!1,l=!1;for(let c=0;c<s.length;c++){const d=s[c],u=o[d.start][e],h=o[d.end][e];if(Ma(r,u,h)){a=r===u,l=r===h;break}}return{first:a,last:l,point:i}}class Vz{constructor(t){this.x=t.x,this.y=t.y,this.radius=t.radius}pathSegment(t,e,i){const{x:r,y:s,radius:o}=this;return t.arc(r,s,o,(e=e||{start:0,end:sn}).end,e.start,!0),!i.bounds}interpolate(t){const{x:e,y:i,radius:r}=this,s=t.angle;return{x:e+Math.cos(s)*r,y:i+Math.sin(s)*r,angle:s}}}function eE(n,t,e){const i=function zue(n){const{chart:t,fill:e,line:i}=n;if(ni(e))return function Uue(n,t){const e=n.getDatasetMeta(t);return e&&n.isDatasetVisible(t)?e.dataset:null}(t,e);if("stack"===e)return function Lue(n){const{scale:t,index:e,line:i}=n,r=[],s=i.segments,o=i.points,a=function $ue(n,t){const e=[],i=n.getMatchingVisibleMetas("line");for(let r=0;r<i.length;r++){const s=i[r];if(s.index===t)break;s.hidden||e.unshift(s.dataset)}return e}(t,e);a.push(Lz({x:null,y:t.bottom},i));for(let l=0;l<s.length;l++){const c=s[l];for(let d=c.start;d<=c.end;d++)Vue(r,o[d],a)}return new ky({points:r,options:{}})}(n);if("shape"===e)return!0;const r=function Hue(n){return(n.scale||{}).getPointPositionForValue?function Wue(n){const{scale:t,fill:e}=n,i=t.options,r=t.getLabels().length,s=i.reverse?t.max:t.min,o=function Fue(n,t,e){let i;return i="start"===n?e:"end"===n?t.options.reverse?t.min:t.max:Tt(n)?n.value:t.getBaseValue(),i}(e,t,s),a=[];if(i.grid.circular){const l=t.getPointPositionForValue(0,s);return new Vz({x:l.x,y:l.y,radius:t.getDistanceFromCenterForValue(o)})}for(let l=0;l<r;++l)a.push(t.getPointPositionForValue(l,o));return a}(n):function jue(n){const{scale:t={},fill:e}=n,i=function Oue(n,t){let e=null;return"start"===n?e=t.bottom:"end"===n?e=t.top:Tt(n)?e=t.getPixelForValue(n.value):t.getBasePixel&&(e=t.getBasePixel()),e}(e,t);if(ni(i)){const r=t.isHorizontal();return{x:r?i:null,y:r?null:i}}return null}(n)}(n);return r instanceof Vz?r:Lz(r,i)}(t),{line:r,scale:s,axis:o}=t,a=r.options,l=a.fill,c=a.backgroundColor,{above:d=c,below:u=c}=l||{};i&&r.points.length&&(hy(n,e),function Gue(n,t){const{line:e,target:i,above:r,below:s,area:o,scale:a}=t,l=e._loop?"angle":t.axis;n.save(),"x"===l&&s!==r&&(Bz(n,i,o.top),zz(n,{line:e,target:i,color:r,scale:a,property:l}),n.restore(),n.save(),Bz(n,i,o.bottom)),zz(n,{line:e,target:i,color:s,scale:a,property:l}),n.restore()}(n,{line:r,target:i,above:d,below:u,area:e,scale:s,axis:o}),py(n))}function Bz(n,t,e){const{segments:i,points:r}=t;let s=!0,o=!1;n.beginPath();for(const a of i){const{start:l,end:c}=a,d=r[l],u=r[Jk(l,c,r)];s?(n.moveTo(d.x,d.y),s=!1):(n.lineTo(d.x,e),n.lineTo(d.x,d.y)),o=!!t.pathSegment(n,a,{move:o}),o?n.closePath():n.lineTo(u.x,e)}n.lineTo(t.first().x,e),n.closePath(),n.clip()}function zz(n,t){const{line:e,target:i,property:r,color:s,scale:o}=t,a=function Tue(n,t,e){const i=n.segments,r=n.points,s=t.points,o=[];for(const a of i){let{start:l,end:c}=a;c=Jk(l,c,r);const d=Qk(e,r[l],r[c],a.loop);if(!t.segments){o.push({source:a,target:d,start:r[l],end:r[c]});continue}const u=BB(t,d);for(const h of u){const p=Qk(e,s[h.start],s[h.end],h.loop),f=VB(a,r,p);for(const m of f)o.push({source:m,target:h,start:{[e]:Pz(d,p,"start",Math.max)},end:{[e]:Pz(d,p,"end",Math.min)}})}}return o}(e,i,r);for(const{source:l,target:c,start:d,end:u}of a){const{style:{backgroundColor:h=s}={}}=l,p=!0!==i;n.save(),n.fillStyle=h,que(n,o,p&&Qk(r,d,u)),n.beginPath();const f=!!e.pathSegment(n,l);let m;if(p){f?n.closePath():Uz(n,i,u,r);const g=!!i.pathSegment(n,c,{move:f,reverse:!0});m=f&&g,m||Uz(n,i,d,r)}n.closePath(),n.fill(m?"evenodd":"nonzero"),n.restore()}}function que(n,t,e){const{top:i,bottom:r}=t.chart.chartArea,{property:s,start:o,end:a}=e||{};"x"===s&&(n.beginPath(),n.rect(o,i,a-o,r-i),n.clip())}function Uz(n,t,e,i){const r=t.interpolate(e,i);r&&n.lineTo(r.x,r.y)}var Yue={id:"filler",afterDatasetsUpdate(n,t,e){const i=(n.data.datasets||[]).length,r=[];let s,o,a,l;for(o=0;o<i;++o)s=n.getDatasetMeta(o),a=s.dataset,l=null,a&&a.options&&a instanceof ky&&(l={visible:n.isDatasetVisible(o),index:o,fill:Nue(a,o,i),chart:n,axis:s.controller.options.indexAxis,scale:s.vScale,line:a}),s.$filler=l,r.push(l);for(o=0;o<i;++o)l=r[o],l&&!1!==l.fill&&(l.fill=Mue(r,o,e.propagate))},beforeDraw(n,t,e){const i="beforeDraw"===e.drawTime,r=n.getSortedVisibleDatasetMetas(),s=n.chartArea;for(let o=r.length-1;o>=0;--o){const a=r[o].$filler;a&&(a.line.updateControlPoints(s,a.axis),i&&a.fill&&eE(n.ctx,a,s))}},beforeDatasetsDraw(n,t,e){if("beforeDatasetsDraw"!==e.drawTime)return;const i=n.getSortedVisibleDatasetMetas();for(let r=i.length-1;r>=0;--r){const s=i[r].$filler;$z(s)&&eE(n.ctx,s,n.chartArea)}},beforeDatasetDraw(n,t,e){const i=t.meta.$filler;!$z(i)||"beforeDatasetDraw"!==e.drawTime||eE(n.ctx,i,n.chartArea)},defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};const Hz=(n,t)=>{let{boxHeight:e=t,boxWidth:i=t}=n;return n.usePointStyle&&(e=Math.min(e,t),i=n.pointStyleWidth||Math.min(i,t)),{boxWidth:i,boxHeight:e,itemHeight:Math.max(t,e)}};class jz extends go{constructor(t){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,i){this.maxWidth=t,this.maxHeight=e,this._margins=i,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=yn(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter(i=>t.filter(i,this.chart.data))),t.sort&&(e=e.sort((i,r)=>t.sort(i,r,this.chart.data))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display)return void(this.width=this.height=0);const i=t.labels,r=ki(i.font),s=r.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:l}=Hz(i,s);let c,d;e.font=r.string,this.isHorizontal()?(c=this.maxWidth,d=this._fitRows(o,s,a,l)+10):(d=this.maxHeight,c=this._fitCols(o,s,a,l)+10),this.width=Math.min(c,t.maxWidth||this.maxWidth),this.height=Math.min(d,t.maxHeight||this.maxHeight)}_fitRows(t,e,i,r){const{ctx:s,maxWidth:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.lineWidths=[0],d=r+a;let u=t;s.textAlign="left",s.textBaseline="middle";let h=-1,p=-d;return this.legendItems.forEach((f,m)=>{const g=i+e/2+s.measureText(f.text).width;(0===m||c[c.length-1]+g+2*a>o)&&(u+=d,c[c.length-(m>0?0:1)]=0,p+=d,h++),l[m]={left:0,top:p,row:h,width:g,height:r},c[c.length-1]+=g+a}),u}_fitCols(t,e,i,r){const{ctx:s,maxHeight:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.columnSizes=[],d=o-t;let u=a,h=0,p=0,f=0,m=0;return this.legendItems.forEach((g,_)=>{const b=i+e/2+s.measureText(g.text).width;_>0&&p+r+2*a>d&&(u+=h+a,c.push({width:h,height:p}),f+=h+a,m++,h=p=0),l[_]={left:f,top:p,col:m,width:b,height:r},h=Math.max(h,b),p+=r+a}),u+=h,c.push({width:h,height:p}),u}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:i,labels:{padding:r},rtl:s}}=this,o=Mu(s,this.left,this.width);if(this.isHorizontal()){let a=0,l=cr(i,this.left+r,this.right-this.lineWidths[a]);for(const c of e)a!==c.row&&(a=c.row,l=cr(i,this.left+r,this.right-this.lineWidths[a])),c.top+=this.top+t+r,c.left=o.leftForLtr(o.x(l),c.width),l+=c.width+r}else{let a=0,l=cr(i,this.top+t+r,this.bottom-this.columnSizes[a].height);for(const c of e)c.col!==a&&(a=c.col,l=cr(i,this.top+t+r,this.bottom-this.columnSizes[a].height)),c.top=l,c.left+=this.left+r,c.left=o.leftForLtr(o.x(c.left),c.width),l+=c.height+r}}isHorizontal(){return"top"===this.options.position||"bottom"===this.options.position}draw(){if(this.options.display){const t=this.ctx;hy(t,this),this._draw(),py(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:i,ctx:r}=this,{align:s,labels:o}=t,a=At.color,l=Mu(t.rtl,this.left,this.width),c=ki(o.font),{color:d,padding:u}=o,h=c.size,p=h/2;let f;this.drawTitle(),r.textAlign=l.textAlign("left"),r.textBaseline="middle",r.lineWidth=.5,r.font=c.string;const{boxWidth:m,boxHeight:g,itemHeight:_}=Hz(o,h),v=this.isHorizontal(),x=this._computeTitleHeight();f=v?{x:cr(s,this.left+u,this.right-i[0]),y:this.top+u+x,line:0}:{x:this.left+u,y:cr(s,this.top+x+u,this.bottom-e[0].height),line:0},FB(this.ctx,t.textDirection);const w=_+u;this.legendItems.forEach((C,D)=>{r.strokeStyle=C.fontColor||d,r.fillStyle=C.fontColor||d;const k=r.measureText(C.text).width,I=l.textAlign(C.textAlign||(C.textAlign=o.textAlign)),A=m+p+k;let $=f.x,H=f.y;l.setWidth(this.width),v?D>0&&$+A+u>this.right&&(H=f.y+=w,f.line++,$=f.x=cr(s,this.left+u,this.right-i[f.line])):D>0&&H+w>this.bottom&&($=f.x=$+e[f.line].width+u,f.line++,H=f.y=cr(s,this.top+x+u,this.bottom-e[f.line].height)),function(C,D,k){if(isNaN(m)||m<=0||isNaN(g)||g<0)return;r.save();const I=ft(k.lineWidth,1);if(r.fillStyle=ft(k.fillStyle,a),r.lineCap=ft(k.lineCap,"butt"),r.lineDashOffset=ft(k.lineDashOffset,0),r.lineJoin=ft(k.lineJoin,"miter"),r.lineWidth=I,r.strokeStyle=ft(k.strokeStyle,a),r.setLineDash(ft(k.lineDash,[])),o.usePointStyle){const A={radius:g*Math.SQRT2/2,pointStyle:k.pointStyle,rotation:k.rotation,borderWidth:I},$=l.xPlus(C,m/2);xB(r,A,$,D+p,o.pointStyleWidth&&m)}else{const A=D+Math.max((h-g)/2,0),$=l.leftForLtr(C,m),H=$c(k.borderRadius);r.beginPath(),Object.values(H).some(W=>0!==W)?ff(r,{x:$,y:A,w:m,h:g,radius:H}):r.rect($,A,m,g),r.fill(),0!==I&&r.stroke()}r.restore()}(l.x($),H,C),$=((n,t,e,i)=>n===(i?"left":"right")?e:"center"===n?(t+e)/2:t)(I,$+m+p,v?$+A:this.right,t.rtl),function(C,D,k){Lc(r,k.text,C,D+_/2,c,{strikethrough:k.hidden,textAlign:l.textAlign(k.textAlign)})}(l.x($),H,C),v?f.x+=A+u:f.y+=w}),PB(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,i=ki(e.font),r=dr(e.padding);if(!e.display)return;const s=Mu(t.rtl,this.left,this.width),o=this.ctx,a=e.position,c=r.top+i.size/2;let d,u=this.left,h=this.width;if(this.isHorizontal())h=Math.max(...this.lineWidths),d=this.top+c,u=cr(t.align,u,this.right-h);else{const f=this.columnSizes.reduce((m,g)=>Math.max(m,g.height),0);d=c+cr(t.align,this.top,this.bottom-f-t.labels.padding-this._computeTitleHeight())}const p=cr(a,u,u+h);o.textAlign=s.textAlign(Dk(a)),o.textBaseline="middle",o.strokeStyle=e.color,o.fillStyle=e.color,o.font=i.string,Lc(o,e.text,p,d,i)}_computeTitleHeight(){const t=this.options.title,e=ki(t.font),i=dr(t.padding);return t.display?e.lineHeight+i.height:0}_getLegendItemAt(t,e){let i,r,s;if(Ma(t,this.left,this.right)&&Ma(e,this.top,this.bottom))for(s=this.legendHitBoxes,i=0;i<s.length;++i)if(r=s[i],Ma(t,r.left,r.left+r.width)&&Ma(e,r.top,r.top+r.height))return this.legendItems[i];return null}handleEvent(t){const e=this.options;if(!function Xue(n,t){return!(("mousemove"!==n&&"mouseout"!==n||!t.onHover&&!t.onLeave)&&(!t.onClick||"click"!==n&&"mouseup"!==n))}(t.type,e))return;const i=this._getLegendItemAt(t.x,t.y);if("mousemove"===t.type||"mouseout"===t.type){const r=this._hoveredItem,s=((n,t)=>null!==n&&null!==t&&n.datasetIndex===t.datasetIndex&&n.index===t.index)(r,i);r&&!s&&yn(e.onLeave,[t,r,this],this),this._hoveredItem=i,i&&!s&&yn(e.onHover,[t,i,this],this)}else i&&yn(e.onClick,[t,i,this],this)}}var Zue={id:"legend",_element:jz,start(n,t,e){const i=n.legend=new jz({ctx:n.ctx,options:e,chart:n});ur.configure(n,i,e),ur.addBox(n,i)},stop(n){ur.removeBox(n,n.legend),delete n.legend},beforeUpdate(n,t,e){const i=n.legend;ur.configure(n,i,e),i.options=e},afterUpdate(n){const t=n.legend;t.buildLabels(),t.adjustHitBoxes()},afterEvent(n,t){t.replay||n.legend.handleEvent(t.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(n,t,e){const i=t.datasetIndex,r=e.chart;r.isDatasetVisible(i)?(r.hide(i),t.hidden=!0):(r.show(i),t.hidden=!1)},onHover:null,onLeave:null,labels:{color:n=>n.chart.options.color,boxWidth:40,padding:10,generateLabels(n){const t=n.data.datasets,{labels:{usePointStyle:e,pointStyle:i,textAlign:r,color:s}}=n.legend.options;return n._getSortedDatasetMetas().map(o=>{const a=o.controller.getStyle(e?0:void 0),l=dr(a.borderWidth);return{text:t[o.index].label,fillStyle:a.backgroundColor,fontColor:s,hidden:!o.visible,lineCap:a.borderCapStyle,lineDash:a.borderDash,lineDashOffset:a.borderDashOffset,lineJoin:a.borderJoinStyle,lineWidth:(l.width+l.height)/4,strokeStyle:a.borderColor,pointStyle:i||a.pointStyle,rotation:a.rotation,textAlign:r||a.textAlign,borderRadius:0,datasetIndex:o.index}},this)}},title:{color:n=>n.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:n=>!n.startsWith("on"),labels:{_scriptable:n=>!["generateLabels","filter","sort"].includes(n)}}};class tE extends go{constructor(t){super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e){const i=this.options;if(this.left=0,this.top=0,!i.display)return void(this.width=this.height=this.right=this.bottom=0);this.width=this.right=t,this.height=this.bottom=e;const r=bn(i.text)?i.text.length:1;this._padding=dr(i.padding);const s=r*ki(i.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=s:this.width=s}isHorizontal(){const t=this.options.position;return"top"===t||"bottom"===t}_drawArgs(t){const{top:e,left:i,bottom:r,right:s,options:o}=this,a=o.align;let c,d,u,l=0;return this.isHorizontal()?(d=cr(a,i,s),u=e+t,c=s-i):("left"===o.position?(d=i+t,u=cr(a,r,e),l=-.5*Mn):(d=s-t,u=cr(a,e,r),l=.5*Mn),c=r-e),{titleX:d,titleY:u,maxWidth:c,rotation:l}}draw(){const t=this.ctx,e=this.options;if(!e.display)return;const i=ki(e.font),s=i.lineHeight/2+this._padding.top,{titleX:o,titleY:a,maxWidth:l,rotation:c}=this._drawArgs(s);Lc(t,e.text,0,0,i,{color:e.color,maxWidth:l,rotation:c,textAlign:Dk(e.align),textBaseline:"middle",translation:[o,a]})}}var Jue={id:"title",_element:tE,start(n,t,e){!function Que(n,t){const e=new tE({ctx:n.ctx,options:t,chart:n});ur.configure(n,e,t),ur.addBox(n,e),n.titleBlock=e}(n,e)},stop(n){ur.removeBox(n,n.titleBlock),delete n.titleBlock},beforeUpdate(n,t,e){const i=n.titleBlock;ur.configure(n,i,e),i.options=e},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const Iy=new WeakMap;var ehe={id:"subtitle",start(n,t,e){const i=new tE({ctx:n.ctx,options:e,chart:n});ur.configure(n,i,e),ur.addBox(n,i),Iy.set(n,i)},stop(n){ur.removeBox(n,Iy.get(n)),Iy.delete(n)},beforeUpdate(n,t,e){const i=Iy.get(n);ur.configure(n,i,e),i.options=e},defaults:{align:"center",display:!1,font:{weight:"normal"},fullSize:!0,padding:0,position:"top",text:"",weight:1500},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const kf={average(n){if(!n.length)return!1;let t,e,i=0,r=0,s=0;for(t=0,e=n.length;t<e;++t){const o=n[t].element;if(o&&o.hasValue()){const a=o.tooltipPosition();i+=a.x,r+=a.y,++s}}return{x:i/s,y:r/s}},nearest(n,t){if(!n.length)return!1;let s,o,a,e=t.x,i=t.y,r=Number.POSITIVE_INFINITY;for(s=0,o=n.length;s<o;++s){const l=n[s].element;if(l&&l.hasValue()){const d=wk(t,l.getCenterPoint());d<r&&(r=d,a=l)}}if(a){const l=a.tooltipPosition();e=l.x,i=l.y}return{x:e,y:i}}};function Go(n,t){return t&&(bn(t)?Array.prototype.push.apply(n,t):n.push(t)),n}function Fa(n){return("string"==typeof n||n instanceof String)&&n.indexOf("\n")>-1?n.split("\n"):n}function the(n,t){const{element:e,datasetIndex:i,index:r}=t,s=n.getDatasetMeta(i).controller,{label:o,value:a}=s.getLabelAndValue(r);return{chart:n,label:o,parsed:s.getParsed(r),raw:n.data.datasets[i].data[r],formattedValue:a,dataset:s.getDataset(),dataIndex:r,datasetIndex:i,element:e}}function Wz(n,t){const e=n.chart.ctx,{body:i,footer:r,title:s}=n,{boxWidth:o,boxHeight:a}=t,l=ki(t.bodyFont),c=ki(t.titleFont),d=ki(t.footerFont),u=s.length,h=r.length,p=i.length,f=dr(t.padding);let m=f.height,g=0,_=i.reduce((v,x)=>v+x.before.length+x.lines.length+x.after.length,0);_+=n.beforeBody.length+n.afterBody.length,u&&(m+=u*c.lineHeight+(u-1)*t.titleSpacing+t.titleMarginBottom),_&&(m+=p*(t.displayColors?Math.max(a,l.lineHeight):l.lineHeight)+(_-p)*l.lineHeight+(_-1)*t.bodySpacing),h&&(m+=t.footerMarginTop+h*d.lineHeight+(h-1)*t.footerSpacing);let b=0;const y=function(v){g=Math.max(g,e.measureText(v).width+b)};return e.save(),e.font=c.string,en(n.title,y),e.font=l.string,en(n.beforeBody.concat(n.afterBody),y),b=t.displayColors?o+2+t.boxPadding:0,en(i,v=>{en(v.before,y),en(v.lines,y),en(v.after,y)}),b=0,e.font=d.string,en(n.footer,y),e.restore(),g+=f.width,{width:g,height:m}}function rhe(n,t,e,i){const{x:r,width:s}=e,{width:o,chartArea:{left:a,right:l}}=n;let c="center";return"center"===i?c=r<=(a+l)/2?"left":"right":r<=s/2?c="left":r>=o-s/2&&(c="right"),function ihe(n,t,e,i){const{x:r,width:s}=i,o=e.caretSize+e.caretPadding;if("left"===n&&r+s+o>t.width||"right"===n&&r-s-o<0)return!0}(c,n,t,e)&&(c="center"),c}function Gz(n,t,e){const i=e.yAlign||t.yAlign||function nhe(n,t){const{y:e,height:i}=t;return e<i/2?"top":e>n.height-i/2?"bottom":"center"}(n,e);return{xAlign:e.xAlign||t.xAlign||rhe(n,t,e,i),yAlign:i}}function qz(n,t,e,i){const{caretSize:r,caretPadding:s,cornerRadius:o}=n,{xAlign:a,yAlign:l}=e,c=r+s,{topLeft:d,topRight:u,bottomLeft:h,bottomRight:p}=$c(o);let f=function she(n,t){let{x:e,width:i}=n;return"right"===t?e-=i:"center"===t&&(e-=i/2),e}(t,a);const m=function ohe(n,t,e){let{y:i,height:r}=n;return"top"===t?i+=e:i-="bottom"===t?r+e:r/2,i}(t,l,c);return"center"===l?"left"===a?f+=c:"right"===a&&(f-=c):"left"===a?f-=Math.max(d,h)+r:"right"===a&&(f+=Math.max(u,p)+r),{x:Bi(f,0,i.width-t.width),y:Bi(m,0,i.height-t.height)}}function Ty(n,t,e){const i=dr(e.padding);return"center"===t?n.x+n.width/2:"right"===t?n.x+n.width-i.right:n.x+i.left}function Yz(n){return Go([],Fa(n))}function Kz(n,t){const e=t&&t.dataset&&t.dataset.tooltip&&t.dataset.tooltip.callbacks;return e?n.override(e):n}let Xz=(()=>{class n extends go{constructor(e){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=e.chart||e._chart,this._chart=this.chart,this.options=e.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(e){this.options=e,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const e=this._cachedAnimations;if(e)return e;const i=this.chart,r=this.options.setContext(this.getContext()),s=r.enabled&&i.options.animation&&r.animations,o=new jB(this.chart,s);return s._cacheable&&(this._cachedAnimations=Object.freeze(o)),o}getContext(){return this.$context||(this.$context=function ahe(n,t,e){return _l(n,{tooltip:t,tooltipItems:e,type:"tooltip"})}(this.chart.getContext(),this,this._tooltipItems))}getTitle(e,i){const{callbacks:r}=i,s=r.beforeTitle.apply(this,[e]),o=r.title.apply(this,[e]),a=r.afterTitle.apply(this,[e]);let l=[];return l=Go(l,Fa(s)),l=Go(l,Fa(o)),l=Go(l,Fa(a)),l}getBeforeBody(e,i){return Yz(i.callbacks.beforeBody.apply(this,[e]))}getBody(e,i){const{callbacks:r}=i,s=[];return en(e,o=>{const a={before:[],lines:[],after:[]},l=Kz(r,o);Go(a.before,Fa(l.beforeLabel.call(this,o))),Go(a.lines,l.label.call(this,o)),Go(a.after,Fa(l.afterLabel.call(this,o))),s.push(a)}),s}getAfterBody(e,i){return Yz(i.callbacks.afterBody.apply(this,[e]))}getFooter(e,i){const{callbacks:r}=i,s=r.beforeFooter.apply(this,[e]),o=r.footer.apply(this,[e]),a=r.afterFooter.apply(this,[e]);let l=[];return l=Go(l,Fa(s)),l=Go(l,Fa(o)),l=Go(l,Fa(a)),l}_createItems(e){const i=this._active,r=this.chart.data,s=[],o=[],a=[];let c,d,l=[];for(c=0,d=i.length;c<d;++c)l.push(the(this.chart,i[c]));return e.filter&&(l=l.filter((u,h,p)=>e.filter(u,h,p,r))),e.itemSort&&(l=l.sort((u,h)=>e.itemSort(u,h,r))),en(l,u=>{const h=Kz(e.callbacks,u);s.push(h.labelColor.call(this,u)),o.push(h.labelPointStyle.call(this,u)),a.push(h.labelTextColor.call(this,u))}),this.labelColors=s,this.labelPointStyles=o,this.labelTextColors=a,this.dataPoints=l,l}update(e,i){const r=this.options.setContext(this.getContext()),s=this._active;let o,a=[];if(s.length){const l=kf[r.position].call(this,s,this._eventPosition);a=this._createItems(r),this.title=this.getTitle(a,r),this.beforeBody=this.getBeforeBody(a,r),this.body=this.getBody(a,r),this.afterBody=this.getAfterBody(a,r),this.footer=this.getFooter(a,r);const c=this._size=Wz(this,r),d=Object.assign({},l,c),u=Gz(this.chart,r,d),h=qz(r,d,u,this.chart);this.xAlign=u.xAlign,this.yAlign=u.yAlign,o={opacity:1,x:h.x,y:h.y,width:c.width,height:c.height,caretX:l.x,caretY:l.y}}else 0!==this.opacity&&(o={opacity:0});this._tooltipItems=a,this.$context=void 0,o&&this._resolveAnimations().update(this,o),e&&r.external&&r.external.call(this,{chart:this.chart,tooltip:this,replay:i})}drawCaret(e,i,r,s){const o=this.getCaretPosition(e,r,s);i.lineTo(o.x1,o.y1),i.lineTo(o.x2,o.y2),i.lineTo(o.x3,o.y3)}getCaretPosition(e,i,r){const{xAlign:s,yAlign:o}=this,{caretSize:a,cornerRadius:l}=r,{topLeft:c,topRight:d,bottomLeft:u,bottomRight:h}=$c(l),{x:p,y:f}=e,{width:m,height:g}=i;let _,b,y,v,x,w;return"center"===o?(x=f+g/2,"left"===s?(_=p,b=_-a,v=x+a,w=x-a):(_=p+m,b=_+a,v=x-a,w=x+a),y=_):(b="left"===s?p+Math.max(c,u)+a:"right"===s?p+m-Math.max(d,h)-a:this.caretX,"top"===o?(v=f,x=v-a,_=b-a,y=b+a):(v=f+g,x=v+a,_=b+a,y=b-a),w=v),{x1:_,x2:b,x3:y,y1:v,y2:x,y3:w}}drawTitle(e,i,r){const s=this.title,o=s.length;let a,l,c;if(o){const d=Mu(r.rtl,this.x,this.width);for(e.x=Ty(this,r.titleAlign,r),i.textAlign=d.textAlign(r.titleAlign),i.textBaseline="middle",a=ki(r.titleFont),l=r.titleSpacing,i.fillStyle=r.titleColor,i.font=a.string,c=0;c<o;++c)i.fillText(s[c],d.x(e.x),e.y+a.lineHeight/2),e.y+=a.lineHeight+l,c+1===o&&(e.y+=r.titleMarginBottom-l)}}_drawColorBox(e,i,r,s,o){const a=this.labelColors[r],l=this.labelPointStyles[r],{boxHeight:c,boxWidth:d,boxPadding:u}=o,h=ki(o.bodyFont),p=Ty(this,"left",o),f=s.x(p),g=i.y+(c<h.lineHeight?(h.lineHeight-c)/2:0);if(o.usePointStyle){const _={radius:Math.min(d,c)/2,pointStyle:l.pointStyle,rotation:l.rotation,borderWidth:1},b=s.leftForLtr(f,d)+d/2,y=g+c/2;e.strokeStyle=o.multiKeyBackground,e.fillStyle=o.multiKeyBackground,Rk(e,_,b,y),e.strokeStyle=a.borderColor,e.fillStyle=a.backgroundColor,Rk(e,_,b,y)}else{e.lineWidth=Tt(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1,e.strokeStyle=a.borderColor,e.setLineDash(a.borderDash||[]),e.lineDashOffset=a.borderDashOffset||0;const _=s.leftForLtr(f,d-u),b=s.leftForLtr(s.xPlus(f,1),d-u-2),y=$c(a.borderRadius);Object.values(y).some(v=>0!==v)?(e.beginPath(),e.fillStyle=o.multiKeyBackground,ff(e,{x:_,y:g,w:d,h:c,radius:y}),e.fill(),e.stroke(),e.fillStyle=a.backgroundColor,e.beginPath(),ff(e,{x:b,y:g+1,w:d-2,h:c-2,radius:y}),e.fill()):(e.fillStyle=o.multiKeyBackground,e.fillRect(_,g,d,c),e.strokeRect(_,g,d,c),e.fillStyle=a.backgroundColor,e.fillRect(b,g+1,d-2,c-2))}e.fillStyle=this.labelTextColors[r]}drawBody(e,i,r){const{body:s}=this,{bodySpacing:o,bodyAlign:a,displayColors:l,boxHeight:c,boxWidth:d,boxPadding:u}=r,h=ki(r.bodyFont);let p=h.lineHeight,f=0;const m=Mu(r.rtl,this.x,this.width),g=function(k){i.fillText(k,m.x(e.x+f),e.y+p/2),e.y+=p+o},_=m.textAlign(a);let b,y,v,x,w,C,D;for(i.textAlign=a,i.textBaseline="middle",i.font=h.string,e.x=Ty(this,_,r),i.fillStyle=r.bodyColor,en(this.beforeBody,g),f=l&&"right"!==_?"center"===a?d/2+u:d+2+u:0,x=0,C=s.length;x<C;++x){for(b=s[x],y=this.labelTextColors[x],i.fillStyle=y,en(b.before,g),v=b.lines,l&&v.length&&(this._drawColorBox(i,e,x,m,r),p=Math.max(h.lineHeight,c)),w=0,D=v.length;w<D;++w)g(v[w]),p=h.lineHeight;en(b.after,g)}f=0,p=h.lineHeight,en(this.afterBody,g),e.y-=o}drawFooter(e,i,r){const s=this.footer,o=s.length;let a,l;if(o){const c=Mu(r.rtl,this.x,this.width);for(e.x=Ty(this,r.footerAlign,r),e.y+=r.footerMarginTop,i.textAlign=c.textAlign(r.footerAlign),i.textBaseline="middle",a=ki(r.footerFont),i.fillStyle=r.footerColor,i.font=a.string,l=0;l<o;++l)i.fillText(s[l],c.x(e.x),e.y+a.lineHeight/2),e.y+=a.lineHeight+r.footerSpacing}}drawBackground(e,i,r,s){const{xAlign:o,yAlign:a}=this,{x:l,y:c}=e,{width:d,height:u}=r,{topLeft:h,topRight:p,bottomLeft:f,bottomRight:m}=$c(s.cornerRadius);i.fillStyle=s.backgroundColor,i.strokeStyle=s.borderColor,i.lineWidth=s.borderWidth,i.beginPath(),i.moveTo(l+h,c),"top"===a&&this.drawCaret(e,i,r,s),i.lineTo(l+d-p,c),i.quadraticCurveTo(l+d,c,l+d,c+p),"center"===a&&"right"===o&&this.drawCaret(e,i,r,s),i.lineTo(l+d,c+u-m),i.quadraticCurveTo(l+d,c+u,l+d-m,c+u),"bottom"===a&&this.drawCaret(e,i,r,s),i.lineTo(l+f,c+u),i.quadraticCurveTo(l,c+u,l,c+u-f),"center"===a&&"left"===o&&this.drawCaret(e,i,r,s),i.lineTo(l,c+h),i.quadraticCurveTo(l,c,l+h,c),i.closePath(),i.fill(),s.borderWidth>0&&i.stroke()}_updateAnimationTarget(e){const i=this.chart,r=this.$animations,s=r&&r.x,o=r&&r.y;if(s||o){const a=kf[e.position].call(this,this._active,this._eventPosition);if(!a)return;const l=this._size=Wz(this,e),c=Object.assign({},a,this._size),d=Gz(i,e,c),u=qz(e,c,d,i);(s._to!==u.x||o._to!==u.y)&&(this.xAlign=d.xAlign,this.yAlign=d.yAlign,this.width=l.width,this.height=l.height,this.caretX=a.x,this.caretY=a.y,this._resolveAnimations().update(this,u))}}_willRender(){return!!this.opacity}draw(e){const i=this.options.setContext(this.getContext());let r=this.opacity;if(!r)return;this._updateAnimationTarget(i);const s={width:this.width,height:this.height},o={x:this.x,y:this.y};r=Math.abs(r)<.001?0:r;const a=dr(i.padding);i.enabled&&(this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length)&&(e.save(),e.globalAlpha=r,this.drawBackground(o,e,s,i),FB(e,i.textDirection),o.y+=a.top,this.drawTitle(o,e,i),this.drawBody(o,e,i),this.drawFooter(o,e,i),PB(e,i.textDirection),e.restore())}getActiveElements(){return this._active||[]}setActiveElements(e,i){const r=this._active,s=e.map(({datasetIndex:l,index:c})=>{const d=this.chart.getDatasetMeta(l);if(!d)throw new Error("Cannot find a dataset at index "+l);return{datasetIndex:l,element:d.data[c],index:c}}),o=!iy(r,s),a=this._positionChanged(s,i);(o||a)&&(this._active=s,this._eventPosition=i,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(e,i,r=!0){if(i&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const s=this.options,o=this._active||[],a=this._getActiveElements(e,o,i,r),l=this._positionChanged(a,e),c=i||!iy(a,o)||l;return c&&(this._active=a,(s.enabled||s.external)&&(this._eventPosition={x:e.x,y:e.y},this.update(!0,i))),c}_getActiveElements(e,i,r,s){const o=this.options;if("mouseout"===e.type)return[];if(!s)return i;const a=this.chart.getElementsAtEventForMode(e,o.mode,o,r);return o.reverse&&a.reverse(),a}_positionChanged(e,i){const{caretX:r,caretY:s,options:o}=this,a=kf[o.position].call(this,e,i);return!1!==a&&(r!==a.x||s!==a.y)}}return n.positioners=kf,n})();var lhe={id:"tooltip",_element:Xz,positioners:kf,afterInit(n,t,e){e&&(n.tooltip=new Xz({chart:n,options:e}))},beforeUpdate(n,t,e){n.tooltip&&n.tooltip.initialize(e)},reset(n,t,e){n.tooltip&&n.tooltip.initialize(e)},afterDraw(n){const t=n.tooltip;if(t&&t._willRender()){const e={tooltip:t};if(!1===n.notifyPlugins("beforeTooltipDraw",e))return;t.draw(n.ctx),n.notifyPlugins("afterTooltipDraw",e)}},afterEvent(n,t){n.tooltip&&n.tooltip.handleEvent(t.event,t.replay,t.inChartArea)&&(t.changed=!0)},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(n,t)=>t.bodyFont.size,boxWidth:(n,t)=>t.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:{beforeTitle:Aa,title(n){if(n.length>0){const t=n[0],e=t.chart.data.labels,i=e?e.length:0;if(this&&this.options&&"dataset"===this.options.mode)return t.dataset.label||"";if(t.label)return t.label;if(i>0&&t.dataIndex<i)return e[t.dataIndex]}return""},afterTitle:Aa,beforeBody:Aa,beforeLabel:Aa,label(n){if(this&&this.options&&"dataset"===this.options.mode)return n.label+": "+n.formattedValue||n.formattedValue;let t=n.dataset.label||"";t&&(t+=": ");const e=n.formattedValue;return Vt(e)||(t+=e),t},labelColor(n){const e=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(n){const e=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:Aa,afterBody:Aa,beforeFooter:Aa,footer:Aa,afterFooter:Aa}},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:n=>"filter"!==n&&"itemSort"!==n&&"external"!==n,_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]},che=Object.freeze({__proto__:null,Decimation:Iue,Filler:Yue,Legend:Zue,SubTitle:ehe,Title:Jue,Tooltip:lhe});class Ay extends Uc{constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const i=this.getLabels();for(const{index:r,label:s}of e)i[r]===s&&i.splice(r,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(Vt(t))return null;const i=this.getLabels();return e=isFinite(e)&&i[e]===t?e:function uhe(n,t,e,i){const r=n.indexOf(t);return-1===r?((n,t,e,i)=>("string"==typeof t?(e=n.push(t)-1,i.unshift({index:e,label:t})):isNaN(t)&&(e=null),e))(n,t,e,i):r!==n.lastIndexOf(t)?e:r}(i,t,ft(e,t),this._addedLabels),((n,t)=>null===n?null:Bi(Math.round(n),0,t))(e,i.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:i,max:r}=this.getMinMax(!0);"ticks"===this.options.bounds&&(t||(i=0),e||(r=this.getLabels().length-1)),this.min=i,this.max=r}buildTicks(){const t=this.min,e=this.max,i=this.options.offset,r=[];let s=this.getLabels();s=0===t&&e===s.length-1?s:s.slice(t,e+1),this._valueRange=Math.max(s.length-(i?0:1),1),this._startValue=this.min-(i?.5:0);for(let o=t;o<=e;o++)r.push({value:o});return r}getLabelForValue(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return"number"!=typeof t&&(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}}function Zz(n,t,{horizontal:e,minRotation:i}){const r=mo(i),s=(e?Math.sin(r):Math.cos(r))||.001;return Math.min(t/s,.75*t*(""+n).length)}Ay.id="category",Ay.defaults={ticks:{callback:Ay.prototype.getLabelForValue}};class My extends Uc{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return Vt(t)||("number"==typeof t||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:i}=this.getUserBounds();let{min:r,max:s}=this;const o=l=>r=e?r:l,a=l=>s=i?s:l;if(t){const l=Ho(r),c=Ho(s);l<0&&c<0?a(0):l>0&&c>0&&o(0)}if(r===s){let l=1;(s>=Number.MAX_SAFE_INTEGER||r<=Number.MIN_SAFE_INTEGER)&&(l=Math.abs(.05*s)),a(s+l),t||o(r-l)}this.min=r,this.max=s}getTickLimit(){const t=this.options.ticks;let r,{maxTicksLimit:e,stepSize:i}=t;return i?(r=Math.ceil(this.max/i)-Math.floor(this.min/i)+1,r>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${r} ticks. Limiting to 1000.`),r=1e3)):(r=this.computeTickLimit(),e=e||11),e&&(r=Math.min(e,r)),r}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let i=this.getTickLimit();i=Math.max(2,i);const o=function phe(n,t){const e=[],{bounds:r,step:s,min:o,max:a,precision:l,count:c,maxTicks:d,maxDigits:u,includeBounds:h}=n,p=s||1,f=d-1,{min:m,max:g}=t,_=!Vt(o),b=!Vt(a),y=!Vt(c),v=(g-m)/(u+1);let w,C,D,k,x=ZV((g-m)/f/p)*p;if(x<1e-14&&!_&&!b)return[{value:m},{value:g}];k=Math.ceil(g/x)-Math.floor(m/x),k>f&&(x=ZV(k*x/f/p)*p),Vt(l)||(w=Math.pow(10,l),x=Math.ceil(x*w)/w),"ticks"===r?(C=Math.floor(m/x)*x,D=Math.ceil(g/x)*x):(C=m,D=g),_&&b&&s&&function Gae(n,t){const e=Math.round(n);return e-t<=n&&e+t>=n}((a-o)/s,x/1e3)?(k=Math.round(Math.min((a-o)/x,d)),x=(a-o)/k,C=o,D=a):y?(C=_?o:C,D=b?a:D,k=c-1,x=(D-C)/k):(k=(D-C)/x,k=af(k,Math.round(k),x/1e3)?Math.round(k):Math.ceil(k));const I=Math.max(JV(x),JV(C));w=Math.pow(10,Vt(l)?I:l),C=Math.round(C*w)/w,D=Math.round(D*w)/w;let A=0;for(_&&(h&&C!==o?(e.push({value:o}),C<o&&A++,af(Math.round((C+A*x)*w)/w,o,Zz(o,v,n))&&A++):C<o&&A++);A<k;++A)e.push({value:Math.round((C+A*x)*w)/w});return b&&h&&D!==a?e.length&&af(e[e.length-1].value,a,Zz(a,v,n))?e[e.length-1].value=a:e.push({value:a}):(!b||D===a)&&e.push({value:D}),e}({maxTicks:i,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);return"ticks"===t.bounds&&QV(o,this,"value"),t.reverse?(o.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),o}configure(){const t=this.ticks;let e=this.min,i=this.max;if(super.configure(),this.options.offset&&t.length){const r=(i-e)/Math.max(t.length-1,1)/2;e-=r,i+=r}this._startValue=e,this._endValue=i,this._valueRange=i-e}getLabelForValue(t){return gf(t,this.chart.options.locale,this.options.ticks.format)}}class nE extends My{determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=ni(t)?t:0,this.max=ni(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,i=mo(this.options.ticks.minRotation),r=(t?Math.sin(i):Math.cos(i))||.001,s=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,s.lineHeight/r))}getPixelForValue(t){return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}function Qz(n){return n/Math.pow(10,Math.floor($s(n)))==1}nE.id="linear",nE.defaults={ticks:{callback:_y.formatters.numeric}};class iE extends Uc{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(t,e){const i=My.prototype.parse.apply(this,[t,e]);if(0!==i)return ni(i)&&i>0?i:null;this._zero=!0}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=ni(t)?Math.max(0,t):null,this.max=ni(e)?Math.max(0,e):null,this.options.beginAtZero&&(this._zero=!0),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let i=this.min,r=this.max;const s=l=>i=t?i:l,o=l=>r=e?r:l,a=(l,c)=>Math.pow(10,Math.floor($s(l))+c);i===r&&(i<=0?(s(1),o(10)):(s(a(i,-1)),o(a(r,1)))),i<=0&&s(a(r,-1)),r<=0&&o(a(i,1)),this._zero&&this.min!==this._suggestedMin&&i===a(this.min,0)&&s(a(i,-1)),this.min=i,this.max=r}buildTicks(){const t=this.options,i=function fhe(n,t){const e=Math.floor($s(t.max)),i=Math.ceil(t.max/Math.pow(10,e)),r=[];let s=Ps(n.min,Math.pow(10,Math.floor($s(t.min)))),o=Math.floor($s(s)),a=Math.floor(s/Math.pow(10,o)),l=o<0?Math.pow(10,Math.abs(o)):1;do{r.push({value:s,major:Qz(s)}),++a,10===a&&(a=1,++o,l=o>=0?1:l),s=Math.round(a*Math.pow(10,o)*l)/l}while(o<e||o===e&&a<i);const c=Ps(n.max,s);return r.push({value:c,major:Qz(s)}),r}({min:this._userMin,max:this._userMax},this);return"ticks"===t.bounds&&QV(i,this,"value"),t.reverse?(i.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),i}getLabelForValue(t){return void 0===t?"0":gf(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure(),this._startValue=$s(t),this._valueRange=$s(this.max)-$s(t)}getPixelForValue(t){return(void 0===t||0===t)&&(t=this.min),null===t||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:($s(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}function rE(n){const t=n.ticks;if(t.display&&n.display){const e=dr(t.backdropPadding);return ft(t.font&&t.font.size,At.font.size)+e.height}return 0}function mhe(n,t,e){return e=bn(e)?e:[e],{w:Dle(n,t.string,e),h:e.length*t.lineHeight}}function Jz(n,t,e,i,r){return n===i||n===r?{start:t-e/2,end:t+e/2}:n<i||n>r?{start:t-e,end:t}:{start:t,end:t+e}}function _he(n,t,e,i,r){const s=Math.abs(Math.sin(e)),o=Math.abs(Math.cos(e));let a=0,l=0;i.start<t.l?(a=(t.l-i.start)/s,n.l=Math.min(n.l,t.l-a)):i.end>t.r&&(a=(i.end-t.r)/s,n.r=Math.max(n.r,t.r+a)),r.start<t.t?(l=(t.t-r.start)/o,n.t=Math.min(n.t,t.t-l)):r.end>t.b&&(l=(r.end-t.b)/o,n.b=Math.max(n.b,t.b+l))}function yhe(n){return 0===n||180===n?"center":n<180?"left":"right"}function vhe(n,t,e){return"right"===e?n-=t:"center"===e&&(n-=t/2),n}function xhe(n,t,e){return 90===e||270===e?n-=t/2:(e>270||e<90)&&(n-=t),n}function e3(n,t,e,i){const{ctx:r}=n;if(e)r.arc(n.xCenter,n.yCenter,t,0,sn);else{let s=n.getPointPosition(0,t);r.moveTo(s.x,s.y);for(let o=1;o<i;o++)s=n.getPointPosition(o,t),r.lineTo(s.x,s.y)}}iE.id="logarithmic",iE.defaults={ticks:{callback:_y.formatters.logarithmic,major:{enabled:!0}}};class Ef extends My{constructor(t){super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const t=this._padding=dr(rE(this.options)/2),e=this.width=this.maxWidth-t.width,i=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+i/2+t.top),this.drawingArea=Math.floor(Math.min(e,i)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!1);this.min=ni(t)&&!isNaN(t)?t:0,this.max=ni(e)&&!isNaN(e)?e:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/rE(this.options))}generateTickLabels(t){My.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map((e,i)=>{const r=yn(this.options.pointLabels.callback,[e,i],this);return r||0===r?r:""}).filter((e,i)=>this.chart.getDataVisibility(i))}fit(){const t=this.options;t.display&&t.pointLabels.display?function ghe(n){const t={l:n.left+n._padding.left,r:n.right-n._padding.right,t:n.top+n._padding.top,b:n.bottom-n._padding.bottom},e=Object.assign({},t),i=[],r=[],s=n._pointLabels.length,o=n.options.pointLabels,a=o.centerPointLabels?Mn/s:0;for(let l=0;l<s;l++){const c=o.setContext(n.getPointLabelContext(l));r[l]=c.padding;const d=n.getPointPosition(l,n.drawingArea+r[l],a),u=ki(c.font),h=mhe(n.ctx,u,n._pointLabels[l]);i[l]=h;const p=ds(n.getIndexAngle(l)+a),f=Math.round(xk(p));_he(e,t,p,Jz(f,d.x,h.w,0,180),Jz(f,d.y,h.h,90,270))}n.setCenterPoint(t.l-e.l,e.r-t.r,t.t-e.t,e.b-t.b),n._pointLabelItems=function bhe(n,t,e){const i=[],r=n._pointLabels.length,s=n.options,o=rE(s)/2,a=n.drawingArea,l=s.pointLabels.centerPointLabels?Mn/r:0;for(let c=0;c<r;c++){const d=n.getPointPosition(c,a+o+e[c],l),u=Math.round(xk(ds(d.angle+Gn))),h=t[c],p=xhe(d.y,h.h,u),f=yhe(u),m=vhe(d.x,h.w,f);i.push({x:d.x,y:p,textAlign:f,left:m,top:p,right:m+h.w,bottom:p+h.h})}return i}(n,i,r)}(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,i,r){this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((i-r)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,i,r))}getIndexAngle(t){return ds(t*(sn/(this._pointLabels.length||1))+mo(this.options.startAngle||0))}getDistanceFromCenterForValue(t){if(Vt(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(Vt(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const i=e[t];return function Dhe(n,t,e){return _l(n,{label:e,index:t,type:"pointLabel"})}(this.getContext(),t,i)}}getPointPosition(t,e,i=0){const r=this.getIndexAngle(t)-Gn+i;return{x:Math.cos(r)*e+this.xCenter,y:Math.sin(r)*e+this.yCenter,angle:r}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:i,right:r,bottom:s}=this._pointLabelItems[t];return{left:e,top:i,right:r,bottom:s}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const i=this.ctx;i.save(),i.beginPath(),e3(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),i.closePath(),i.fillStyle=t,i.fill(),i.restore()}}drawGrid(){const t=this.ctx,e=this.options,{angleLines:i,grid:r}=e,s=this._pointLabels.length;let o,a,l;if(e.pointLabels.display&&function whe(n,t){const{ctx:e,options:{pointLabels:i}}=n;for(let r=t-1;r>=0;r--){const s=i.setContext(n.getPointLabelContext(r)),o=ki(s.font),{x:a,y:l,textAlign:c,left:d,top:u,right:h,bottom:p}=n._pointLabelItems[r],{backdropColor:f}=s;if(!Vt(f)){const m=$c(s.borderRadius),g=dr(s.backdropPadding);e.fillStyle=f;const _=d-g.left,b=u-g.top,y=h-d+g.width,v=p-u+g.height;Object.values(m).some(x=>0!==x)?(e.beginPath(),ff(e,{x:_,y:b,w:y,h:v,radius:m}),e.fill()):e.fillRect(_,b,y,v)}Lc(e,n._pointLabels[r],a,l+o.lineHeight/2,o,{color:s.color,textAlign:c,textBaseline:"middle"})}}(this,s),r.display&&this.ticks.forEach((c,d)=>{0!==d&&(a=this.getDistanceFromCenterForValue(c.value),function Che(n,t,e,i){const r=n.ctx,s=t.circular,{color:o,lineWidth:a}=t;!s&&!i||!o||!a||e<0||(r.save(),r.strokeStyle=o,r.lineWidth=a,r.setLineDash(t.borderDash),r.lineDashOffset=t.borderDashOffset,r.beginPath(),e3(n,e,s,i),r.closePath(),r.stroke(),r.restore())}(this,r.setContext(this.getContext(d-1)),a,s))}),i.display){for(t.save(),o=s-1;o>=0;o--){const c=i.setContext(this.getPointLabelContext(o)),{color:d,lineWidth:u}=c;!u||!d||(t.lineWidth=u,t.strokeStyle=d,t.setLineDash(c.borderDash),t.lineDashOffset=c.borderDashOffset,a=this.getDistanceFromCenterForValue(e.ticks.reverse?this.min:this.max),l=this.getPointPosition(o,a),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx,e=this.options,i=e.ticks;if(!i.display)return;const r=this.getIndexAngle(0);let s,o;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(r),t.textAlign="center",t.textBaseline="middle",this.ticks.forEach((a,l)=>{if(0===l&&!e.reverse)return;const c=i.setContext(this.getContext(l)),d=ki(c.font);if(s=this.getDistanceFromCenterForValue(this.ticks[l].value),c.showLabelBackdrop){t.font=d.string,o=t.measureText(a.label).width,t.fillStyle=c.backdropColor;const u=dr(c.backdropPadding);t.fillRect(-o/2-u.left,-s-d.size/2-u.top,o+u.width,d.size+u.height)}Lc(t,a.label,0,-s,d,{color:c.color})}),t.restore()}drawTitle(){}}Ef.id="radialLinear",Ef.defaults={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:_y.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:n=>n,padding:5,centerPointLabels:!1}},Ef.defaultRoutes={"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"},Ef.descriptors={angleLines:{_fallback:"grid"}};const Ny={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Hr=Object.keys(Ny);function She(n,t){return n-t}function t3(n,t){if(Vt(t))return null;const e=n._adapter,{parser:i,round:r,isoWeekday:s}=n._parseOpts;let o=t;return"function"==typeof i&&(o=i(o)),ni(o)||(o="string"==typeof i?e.parse(o,i):e.parse(o)),null===o?null:(r&&(o="week"!==r||!Eu(s)&&!0!==s?e.startOf(o,r):e.startOf(o,"isoWeek",s)),+o)}function n3(n,t,e,i){const r=Hr.length;for(let s=Hr.indexOf(n);s<r-1;++s){const o=Ny[Hr[s]];if(o.common&&Math.ceil((e-t)/((o.steps?o.steps:Number.MAX_SAFE_INTEGER)*o.size))<=i)return Hr[s]}return Hr[r-1]}function r3(n,t,e){if(e){if(e.length){const{lo:i,hi:r}=Ck(e,t);n[e[i]>=t?e[i]:e[r]]=!0}}else n[t]=!0}function s3(n,t,e){const i=[],r={},s=t.length;let o,a;for(o=0;o<s;++o)a=t[o],r[a]=o,i.push({value:a,major:!1});return 0!==s&&e?function Ihe(n,t,e,i){const r=n._adapter,s=+r.startOf(t[0].value,i),o=t[t.length-1].value;let a,l;for(a=s;a<=o;a=+r.add(a,1,i))l=e[a],l>=0&&(t[l].major=!0);return t}(n,i,r,e):i}let sE=(()=>{class n extends Uc{constructor(e){super(e),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(e,i){const r=e.time||(e.time={}),s=this._adapter=new pde._date(e.adapters.date);s.init(i),rf(r.displayFormats,s.formats()),this._parseOpts={parser:r.parser,round:r.round,isoWeekday:r.isoWeekday},super.init(e),this._normalized=i.normalized}parse(e,i){return void 0===e?null:t3(this,e)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const e=this.options,i=this._adapter,r=e.time.unit||"day";let{min:s,max:o,minDefined:a,maxDefined:l}=this.getUserBounds();function c(d){!a&&!isNaN(d.min)&&(s=Math.min(s,d.min)),!l&&!isNaN(d.max)&&(o=Math.max(o,d.max))}(!a||!l)&&(c(this._getLabelBounds()),("ticks"!==e.bounds||"labels"!==e.ticks.source)&&c(this.getMinMax(!1))),s=ni(s)&&!isNaN(s)?s:+i.startOf(Date.now(),r),o=ni(o)&&!isNaN(o)?o:+i.endOf(Date.now(),r)+1,this.min=Math.min(s,o-1),this.max=Math.max(s+1,o)}_getLabelBounds(){const e=this.getLabelTimestamps();let i=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;return e.length&&(i=e[0],r=e[e.length-1]),{min:i,max:r}}buildTicks(){const e=this.options,i=e.time,r=e.ticks,s="labels"===r.source?this.getLabelTimestamps():this._generate();"ticks"===e.bounds&&s.length&&(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);const o=this.min,l=function Xae(n,t,e){let i=0,r=n.length;for(;i<r&&n[i]<t;)i++;for(;r>i&&n[r-1]>e;)r--;return i>0||r<n.length?n.slice(i,r):n}(s,o,this.max);return this._unit=i.unit||(r.autoSkip?n3(i.minUnit,this.min,this.max,this._getLabelCapacity(o)):function khe(n,t,e,i,r){for(let s=Hr.length-1;s>=Hr.indexOf(e);s--){const o=Hr[s];if(Ny[o].common&&n._adapter.diff(r,i,o)>=t-1)return o}return Hr[e?Hr.indexOf(e):0]}(this,l.length,i.minUnit,this.min,this.max)),this._majorUnit=r.major.enabled&&"year"!==this._unit?function Ehe(n){for(let t=Hr.indexOf(n)+1,e=Hr.length;t<e;++t)if(Ny[Hr[t]].common)return Hr[t]}(this._unit):void 0,this.initOffsets(s),e.reverse&&l.reverse(),s3(this,l,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(e=>+e.value))}initOffsets(e){let s,o,i=0,r=0;this.options.offset&&e.length&&(s=this.getDecimalForValue(e[0]),i=1===e.length?1-s:(this.getDecimalForValue(e[1])-s)/2,o=this.getDecimalForValue(e[e.length-1]),r=1===e.length?o:(o-this.getDecimalForValue(e[e.length-2]))/2);const a=e.length<3?.5:.25;i=Bi(i,0,a),r=Bi(r,0,a),this._offsets={start:i,end:r,factor:1/(i+1+r)}}_generate(){const e=this._adapter,i=this.min,r=this.max,s=this.options,o=s.time,a=o.unit||n3(o.minUnit,i,r,this._getLabelCapacity(i)),l=ft(o.stepSize,1),c="week"===a&&o.isoWeekday,d=Eu(c)||!0===c,u={};let p,f,h=i;if(d&&(h=+e.startOf(h,"isoWeek",c)),h=+e.startOf(h,d?"day":a),e.diff(r,i,a)>1e5*l)throw new Error(i+" and "+r+" are too far apart with stepSize of "+l+" "+a);const m="data"===s.ticks.source&&this.getDataTimestamps();for(p=h,f=0;p<r;p=+e.add(p,l,a),f++)r3(u,p,m);return(p===r||"ticks"===s.bounds||1===f)&&r3(u,p,m),Object.keys(u).sort((g,_)=>g-_).map(g=>+g)}getLabelForValue(e){const r=this.options.time;return this._adapter.format(e,r.tooltipFormat?r.tooltipFormat:r.displayFormats.datetime)}_tickFormatFunction(e,i,r,s){const o=this.options,a=o.time.displayFormats,l=this._unit,c=this._majorUnit,u=c&&a[c],h=r[i],f=this._adapter.format(e,s||(c&&u&&h&&h.major?u:l&&a[l])),m=o.ticks.callback;return m?yn(m,[f,i,r],this):f}generateTickLabels(e){let i,r,s;for(i=0,r=e.length;i<r;++i)s=e[i],s.label=this._tickFormatFunction(s.value,i,e)}getDecimalForValue(e){return null===e?NaN:(e-this.min)/(this.max-this.min)}getPixelForValue(e){const i=this._offsets,r=this.getDecimalForValue(e);return this.getPixelForDecimal((i.start+r)*i.factor)}getValueForPixel(e){const i=this._offsets,r=this.getDecimalForPixel(e)/i.factor-i.end;return this.min+r*(this.max-this.min)}_getLabelSize(e){const i=this.options.ticks,r=this.ctx.measureText(e).width,s=mo(this.isHorizontal()?i.maxRotation:i.minRotation),o=Math.cos(s),a=Math.sin(s),l=this._resolveTickFontOptions(0).size;return{w:r*o+l*a,h:r*a+l*o}}_getLabelCapacity(e){const i=this.options.time,r=i.displayFormats,s=r[i.unit]||r.millisecond,o=this._tickFormatFunction(e,0,s3(this,[e],this._majorUnit),s),a=this._getLabelSize(o),l=Math.floor(this.isHorizontal()?this.width/a.w:this.height/a.h)-1;return l>0?l:1}getDataTimestamps(){let i,r,e=this._cache.data||[];if(e.length)return e;const s=this.getMatchingVisibleMetas();if(this._normalized&&s.length)return this._cache.data=s[0].controller.getAllParsedValues(this);for(i=0,r=s.length;i<r;++i)e=e.concat(s[i].controller.getAllParsedValues(this));return this._cache.data=this.normalize(e)}getLabelTimestamps(){const e=this._cache.labels||[];let i,r;if(e.length)return e;const s=this.getLabels();for(i=0,r=s.length;i<r;++i)e.push(t3(this,s[i]));return this._cache.labels=this._normalized?e:this.normalize(e)}normalize(e){return iB(e.sort(She))}}return n.id="time",n.defaults={bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",major:{enabled:!1}}},n})();function Ry(n,t,e){let s,o,a,l,i=0,r=n.length-1;e?(t>=n[i].pos&&t<=n[r].pos&&({lo:i,hi:r}=Na(n,"pos",t)),({pos:s,time:a}=n[i]),({pos:o,time:l}=n[r])):(t>=n[i].time&&t<=n[r].time&&({lo:i,hi:r}=Na(n,"time",t)),({time:s,pos:a}=n[i]),({time:o,pos:l}=n[r]));const c=o-s;return c?a+(l-a)*(t-s)/c:a}class oE extends sE{constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=Ry(e,this.min),this._tableRange=Ry(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:i}=this,r=[],s=[];let o,a,l,c,d;for(o=0,a=t.length;o<a;++o)c=t[o],c>=e&&c<=i&&r.push(c);if(r.length<2)return[{time:e,pos:0},{time:i,pos:1}];for(o=0,a=r.length;o<a;++o)d=r[o+1],l=r[o-1],c=r[o],Math.round((d+l)/2)!==c&&s.push({time:c,pos:o/(a-1)});return s}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),i=this.getLabelTimestamps();return t=e.length&&i.length?this.normalize(e.concat(i)):e.length?e:i,t=this._cache.all=t,t}getDecimalForValue(t){return(Ry(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return Ry(this._table,i*this._tableRange+this._minPos,!0)}}oE.id="timeseries",oE.defaults=sE.defaults;const Ahe=[hde,Due,che,Object.freeze({__proto__:null,CategoryScale:Ay,LinearScale:nE,LogarithmicScale:iE,RadialLinearScale:Ef,TimeScale:sE,TimeSeriesScale:oE})],Oy=function Rhe(n,t){return n===t||n!=n&&t!=t},Fy=function Ohe(n,t){for(var e=n.length;e--;)if(Oy(n[e][0],t))return e;return-1};var Phe=Array.prototype.splice;function Ru(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var i=n[t];this.set(i[0],i[1])}}Ru.prototype.clear=function Mhe(){this.__data__=[],this.size=0},Ru.prototype.delete=function Lhe(n){var t=this.__data__,e=Fy(t,n);return!(e<0||(e==t.length-1?t.pop():Phe.call(t,e,1),--this.size,0))},Ru.prototype.get=function Vhe(n){var t=this.__data__,e=Fy(t,n);return e<0?void 0:t[e][1]},Ru.prototype.has=function zhe(n){return Fy(this.__data__,n)>-1},Ru.prototype.set=function Hhe(n,t){var e=this.__data__,i=Fy(e,n);return i<0?(++this.size,e.push([n,t])):e[i][1]=t,this};const Py=Ru,o3="object"==typeof global&&global&&global.Object===Object&&global;var epe="object"==typeof self&&self&&self.Object===Object&&self;const Ou=o3||epe||Function("return this")();var npe=Ou.Symbol,a3=Object.prototype,ipe=a3.hasOwnProperty,rpe=a3.toString,If=npe?npe.toStringTag:void 0;var lpe=Object.prototype.toString;var l3=npe?npe.toStringTag:void 0;const $y=function ppe(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":l3&&l3 in Object(n)?function spe(n){var t=ipe.call(n,If),e=n[If];try{n[If]=void 0;var i=!0}catch{}var r=rpe.call(n);return i&&(t?n[If]=e:delete n[If]),r}(n):function cpe(n){return lpe.call(n)}(n)},jc=function fpe(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)};const aE=function ype(n){if(!jc(n))return!1;var t=$y(n);return"[object Function]"==t||"[object GeneratorFunction]"==t||"[object AsyncFunction]"==t||"[object Proxy]"==t};var n,vpe=Ou["__core-js_shared__"],c3=(n=/[^.]+$/.exec(vpe&&vpe.keys&&vpe.keys.IE_PROTO||""))?"Symbol(src)_1."+n:"";var Dpe=Function.prototype.toString;var Ipe=/^\[object .+?Constructor\]$/,Rpe=RegExp("^"+Function.prototype.toString.call(Object.prototype.hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");const Fpe=function Ope(n){return!(!jc(n)||function xpe(n){return!!c3&&c3 in n}(n))&&(aE(n)?Rpe:Ipe).test(function Spe(n){if(null!=n){try{return Dpe.call(n)}catch{}try{return n+""}catch{}}return""}(n))},cE=function $pe(n,t){var e=function Ppe(n,t){return n?.[t]}(n,t);return Fpe(e)?e:void 0},d3=cE(Ou,"Map"),Tf=cE(Object,"create");var qpe=Object.prototype.hasOwnProperty;var Zpe=Object.prototype.hasOwnProperty;function Fu(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var i=n[t];this.set(i[0],i[1])}}Fu.prototype.clear=function zpe(){this.__data__=Tf?Tf(null):{},this.size=0},Fu.prototype.delete=function Hpe(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t},Fu.prototype.get=function Ype(n){var t=this.__data__;if(Tf){var e=t[n];return"__lodash_hash_undefined__"===e?void 0:e}return qpe.call(t,n)?t[n]:void 0},Fu.prototype.has=function Qpe(n){var t=this.__data__;return Tf?void 0!==t[n]:Zpe.call(t,n)},Fu.prototype.set=function tfe(n,t){var e=this.__data__;return this.size+=this.has(n)?0:1,e[n]=Tf&&void 0===t?"__lodash_hash_undefined__":t,this};const u3=Fu,Vy=function afe(n,t){var e=n.__data__;return function sfe(n){var t=typeof n;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==n:null===n}(t)?e["string"==typeof t?"string":"hash"]:e.map};function Pu(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var i=n[t];this.set(i[0],i[1])}}Pu.prototype.clear=function ife(){this.size=0,this.__data__={hash:new u3,map:new(d3||Py),string:new u3}},Pu.prototype.delete=function lfe(n){var t=Vy(this,n).delete(n);return this.size-=t?1:0,t},Pu.prototype.get=function dfe(n){return Vy(this,n).get(n)},Pu.prototype.has=function hfe(n){return Vy(this,n).has(n)},Pu.prototype.set=function ffe(n,t){var e=Vy(this,n),i=e.size;return e.set(n,t),this.size+=e.size==i?0:1,this};const gfe=Pu;function Lu(n){var t=this.__data__=new Py(n);this.size=t.size}Lu.prototype.clear=function Whe(){this.__data__=new Py,this.size=0},Lu.prototype.delete=function qhe(n){var t=this.__data__,e=t.delete(n);return this.size=t.size,e},Lu.prototype.get=function Khe(n){return this.__data__.get(n)},Lu.prototype.has=function Zhe(n){return this.__data__.has(n)},Lu.prototype.set=function bfe(n,t){var e=this.__data__;if(e instanceof Py){var i=e.__data__;if(!d3||i.length<199)return i.push([n,t]),this.size=++e.size,this;e=this.__data__=new gfe(i)}return e.set(n,t),this.size=e.size,this};const vfe=Lu;var xfe=function(){try{var n=cE(Object,"defineProperty");return n({},"",{}),n}catch{}}();const By=xfe,dE=function wfe(n,t,e){"__proto__"==t&&By?By(n,t,{configurable:!0,enumerable:!0,value:e,writable:!0}):n[t]=e},uE=function Cfe(n,t,e){(void 0!==e&&!Oy(n[t],e)||void 0===e&&!(t in n))&&dE(n,t,e)};var Sfe=function Dfe(n){return function(t,e,i){for(var r=-1,s=Object(t),o=i(t),a=o.length;a--;){var l=o[n?a:++r];if(!1===e(s[l],l,s))break}return t}}();const kfe=Sfe;var h3="object"==typeof exports&&exports&&!exports.nodeType&&exports,p3=h3&&"object"==typeof module&&module&&!module.nodeType&&module,f3=p3&&p3.exports===h3?Ou.Buffer:void 0,m3=f3?f3.allocUnsafe:void 0;const g3=Ou.Uint8Array,Ofe=function Rfe(n,t){var e=t?function Mfe(n){var t=new n.constructor(n.byteLength);return new g3(t).set(new g3(n)),t}(n.buffer):n.buffer;return new n.constructor(e,n.byteOffset,n.length)};var _3=Object.create,Lfe=function(){function n(){}return function(t){if(!jc(t))return{};if(_3)return _3(t);n.prototype=t;var e=new n;return n.prototype=void 0,e}}();const $fe=Lfe;var Bfe=function Vfe(n,t){return function(e){return n(t(e))}}(Object.getPrototypeOf,Object);const b3=Bfe;var zfe=Object.prototype;const y3=function Ufe(n){var t=n&&n.constructor;return n===("function"==typeof t&&t.prototype||zfe)},Af=function Wfe(n){return null!=n&&"object"==typeof n};const v3=function qfe(n){return Af(n)&&"[object Arguments]"==$y(n)};var x3=Object.prototype,Yfe=x3.hasOwnProperty,Kfe=x3.propertyIsEnumerable,Xfe=v3(function(){return arguments}())?v3:function(n){return Af(n)&&Yfe.call(n,"callee")&&!Kfe.call(n,"callee")};const hE=Xfe,pE=Array.isArray;const w3=function Jfe(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991},fE=function eme(n){return null!=n&&w3(n.length)&&!aE(n)};var C3="object"==typeof exports&&exports&&!exports.nodeType&&exports,D3=C3&&"object"==typeof module&&module&&!module.nodeType&&module,S3=D3&&D3.exports===C3?Ou.Buffer:void 0;const k3=(S3?S3.isBuffer:void 0)||function ime(){return!1};var E3=Function.prototype.toString,ume=Object.prototype.hasOwnProperty,hme=E3.call(Object);var Sn={};Sn["[object Float32Array]"]=Sn["[object Float64Array]"]=Sn["[object Int8Array]"]=Sn["[object Int16Array]"]=Sn["[object Int32Array]"]=Sn["[object Uint8Array]"]=Sn["[object Uint8ClampedArray]"]=Sn["[object Uint16Array]"]=Sn["[object Uint32Array]"]=!0,Sn["[object Arguments]"]=Sn["[object Array]"]=Sn["[object ArrayBuffer]"]=Sn["[object Boolean]"]=Sn["[object DataView]"]=Sn["[object Date]"]=Sn["[object Error]"]=Sn["[object Function]"]=Sn["[object Map]"]=Sn["[object Number]"]=Sn["[object Object]"]=Sn["[object RegExp]"]=Sn["[object Set]"]=Sn["[object String]"]=Sn["[object WeakMap]"]=!1;var I3="object"==typeof exports&&exports&&!exports.nodeType&&exports,Mf=I3&&"object"==typeof module&&module&&!module.nodeType&&module,mE=Mf&&Mf.exports===I3&&o3.process,jme=function(){try{return Mf&&Mf.require&&Mf.require("util").types||mE&&mE.binding&&mE.binding("util")}catch{}}(),A3=jme&&jme.isTypedArray;const M3=A3?function zme(n){return function(t){return n(t)}}(A3):function Vme(n){return Af(n)&&w3(n.length)&&!!Sn[$y(n)]},gE=function Gme(n,t){if(("constructor"!==t||"function"!=typeof n[t])&&"__proto__"!=t)return n[t]};var Yme=Object.prototype.hasOwnProperty;const Xme=function Kme(n,t,e){var i=n[t];(!Yme.call(n,t)||!Oy(i,e)||void 0===e&&!(t in n))&&dE(n,t,e)};var nge=/^(?:0|[1-9]\d*)$/;const N3=function ige(n,t){var e=typeof n;return!!(t=t??9007199254740991)&&("number"==e||"symbol"!=e&&nge.test(n))&&n>-1&&n%1==0&&n<t};var sge=Object.prototype.hasOwnProperty;const age=function oge(n,t){var e=pE(n),i=!e&&hE(n),r=!e&&!i&&k3(n),s=!e&&!i&&!r&&M3(n),o=e||i||r||s,a=o?function Jme(n,t){for(var e=-1,i=Array(n);++e<n;)i[e]=t(e);return i}(n.length,String):[],l=a.length;for(var c in n)(t||sge.call(n,c))&&(!o||!("length"==c||r&&("offset"==c||"parent"==c)||s&&("buffer"==c||"byteLength"==c||"byteOffset"==c)||N3(c,l)))&&a.push(c);return a};var uge=Object.prototype.hasOwnProperty;const pge=function hge(n){if(!jc(n))return function lge(n){var t=[];if(null!=n)for(var e in Object(n))t.push(e);return t}(n);var t=y3(n),e=[];for(var i in n)"constructor"==i&&(t||!uge.call(n,i))||e.push(i);return e},R3=function fge(n){return fE(n)?age(n,!0):pge(n)},gge=function mge(n){return function Zme(n,t,e,i){var r=!e;e||(e={});for(var s=-1,o=t.length;++s<o;){var a=t[s],l=i?i(e[a],n[a],a,e,n):void 0;void 0===l&&(l=n[a]),r?dE(e,a,l):Xme(e,a,l)}return e}(n,R3(n))},bge=function _ge(n,t,e,i,r,s,o){var a=gE(n,e),l=gE(t,e),c=o.get(l);if(c)uE(n,e,c);else{var d=s?s(a,l,e+"",n,t,o):void 0,u=void 0===d;if(u){var h=pE(l),p=!h&&k3(l),f=!h&&!p&&M3(l);d=l,h||p||f?pE(a)?d=a:function tme(n){return Af(n)&&fE(n)}(a)?d=function Ffe(n,t){var e=-1,i=n.length;for(t||(t=Array(i));++e<i;)t[e]=n[e];return t}(a):p?(u=!1,d=function Ife(n,t){if(t)return n.slice();var e=n.length,i=m3?m3(e):new n.constructor(e);return n.copy(i),i}(l,!0)):f?(u=!1,d=Ofe(l,!0)):d=[]:function pme(n){if(!Af(n)||"[object Object]"!=$y(n))return!1;var t=b3(n);if(null===t)return!0;var e=ume.call(t,"constructor")&&t.constructor;return"function"==typeof e&&e instanceof e&&E3.call(e)==hme}(l)||hE(l)?(d=a,hE(a)?d=gge(a):(!jc(a)||aE(a))&&(d=function Hfe(n){return"function"!=typeof n.constructor||y3(n)?{}:$fe(b3(n))}(l))):u=!1}u&&(o.set(l,d),r(d,l,i,s,o),o.delete(l)),uE(n,e,d)}},yge=function O3(n,t,e,i,r){n!==t&&kfe(t,function(s,o){if(r||(r=new vfe),jc(s))bge(n,t,o,e,O3,i,r);else{var a=i?i(gE(n,o),s,o+"",n,t,r):void 0;void 0===a&&(a=s),uE(n,o,a)}},R3)},F3=function vge(n){return n},wge=function xge(n,t,e){switch(e.length){case 0:return n.call(t);case 1:return n.call(t,e[0]);case 2:return n.call(t,e[0],e[1]);case 3:return n.call(t,e[0],e[1],e[2])}return n.apply(t,e)};var P3=Math.max;const kge=function Sge(n){return function(){return n}};var Ege=By?function(n,t){return By(n,"toString",{configurable:!0,enumerable:!1,value:kge(t),writable:!0})}:F3,Tge=800,Age=16,Mge=Date.now,Rge=function Nge(n){var t=0,e=0;return function(){var i=Mge(),r=Age-(i-e);if(e=i,r>0){if(++t>=Tge)return arguments[0]}else t=0;return n.apply(void 0,arguments)}}(Ege);const Oge=Rge,Pge=function Fge(n,t){return Oge(function Cge(n,t,e){return t=P3(void 0===t?n.length-1:t,0),function(){for(var i=arguments,r=-1,s=P3(i.length-t,0),o=Array(s);++r<s;)o[r]=i[t+r];r=-1;for(var a=Array(t+1);++r<t;)a[r]=i[r];return a[t]=e(o),wge(n,this,a)}}(n,t,F3),n+"")};var Bge=function Vge(n){return Pge(function(t,e){var i=-1,r=e.length,s=r>1?e[r-1]:void 0,o=r>2?e[2]:void 0;for(s=n.length>3&&"function"==typeof s?(r--,s):void 0,o&&function Lge(n,t,e){if(!jc(e))return!1;var i=typeof t;return!!("number"==i?fE(e)&&N3(t,e.length):"string"==i&&t in e)&&Oy(e[t],n)}(e[0],e[1],o)&&(s=r<3?void 0:s,r=1),t=Object(t);++i<r;){var a=e[i];a&&n(t,a,i,s)}return t})}(function(n,t,e){yge(n,t,e)});const L3=Bge;let zge=(()=>{class n{constructor(){this.colorschemesOptions=new ls(void 0)}setColorschemesOptions(e){this.pColorschemesOptions=e,this.colorschemesOptions.next(e)}getColorschemesOptions(){return this.pColorschemesOptions}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Uge=(()=>{class n{constructor(e,i,r){this.zone=i,this.themeService=r,this.type="bar",this.plugins=[],this.chartClick=new $t,this.chartHover=new $t,this.subs=[],this.themeOverrides={},this.ctx=e.nativeElement.getContext("2d"),this.subs.push(this.themeService.colorschemesOptions.pipe(s$()).subscribe(s=>this.themeChanged(s)))}ngOnChanges(e){const i=["type"],r=Object.getOwnPropertyNames(e);if(r.some(s=>i.includes(s))||r.every(s=>e[s].isFirstChange()))this.render();else{const s=this.getChartConfiguration();this.chart&&(Object.assign(this.chart.config.data,s.data),this.chart.config.plugins&&Object.assign(this.chart.config.plugins,s.plugins),this.chart.config.options&&Object.assign(this.chart.config.options,s.options)),this.update()}}ngOnDestroy(){this.chart&&(this.chart.destroy(),this.chart=void 0),this.subs.forEach(e=>e.unsubscribe())}render(){return this.chart&&this.chart.destroy(),this.zone.runOutsideAngular(()=>this.chart=new Sf(this.ctx,this.getChartConfiguration()))}update(e){this.chart&&this.zone.runOutsideAngular(()=>this.chart?.update(e))}hideDataset(e,i){this.chart&&(this.chart.getDatasetMeta(e).hidden=i,this.update())}isDatasetHidden(e){return this.chart?.getDatasetMeta(e)?.hidden}toBase64Image(){return this.chart?.toBase64Image()}themeChanged(e){this.themeOverrides=e,this.chart&&(this.chart.config.options&&Object.assign(this.chart.config.options,this.getChartOptions()),this.update())}getChartOptions(){return L3({onHover:(e,i)=>{!this.chartHover.observed&&!this.chartHover.observers?.length||this.zone.run(()=>this.chartHover.emit({event:e,active:i}))},onClick:(e,i)=>{!this.chartClick.observed&&!this.chartClick.observers?.length||this.zone.run(()=>this.chartClick.emit({event:e,active:i}))}},this.themeOverrides,this.options,{plugins:{legend:{display:this.legend}}})}getChartConfiguration(){return{type:this.type,data:this.getChartData(),options:this.getChartOptions(),plugins:this.plugins}}getChartData(){return this.data?this.data:{labels:this.labels||[],datasets:this.datasets||[]}}}return n.\u0275fac=function(e){return new(e||n)(V(Pt),V(Qe),V(zge))},n.\u0275dir=we({type:n,selectors:[["canvas","baseChart",""]],inputs:{type:"type",legend:"legend",data:"data",options:"options",plugins:"plugins",labels:"labels",datasets:"datasets"},outputs:{chartClick:"chartClick",chartHover:"chartHover"},exportAs:["base-chart"],features:[rr]}),n})();const Hge=[[255,99,132],[54,162,235],[255,206,86],[231,233,237],[75,192,192],[151,187,205],[220,220,220],[247,70,74],[70,191,189],[253,180,92],[148,159,177],[77,83,96]],jge={plugins:{colors:{enabled:!1}},datasets:{line:{backgroundColor:n=>vl(xl(n.datasetIndex),.4),borderColor:n=>vl(xl(n.datasetIndex),1),pointBackgroundColor:n=>vl(xl(n.datasetIndex),1),pointBorderColor:"#fff"},bar:{backgroundColor:n=>vl(xl(n.datasetIndex),.6),borderColor:n=>vl(xl(n.datasetIndex),1)},get radar(){return this.line},doughnut:{backgroundColor:n=>vl(xl(n.dataIndex),.6),borderColor:"#fff"},get pie(){return this.doughnut},polarArea:{backgroundColor:n=>vl(xl(n.dataIndex),.6),borderColor:n=>vl(xl(n.dataIndex),1)},get bubble(){return this.doughnut},get scatter(){return this.doughnut},get area(){return this.polarArea}}};function vl(n,t){return"rgba("+n.concat(t).join(",")+")"}function _E(n,t){return Math.floor(Math.random()*(t-n+1))+n}function xl(n=0){return Hge[n]||function Wge(){return[_E(0,255),_E(0,255),_E(0,255)]}()}let $3=(()=>{class n{constructor(){this.generateColors=!0}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();Sf.register(...Ahe);let Gge=(()=>{class n{constructor(e){e?.plugins&&Sf.register(...e?.plugins);const i=L3(e?.generateColors?jge:{},e?.defaults||{});At.set(i)}static forRoot(e){return{ngModule:n,providers:[{provide:$3,useValue:e}]}}}return n.\u0275fac=function(e){return new(e||n)(Y($3,8))},n.\u0275mod=ut({type:n}),n.\u0275inj=at({}),n})();const zy=Ve(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"});function $u(n,t){const e=ke(n)?n:()=>n,i=r=>r.error(e());return new Ze(t?r=>t.schedule(i,0,r):i)}function bE(){return Hn((n,t)=>{let e=null;n._refCount++;const i=Tn(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount)return void(e=null);const r=n._connection,s=e;e=null,r&&(!s||r===s)&&r.unsubscribe(),t.unsubscribe()});n.subscribe(i),i.closed||(e=n.connect())})}class V3 extends Ze{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,tN(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new U;const e=this.getSubject();t.add(this.source.subscribe(Tn(e,void 0,()=>{this._teardown(),e.complete()},i=>{this._teardown(),e.error(i)},()=>this._teardown()))),t.closed&&(this._connection=null,t=U.EMPTY)}return t}refCount(){return bE()(this)}}function qo(n,t){return Hn((e,i)=>{let r=null,s=0,o=!1;const a=()=>o&&!r&&i.complete();e.subscribe(Tn(i,l=>{r?.unsubscribe();let c=0;const d=s++;Cr(n(l,d)).subscribe(r=Tn(i,u=>i.next(t?t(l,u,d,c++):u),()=>{r=null,a()}))},()=>{o=!0,a()}))})}function Uy(n){return Hn((t,e)=>{let i=!1;t.subscribe(Tn(e,r=>{i=!0,e.next(r)},()=>{i||e.next(n),e.complete()}))})}function B3(n=qge){return Hn((t,e)=>{let i=!1;t.subscribe(Tn(e,r=>{i=!0,e.next(r)},()=>i?e.complete():e.error(n())))})}function qge(){return new zy}function wl(n,t){const e=arguments.length>=2;return i=>i.pipe(n?lr((r,s)=>n(r,s,i)):wn,fo(1),e?Uy(t):B3(()=>new zy))}function Cl(n,t){return ke(t)?Pi(n,t,1):Pi(n,1)}function Pa(n){return Hn((t,e)=>{let s,i=null,r=!1;i=t.subscribe(Tn(e,void 0,void 0,o=>{s=Cr(n(o,Pa(n)(t))),i?(i.unsubscribe(),i=null,s.subscribe(e)):r=!0})),r&&(i.unsubscribe(),i=null,s.subscribe(e))})}function z3(n,t){return Hn(function Yge(n,t,e,i,r){return(s,o)=>{let a=e,l=t,c=0;s.subscribe(Tn(o,d=>{const u=c++;l=a?n(l,d,u):(a=!0,d),i&&o.next(l)},r&&(()=>{a&&o.next(l),o.complete()})))}}(n,t,arguments.length>=2,!0))}function yE(n){return n<=0?()=>Mo:Hn((t,e)=>{let i=[];t.subscribe(Tn(e,r=>{i.push(r),n<i.length&&i.shift()},()=>{for(const r of i)e.next(r);e.complete()},void 0,()=>{i=null}))})}function U3(n,t){const e=arguments.length>=2;return i=>i.pipe(n?lr((r,s)=>n(r,s,i)):wn,yE(1),e?Uy(t):B3(()=>new zy))}function Hy(n){return Hn((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}const st="primary",Nf=Symbol("RouteTitle");class Zge{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function Vu(n){return new Zge(n)}function Qge(n,t,e){const i=e.path.split("/");if(i.length>n.length||"full"===e.pathMatch&&(t.hasChildren()||i.length<n.length))return null;const r={};for(let s=0;s<i.length;s++){const o=i[s],a=n[s];if(o.startsWith(":"))r[o.substring(1)]=a;else if(o!==a.path)return null}return{consumed:n.slice(0,i.length),posParams:r}}function Yo(n,t){const e=n?Object.keys(n):void 0,i=t?Object.keys(t):void 0;if(!e||!i||e.length!=i.length)return!1;let r;for(let s=0;s<e.length;s++)if(r=e[s],!H3(n[r],t[r]))return!1;return!0}function H3(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),i=[...t].sort();return e.every((r,s)=>i[s]===r)}return n===t}function j3(n){return Array.prototype.concat.apply([],n)}function W3(n){return n.length>0?n[n.length-1]:null}function Ki(n,t){for(const e in n)n.hasOwnProperty(e)&&t(n[e],e)}function Dl(n){return hD(n)?n:Cp(n)?oi(Promise.resolve(n)):Fe(n)}const jy=!1,e_e={exact:function Y3(n,t,e){if(!Wc(n.segments,t.segments)||!Wy(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const i in t.children)if(!n.children[i]||!Y3(n.children[i],t.children[i],e))return!1;return!0},subset:K3},G3={exact:function t_e(n,t){return Yo(n,t)},subset:function n_e(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>H3(n[e],t[e]))},ignored:()=>!0};function q3(n,t,e){return e_e[e.paths](n.root,t.root,e.matrixParams)&&G3[e.queryParams](n.queryParams,t.queryParams)&&!("exact"===e.fragment&&n.fragment!==t.fragment)}function K3(n,t,e){return X3(n,t,t.segments,e)}function X3(n,t,e,i){if(n.segments.length>e.length){const r=n.segments.slice(0,e.length);return!(!Wc(r,e)||t.hasChildren()||!Wy(r,e,i))}if(n.segments.length===e.length){if(!Wc(n.segments,e)||!Wy(n.segments,e,i))return!1;for(const r in t.children)if(!n.children[r]||!K3(n.children[r],t.children[r],i))return!1;return!0}{const r=e.slice(0,n.segments.length),s=e.slice(n.segments.length);return!!(Wc(n.segments,r)&&Wy(n.segments,r,i)&&n.children[st])&&X3(n.children[st],t,s,i)}}function Wy(n,t,e){return t.every((i,r)=>G3[e](n[r].parameters,i.parameters))}class Sl{constructor(t=new Ct([],{}),e={},i=null){this.root=t,this.queryParams=e,this.fragment=i}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Vu(this.queryParams)),this._queryParamMap}toString(){return s_e.serialize(this)}}class Ct{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Ki(e,(i,r)=>i.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Gy(this)}}class Rf{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=Vu(this.parameters)),this._parameterMap}toString(){return J3(this)}}function Wc(n,t){return n.length===t.length&&n.every((e,i)=>e.path===t[i].path)}let Of=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:function(){return new vE},providedIn:"root"}),n})();class vE{parse(t){const e=new f_e(t);return new Sl(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){const e=`/${Ff(t.root,!0)}`,i=function l_e(n){const t=Object.keys(n).map(e=>{const i=n[e];return Array.isArray(i)?i.map(r=>`${qy(e)}=${qy(r)}`).join("&"):`${qy(e)}=${qy(i)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(t.queryParams),r="string"==typeof t.fragment?`#${function o_e(n){return encodeURI(n)}(t.fragment)}`:"";return`${e}${i}${r}`}}const s_e=new vE;function Gy(n){return n.segments.map(t=>J3(t)).join("/")}function Ff(n,t){if(!n.hasChildren())return Gy(n);if(t){const e=n.children[st]?Ff(n.children[st],!1):"",i=[];return Ki(n.children,(r,s)=>{s!==st&&i.push(`${s}:${Ff(r,!1)}`)}),i.length>0?`${e}(${i.join("//")})`:e}{const e=function r_e(n,t){let e=[];return Ki(n.children,(i,r)=>{r===st&&(e=e.concat(t(i,r)))}),Ki(n.children,(i,r)=>{r!==st&&(e=e.concat(t(i,r)))}),e}(n,(i,r)=>r===st?[Ff(n.children[st],!1)]:[`${r}:${Ff(i,!1)}`]);return 1===Object.keys(n.children).length&&null!=n.children[st]?`${Gy(n)}/${e[0]}`:`${Gy(n)}/(${e.join("//")})`}}function Z3(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function qy(n){return Z3(n).replace(/%3B/gi,";")}function xE(n){return Z3(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Yy(n){return decodeURIComponent(n)}function Q3(n){return Yy(n.replace(/\+/g,"%20"))}function J3(n){return`${xE(n.path)}${function a_e(n){return Object.keys(n).map(t=>`;${xE(t)}=${xE(n[t])}`).join("")}(n.parameters)}`}const c_e=/^[^\/()?;=#]+/;function Ky(n){const t=n.match(c_e);return t?t[0]:""}const d_e=/^[^=?&#]+/,h_e=/^[^&#]+/;class f_e{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Ct([],{}):new Ct([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let i={};return this.peekStartsWith("(")&&(i=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(i[st]=new Ct(t,e)),i}parseSegment(){const t=Ky(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new Q(4009,jy);return this.capture(t),new Rf(Yy(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=Ky(this.remaining);if(!e)return;this.capture(e);let i="";if(this.consumeOptional("=")){const r=Ky(this.remaining);r&&(i=r,this.capture(i))}t[Yy(e)]=Yy(i)}parseQueryParam(t){const e=function u_e(n){const t=n.match(d_e);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let i="";if(this.consumeOptional("=")){const o=function p_e(n){const t=n.match(h_e);return t?t[0]:""}(this.remaining);o&&(i=o,this.capture(i))}const r=Q3(e),s=Q3(i);if(t.hasOwnProperty(r)){let o=t[r];Array.isArray(o)||(o=[o],t[r]=o),o.push(s)}else t[r]=s}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const i=Ky(this.remaining),r=this.remaining[i.length];if("/"!==r&&")"!==r&&";"!==r)throw new Q(4010,jy);let s;i.indexOf(":")>-1?(s=i.slice(0,i.indexOf(":")),this.capture(s),this.capture(":")):t&&(s=st);const o=this.parseChildren();e[s]=1===Object.keys(o).length?o[st]:new Ct([],o),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Q(4011,jy)}}function wE(n){return n.segments.length>0?new Ct([],{[st]:n}):n}function Xy(n){const t={};for(const i of Object.keys(n.children)){const s=Xy(n.children[i]);(s.segments.length>0||s.hasChildren())&&(t[i]=s)}return function m_e(n){if(1===n.numberOfChildren&&n.children[st]){const t=n.children[st];return new Ct(n.segments.concat(t.segments),t.children)}return n}(new Ct(n.segments,t))}function Gc(n){return n instanceof Sl}const CE=!1;function g_e(n,t,e,i,r){if(0===e.length)return Bu(t.root,t.root,t.root,i,r);const s=function rU(n){if("string"==typeof n[0]&&1===n.length&&"/"===n[0])return new iU(!0,0,n);let t=0,e=!1;const i=n.reduce((r,s,o)=>{if("object"==typeof s&&null!=s){if(s.outlets){const a={};return Ki(s.outlets,(l,c)=>{a[c]="string"==typeof l?l.split("/"):l}),[...r,{outlets:a}]}if(s.segmentPath)return[...r,s.segmentPath]}return"string"!=typeof s?[...r,s]:0===o?(s.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?t++:""!=a&&r.push(a))}),r):[...r,s]},[]);return new iU(e,t,i)}(e);return s.toRoot()?Bu(t.root,t.root,new Ct([],{}),i,r):function o(l){const c=function b_e(n,t,e,i){if(n.isAbsolute)return new zu(t.root,!0,0);if(-1===i)return new zu(e,e===t.root,0);return function sU(n,t,e){let i=n,r=t,s=e;for(;s>r;){if(s-=r,i=i.parent,!i)throw new Q(4005,CE&&"Invalid number of '../'");r=i.segments.length}return new zu(i,!1,r-s)}(e,i+(Pf(n.commands[0])?0:1),n.numberOfDoubleDots)}(s,t,n.snapshot?._urlSegment,l),d=c.processChildren?Uu(c.segmentGroup,c.index,s.commands):DE(c.segmentGroup,c.index,s.commands);return Bu(t.root,c.segmentGroup,d,i,r)}(n.snapshot?._lastPathIndex)}function Pf(n){return"object"==typeof n&&null!=n&&!n.outlets&&!n.segmentPath}function Lf(n){return"object"==typeof n&&null!=n&&n.outlets}function Bu(n,t,e,i,r){let o,s={};i&&Ki(i,(l,c)=>{s[c]=Array.isArray(l)?l.map(d=>`${d}`):`${l}`}),o=n===t?e:nU(n,t,e);const a=wE(Xy(o));return new Sl(a,s,r)}function nU(n,t,e){const i={};return Ki(n.children,(r,s)=>{i[s]=r===t?e:nU(r,t,e)}),new Ct(n.segments,i)}class iU{constructor(t,e,i){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=i,t&&i.length>0&&Pf(i[0]))throw new Q(4003,CE&&"Root segment cannot have matrix parameters");const r=i.find(Lf);if(r&&r!==W3(i))throw new Q(4004,CE&&"{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class zu{constructor(t,e,i){this.segmentGroup=t,this.processChildren=e,this.index=i}}function DE(n,t,e){if(n||(n=new Ct([],{})),0===n.segments.length&&n.hasChildren())return Uu(n,t,e);const i=function v_e(n,t,e){let i=0,r=t;const s={match:!1,pathIndex:0,commandIndex:0};for(;r<n.segments.length;){if(i>=e.length)return s;const o=n.segments[r],a=e[i];if(Lf(a))break;const l=`${a}`,c=i<e.length-1?e[i+1]:null;if(r>0&&void 0===l)break;if(l&&c&&"object"==typeof c&&void 0===c.outlets){if(!aU(l,c,o))return s;i+=2}else{if(!aU(l,{},o))return s;i++}r++}return{match:!0,pathIndex:r,commandIndex:i}}(n,t,e),r=e.slice(i.commandIndex);if(i.match&&i.pathIndex<n.segments.length){const s=new Ct(n.segments.slice(0,i.pathIndex),{});return s.children[st]=new Ct(n.segments.slice(i.pathIndex),n.children),Uu(s,0,r)}return i.match&&0===r.length?new Ct(n.segments,{}):i.match&&!n.hasChildren()?SE(n,t,e):i.match?Uu(n,0,r):SE(n,t,e)}function Uu(n,t,e){if(0===e.length)return new Ct(n.segments,{});{const i=function y_e(n){return Lf(n[0])?n[0].outlets:{[st]:n}}(e),r={};return!i[st]&&n.children[st]&&1===n.numberOfChildren&&0===n.children[st].segments.length?Uu(n.children[st],t,e):(Ki(i,(s,o)=>{"string"==typeof s&&(s=[s]),null!==s&&(r[o]=DE(n.children[o],t,s))}),Ki(n.children,(s,o)=>{void 0===i[o]&&(r[o]=s)}),new Ct(n.segments,r))}}function SE(n,t,e){const i=n.segments.slice(0,t);let r=0;for(;r<e.length;){const s=e[r];if(Lf(s)){const l=x_e(s.outlets);return new Ct(i,l)}if(0===r&&Pf(e[0])){i.push(new Rf(n.segments[t].path,oU(e[0]))),r++;continue}const o=Lf(s)?s.outlets[st]:`${s}`,a=r<e.length-1?e[r+1]:null;o&&a&&Pf(a)?(i.push(new Rf(o,oU(a))),r+=2):(i.push(new Rf(o,{})),r++)}return new Ct(i,{})}function x_e(n){const t={};return Ki(n,(e,i)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[i]=SE(new Ct([],{}),0,e))}),t}function oU(n){const t={};return Ki(n,(e,i)=>t[i]=`${e}`),t}function aU(n,t,e){return n==e.path&&Yo(t,e.parameters)}const $f="imperative";class Ko{constructor(t,e){this.id=t,this.url=e}}class kE extends Ko{constructor(t,e,i="imperative",r=null){super(t,e),this.type=0,this.navigationTrigger=i,this.restoredState=r}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class qc extends Ko{constructor(t,e,i){super(t,e),this.urlAfterRedirects=i,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Zy extends Ko{constructor(t,e,i,r){super(t,e),this.reason=i,this.code=r,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Qy extends Ko{constructor(t,e,i,r){super(t,e),this.reason=i,this.code=r,this.type=16}}class EE extends Ko{constructor(t,e,i,r){super(t,e),this.error=i,this.target=r,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class w_e extends Ko{constructor(t,e,i,r){super(t,e),this.urlAfterRedirects=i,this.state=r,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class C_e extends Ko{constructor(t,e,i,r){super(t,e),this.urlAfterRedirects=i,this.state=r,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class D_e extends Ko{constructor(t,e,i,r,s){super(t,e),this.urlAfterRedirects=i,this.state=r,this.shouldActivate=s,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class S_e extends Ko{constructor(t,e,i,r){super(t,e),this.urlAfterRedirects=i,this.state=r,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class k_e extends Ko{constructor(t,e,i,r){super(t,e),this.urlAfterRedirects=i,this.state=r,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class E_e{constructor(t){this.route=t,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class I_e{constructor(t){this.route=t,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class T_e{constructor(t){this.snapshot=t,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class A_e{constructor(t){this.snapshot=t,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class M_e{constructor(t){this.snapshot=t,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class N_e{constructor(t){this.snapshot=t,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class lU{constructor(t,e,i){this.routerEvent=t,this.position=e,this.anchor=i,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}let F_e=(()=>{class n{createUrlTree(e,i,r,s,o,a){return g_e(e||i.root,r,s,o,a)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})(),L_e=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:function(t){return F_e.\u0275fac(t)},providedIn:"root"}),n})();class cU{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=IE(t,this._root);return e?e.children.map(i=>i.value):[]}firstChild(t){const e=IE(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=TE(t,this._root);return e.length<2?[]:e[e.length-2].children.map(r=>r.value).filter(r=>r!==t)}pathFromRoot(t){return TE(t,this._root).map(e=>e.value)}}function IE(n,t){if(n===t.value)return t;for(const e of t.children){const i=IE(n,e);if(i)return i}return null}function TE(n,t){if(n===t.value)return[t];for(const e of t.children){const i=TE(n,e);if(i.length)return i.unshift(t),i}return[]}class La{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function Hu(n){const t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}class dU extends cU{constructor(t,e){super(t),this.snapshot=e,AE(this,t)}toString(){return this.snapshot.toString()}}function uU(n,t){const e=function $_e(n,t){const o=new Jy([],{},{},"",{},st,t,null,n.root,-1,{});return new pU("",new La(o,[]))}(n,t),i=new ls([new Rf("",{})]),r=new ls({}),s=new ls({}),o=new ls({}),a=new ls(""),l=new ju(i,r,o,a,s,st,t,e.root);return l.snapshot=e.root,new dU(new La(l,[]),e)}class ju{constructor(t,e,i,r,s,o,a,l){this.url=t,this.params=e,this.queryParams=i,this.fragment=r,this.data=s,this.outlet=o,this.component=a,this.title=this.data?.pipe(Ye(c=>c[Nf]))??Fe(void 0),this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(Ye(t=>Vu(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(Ye(t=>Vu(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function hU(n,t="emptyOnly"){const e=n.pathFromRoot;let i=0;if("always"!==t)for(i=e.length-1;i>=1;){const r=e[i],s=e[i-1];if(r.routeConfig&&""===r.routeConfig.path)i--;else{if(s.component)break;i--}}return function V_e(n){return n.reduce((t,e)=>({params:{...t.params,...e.params},data:{...t.data,...e.data},resolve:{...e.data,...t.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(i))}class Jy{get title(){return this.data?.[Nf]}constructor(t,e,i,r,s,o,a,l,c,d,u){this.url=t,this.params=e,this.queryParams=i,this.fragment=r,this.data=s,this.outlet=o,this.component=a,this.routeConfig=l,this._urlSegment=c,this._lastPathIndex=d,this._resolve=u}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Vu(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Vu(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(i=>i.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class pU extends cU{constructor(t,e){super(e),this.url=t,AE(this,e)}toString(){return fU(this._root)}}function AE(n,t){t.value._routerState=n,t.children.forEach(e=>AE(n,e))}function fU(n){const t=n.children.length>0?` { ${n.children.map(fU).join(", ")} } `:"";return`${n.value}${t}`}function ME(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,Yo(t.queryParams,e.queryParams)||n.queryParams.next(e.queryParams),t.fragment!==e.fragment&&n.fragment.next(e.fragment),Yo(t.params,e.params)||n.params.next(e.params),function Jge(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!Yo(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.url.next(e.url),Yo(t.data,e.data)||n.data.next(e.data)}else n.snapshot=n._futureSnapshot,n.data.next(n._futureSnapshot.data)}function NE(n,t){const e=Yo(n.params,t.params)&&function i_e(n,t){return Wc(n,t)&&n.every((e,i)=>Yo(e.parameters,t[i].parameters))}(n.url,t.url);return e&&!(!n.parent!=!t.parent)&&(!n.parent||NE(n.parent,t.parent))}function Vf(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){const i=e.value;i._futureSnapshot=t.value;const r=function z_e(n,t,e){return t.children.map(i=>{for(const r of e.children)if(n.shouldReuseRoute(i.value,r.value.snapshot))return Vf(n,i,r);return Vf(n,i)})}(n,t,e);return new La(i,r)}{if(n.shouldAttach(t.value)){const s=n.retrieve(t.value);if(null!==s){const o=s.route;return o.value._futureSnapshot=t.value,o.children=t.children.map(a=>Vf(n,a)),o}}const i=function U_e(n){return new ju(new ls(n.url),new ls(n.params),new ls(n.queryParams),new ls(n.fragment),new ls(n.data),n.outlet,n.component,n)}(t.value),r=t.children.map(s=>Vf(n,s));return new La(i,r)}}const RE="ngNavigationCancelingError";function mU(n,t){const{redirectTo:e,navigationBehaviorOptions:i}=Gc(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,r=gU(!1,0,t);return r.url=e,r.navigationBehaviorOptions=i,r}function gU(n,t,e){const i=new Error("NavigationCancelingError: "+(n||""));return i[RE]=!0,i.cancellationCode=t,e&&(i.url=e),i}function _U(n){return bU(n)&&Gc(n.url)}function bU(n){return n&&n[RE]}class H_e{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.injector=null,this.children=new Bf,this.attachRef=null}}let Bf=(()=>{class n{constructor(){this.contexts=new Map}onChildOutletCreated(e,i){const r=this.getOrCreateContext(e);r.outlet=i,this.contexts.set(e,r)}onChildOutletDestroyed(e){const i=this.getContext(e);i&&(i.outlet=null,i.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let i=this.getContext(e);return i||(i=new H_e,this.contexts.set(e,i)),i}getContext(e){return this.contexts.get(e)||null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const ev=!1;let OE=(()=>{class n{constructor(){this.activated=null,this._activatedRoute=null,this.name=st,this.activateEvents=new $t,this.deactivateEvents=new $t,this.attachEvents=new $t,this.detachEvents=new $t,this.parentContexts=lt(Bf),this.location=lt(As),this.changeDetector=lt(_u),this.environmentInjector=lt(va)}ngOnChanges(e){if(e.name){const{firstChange:i,previousValue:r}=e.name;if(i)return;this.isTrackedInParentContexts(r)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(r)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Q(4012,ev);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Q(4012,ev);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Q(4012,ev);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,i){this.activated=e,this._activatedRoute=i,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,i){if(this.isActivated)throw new Q(4013,ev);this._activatedRoute=e;const r=this.location,o=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new j_e(e,a,r.injector);if(i&&function W_e(n){return!!n.resolveComponentFactory}(i)){const c=i.resolveComponentFactory(o);this.activated=r.createComponent(c,r.length,l)}else this.activated=r.createComponent(o,{index:r.length,injector:l,environmentInjector:i??this.environmentInjector});this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=we({type:n,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[rr]}),n})();class j_e{constructor(t,e,i){this.route=t,this.childContexts=e,this.parent=i}get(t,e){return t===ju?this.route:t===Bf?this.childContexts:this.parent.get(t,e)}}let FE=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=bi({type:n,selectors:[["ng-component"]],standalone:!0,features:[ED],decls:1,vars:0,template:function(e,i){1&e&&Ci(0,"router-outlet")},dependencies:[OE],encapsulation:2}),n})();function yU(n,t){return n.providers&&!n._injector&&(n._injector=sb(n.providers,t,`Route: ${n.path}`)),n._injector??t}function LE(n){const t=n.children&&n.children.map(LE),e=t?{...n,children:t}:{...n};return!e.component&&!e.loadComponent&&(t||e.loadChildren)&&e.outlet&&e.outlet!==st&&(e.component=FE),e}function Bs(n){return n.outlet||st}function vU(n,t){const e=n.filter(i=>Bs(i)===t);return e.push(...n.filter(i=>Bs(i)!==t)),e}function zf(n){if(!n)return null;if(n.routeConfig?._injector)return n.routeConfig._injector;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class X_e{constructor(t,e,i,r){this.routeReuseStrategy=t,this.futureState=e,this.currState=i,this.forwardEvent=r}activate(t){const e=this.futureState._root,i=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,i,t),ME(this.futureState.root),this.activateChildRoutes(e,i,t)}deactivateChildRoutes(t,e,i){const r=Hu(e);t.children.forEach(s=>{const o=s.value.outlet;this.deactivateRoutes(s,r[o],i),delete r[o]}),Ki(r,(s,o)=>{this.deactivateRouteAndItsChildren(s,i)})}deactivateRoutes(t,e,i){const r=t.value,s=e?e.value:null;if(r===s)if(r.component){const o=i.getContext(r.outlet);o&&this.deactivateChildRoutes(t,e,o.children)}else this.deactivateChildRoutes(t,e,i);else s&&this.deactivateRouteAndItsChildren(e,i)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const i=e.getContext(t.value.outlet),r=i&&t.value.component?i.children:e,s=Hu(t);for(const o of Object.keys(s))this.deactivateRouteAndItsChildren(s[o],r);if(i&&i.outlet){const o=i.outlet.detach(),a=i.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:o,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){const i=e.getContext(t.value.outlet),r=i&&t.value.component?i.children:e,s=Hu(t);for(const o of Object.keys(s))this.deactivateRouteAndItsChildren(s[o],r);i&&i.outlet&&(i.outlet.deactivate(),i.children.onOutletDeactivated(),i.attachRef=null,i.resolver=null,i.route=null)}activateChildRoutes(t,e,i){const r=Hu(e);t.children.forEach(s=>{this.activateRoutes(s,r[s.value.outlet],i),this.forwardEvent(new N_e(s.value.snapshot))}),t.children.length&&this.forwardEvent(new A_e(t.value.snapshot))}activateRoutes(t,e,i){const r=t.value,s=e?e.value:null;if(ME(r),r===s)if(r.component){const o=i.getOrCreateContext(r.outlet);this.activateChildRoutes(t,e,o.children)}else this.activateChildRoutes(t,e,i);else if(r.component){const o=i.getOrCreateContext(r.outlet);if(this.routeReuseStrategy.shouldAttach(r.snapshot)){const a=this.routeReuseStrategy.retrieve(r.snapshot);this.routeReuseStrategy.store(r.snapshot,null),o.children.onOutletReAttached(a.contexts),o.attachRef=a.componentRef,o.route=a.route.value,o.outlet&&o.outlet.attach(a.componentRef,a.route.value),ME(a.route.value),this.activateChildRoutes(t,null,o.children)}else{const a=zf(r.snapshot),l=a?.get(yc)??null;o.attachRef=null,o.route=r,o.resolver=l,o.injector=a,o.outlet&&o.outlet.activateWith(r,o.injector),this.activateChildRoutes(t,null,o.children)}}else this.activateChildRoutes(t,null,i)}}class xU{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class tv{constructor(t,e){this.component=t,this.route=e}}function Z_e(n,t,e){const i=n._root;return Uf(i,t?t._root:null,e,[i.value])}function Wu(n,t){const e=Symbol(),i=t.get(n,e);return i===e?"function"!=typeof n||function PK(n){return null!==o_(n)}(n)?t.get(n):n:i}function Uf(n,t,e,i,r={canDeactivateChecks:[],canActivateChecks:[]}){const s=Hu(t);return n.children.forEach(o=>{(function J_e(n,t,e,i,r={canDeactivateChecks:[],canActivateChecks:[]}){const s=n.value,o=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(o&&s.routeConfig===o.routeConfig){const l=function ebe(n,t,e){if("function"==typeof e)return e(n,t);switch(e){case"pathParamsChange":return!Wc(n.url,t.url);case"pathParamsOrQueryParamsChange":return!Wc(n.url,t.url)||!Yo(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!NE(n,t)||!Yo(n.queryParams,t.queryParams);default:return!NE(n,t)}}(o,s,s.routeConfig.runGuardsAndResolvers);l?r.canActivateChecks.push(new xU(i)):(s.data=o.data,s._resolvedData=o._resolvedData),Uf(n,t,s.component?a?a.children:null:e,i,r),l&&a&&a.outlet&&a.outlet.isActivated&&r.canDeactivateChecks.push(new tv(a.outlet.component,o))}else o&&Hf(t,a,r),r.canActivateChecks.push(new xU(i)),Uf(n,null,s.component?a?a.children:null:e,i,r)})(o,s[o.value.outlet],e,i.concat([o.value]),r),delete s[o.value.outlet]}),Ki(s,(o,a)=>Hf(o,e.getContext(a),r)),r}function Hf(n,t,e){const i=Hu(n),r=n.value;Ki(i,(s,o)=>{Hf(s,r.component?t?t.children.getContext(o):null:t,e)}),e.canDeactivateChecks.push(new tv(r.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,r))}function jf(n){return"function"==typeof n}function $E(n){return n instanceof zy||"EmptyError"===n?.name}const nv=Symbol("INITIAL_VALUE");function Gu(){return qo(n=>$S(n.map(t=>t.pipe(fo(1),Wp(nv)))).pipe(Ye(t=>{for(const e of t)if(!0!==e){if(e===nv)return nv;if(!1===e||e instanceof Sl)return e}return!0}),lr(t=>t!==nv),fo(1)))}function wU(n){return function Un(...n){return wr(n)}(di(t=>{if(Gc(t))throw mU(0,t)}),Ye(t=>!0===t))}const VE={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function CU(n,t,e,i,r){const s=BE(n,t,e);return s.matched?function _be(n,t,e,i){const r=t.canMatch;return r&&0!==r.length?Fe(r.map(o=>{const a=Wu(o,n);return Dl(function obe(n){return n&&jf(n.canMatch)}(a)?a.canMatch(t,e):n.runInContext(()=>a(t,e)))})).pipe(Gu(),wU()):Fe(!0)}(i=yU(t,i),t,e).pipe(Ye(o=>!0===o?s:{...VE})):Fe(s)}function BE(n,t,e){if(""===t.path)return"full"===t.pathMatch&&(n.hasChildren()||e.length>0)?{...VE}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const r=(t.matcher||Qge)(e,n,t);if(!r)return{...VE};const s={};Ki(r.posParams,(a,l)=>{s[l]=a.path});const o=r.consumed.length>0?{...s,...r.consumed[r.consumed.length-1].parameters}:s;return{matched:!0,consumedSegments:r.consumed,remainingSegments:e.slice(r.consumed.length),parameters:o,positionalParamSegments:r.posParams??{}}}function iv(n,t,e,i){if(e.length>0&&function vbe(n,t,e){return e.some(i=>rv(n,t,i)&&Bs(i)!==st)}(n,e,i)){const s=new Ct(t,function ybe(n,t,e,i){const r={};r[st]=i,i._sourceSegment=n,i._segmentIndexShift=t.length;for(const s of e)if(""===s.path&&Bs(s)!==st){const o=new Ct([],{});o._sourceSegment=n,o._segmentIndexShift=t.length,r[Bs(s)]=o}return r}(n,t,i,new Ct(e,n.children)));return s._sourceSegment=n,s._segmentIndexShift=t.length,{segmentGroup:s,slicedSegments:[]}}if(0===e.length&&function xbe(n,t,e){return e.some(i=>rv(n,t,i))}(n,e,i)){const s=new Ct(n.segments,function bbe(n,t,e,i,r){const s={};for(const o of i)if(rv(n,e,o)&&!r[Bs(o)]){const a=new Ct([],{});a._sourceSegment=n,a._segmentIndexShift=t.length,s[Bs(o)]=a}return{...r,...s}}(n,t,e,i,n.children));return s._sourceSegment=n,s._segmentIndexShift=t.length,{segmentGroup:s,slicedSegments:e}}const r=new Ct(n.segments,n.children);return r._sourceSegment=n,r._segmentIndexShift=t.length,{segmentGroup:r,slicedSegments:e}}function rv(n,t,e){return(!(n.hasChildren()||t.length>0)||"full"!==e.pathMatch)&&""===e.path}function DU(n,t,e,i){return!!(Bs(n)===i||i!==st&&rv(t,e,n))&&("**"===n.path||BE(t,n,e).matched)}function SU(n,t,e){return 0===t.length&&!n.children[e]}const sv=!1;class ov{constructor(t){this.segmentGroup=t||null}}class kU{constructor(t){this.urlTree=t}}function Wf(n){return $u(new ov(n))}function EU(n){return $u(new kU(n))}function wbe(n){return $u(new Q(4e3,sv&&`Only absolute redirects can have named outlets. redirectTo: '${n}'`))}class Sbe{constructor(t,e,i,r,s){this.injector=t,this.configLoader=e,this.urlSerializer=i,this.urlTree=r,this.config=s,this.allowRedirects=!0}apply(){const t=iv(this.urlTree.root,[],[],this.config).segmentGroup,e=new Ct(t.segments,t.children);return this.expandSegmentGroup(this.injector,this.config,e,st).pipe(Ye(s=>this.createUrlTree(Xy(s),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Pa(s=>{if(s instanceof kU)return this.allowRedirects=!1,this.match(s.urlTree);throw s instanceof ov?this.noMatchError(s):s}))}match(t){return this.expandSegmentGroup(this.injector,this.config,t.root,st).pipe(Ye(r=>this.createUrlTree(Xy(r),t.queryParams,t.fragment))).pipe(Pa(r=>{throw r instanceof ov?this.noMatchError(r):r}))}noMatchError(t){return new Q(4002,sv&&`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)}createUrlTree(t,e,i){const r=wE(t);return new Sl(r,e,i)}expandSegmentGroup(t,e,i,r){return 0===i.segments.length&&i.hasChildren()?this.expandChildren(t,e,i).pipe(Ye(s=>new Ct([],s))):this.expandSegment(t,i,e,i.segments,r,!0)}expandChildren(t,e,i){const r=[];for(const s of Object.keys(i.children))"primary"===s?r.unshift(s):r.push(s);return oi(r).pipe(Cl(s=>{const o=i.children[s],a=vU(e,s);return this.expandSegmentGroup(t,a,o,s).pipe(Ye(l=>({segment:l,outlet:s})))}),z3((s,o)=>(s[o.outlet]=o.segment,s),{}),U3())}expandSegment(t,e,i,r,s,o){return oi(i).pipe(Cl(a=>this.expandSegmentAgainstRoute(t,e,i,a,r,s,o).pipe(Pa(c=>{if(c instanceof ov)return Fe(null);throw c}))),wl(a=>!!a),Pa((a,l)=>{if($E(a))return SU(e,r,s)?Fe(new Ct([],{})):Wf(e);throw a}))}expandSegmentAgainstRoute(t,e,i,r,s,o,a){return DU(r,e,s,o)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(t,e,r,s,o):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,i,r,s,o):Wf(e):Wf(e)}expandSegmentAgainstRouteUsingRedirect(t,e,i,r,s,o){return"**"===r.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,i,r,o):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,i,r,s,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,i,r){const s=this.applyRedirectCommands([],i.redirectTo,{});return i.redirectTo.startsWith("/")?EU(s):this.lineralizeSegments(i,s).pipe(Pi(o=>{const a=new Ct(o,{});return this.expandSegment(t,a,e,o,r,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,i,r,s,o){const{matched:a,consumedSegments:l,remainingSegments:c,positionalParamSegments:d}=BE(e,r,s);if(!a)return Wf(e);const u=this.applyRedirectCommands(l,r.redirectTo,d);return r.redirectTo.startsWith("/")?EU(u):this.lineralizeSegments(r,u).pipe(Pi(h=>this.expandSegment(t,e,i,h.concat(c),o,!1)))}matchSegmentAgainstRoute(t,e,i,r,s){return"**"===i.path?(t=yU(i,t),i.loadChildren?(i._loadedRoutes?Fe({routes:i._loadedRoutes,injector:i._loadedInjector}):this.configLoader.loadChildren(t,i)).pipe(Ye(a=>(i._loadedRoutes=a.routes,i._loadedInjector=a.injector,new Ct(r,{})))):Fe(new Ct(r,{}))):CU(e,i,r,t).pipe(qo(({matched:o,consumedSegments:a,remainingSegments:l})=>o?this.getChildConfig(t=i._injector??t,i,r).pipe(Pi(d=>{const u=d.injector??t,h=d.routes,{segmentGroup:p,slicedSegments:f}=iv(e,a,l,h),m=new Ct(p.segments,p.children);if(0===f.length&&m.hasChildren())return this.expandChildren(u,h,m).pipe(Ye(y=>new Ct(a,y)));if(0===h.length&&0===f.length)return Fe(new Ct(a,{}));const g=Bs(i)===s;return this.expandSegment(u,m,h,f,g?st:s,!0).pipe(Ye(b=>new Ct(a.concat(b.segments),b.children)))})):Wf(e)))}getChildConfig(t,e,i){return e.children?Fe({routes:e.children,injector:t}):e.loadChildren?void 0!==e._loadedRoutes?Fe({routes:e._loadedRoutes,injector:e._loadedInjector}):function gbe(n,t,e,i){const r=t.canLoad;return void 0===r||0===r.length?Fe(!0):Fe(r.map(o=>{const a=Wu(o,n);return Dl(function nbe(n){return n&&jf(n.canLoad)}(a)?a.canLoad(t,e):n.runInContext(()=>a(t,e)))})).pipe(Gu(),wU())}(t,e,i).pipe(Pi(r=>r?this.configLoader.loadChildren(t,e).pipe(di(s=>{e._loadedRoutes=s.routes,e._loadedInjector=s.injector})):function Cbe(n){return $u(gU(sv&&`Cannot load children because the guard of the route "path: '${n.path}'" returned false`,3))}(e))):Fe({routes:[],injector:t})}lineralizeSegments(t,e){let i=[],r=e.root;for(;;){if(i=i.concat(r.segments),0===r.numberOfChildren)return Fe(i);if(r.numberOfChildren>1||!r.children[st])return wbe(t.redirectTo);r=r.children[st]}}applyRedirectCommands(t,e,i){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),t,i)}applyRedirectCreateUrlTree(t,e,i,r){const s=this.createSegmentGroup(t,e.root,i,r);return new Sl(s,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const i={};return Ki(t,(r,s)=>{if("string"==typeof r&&r.startsWith(":")){const a=r.substring(1);i[s]=e[a]}else i[s]=r}),i}createSegmentGroup(t,e,i,r){const s=this.createSegments(t,e.segments,i,r);let o={};return Ki(e.children,(a,l)=>{o[l]=this.createSegmentGroup(t,a,i,r)}),new Ct(s,o)}createSegments(t,e,i,r){return e.map(s=>s.path.startsWith(":")?this.findPosParam(t,s,r):this.findOrReturn(s,i))}findPosParam(t,e,i){const r=i[e.path.substring(1)];if(!r)throw new Q(4001,sv&&`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);return r}findOrReturn(t,e){let i=0;for(const r of e){if(r.path===t.path)return e.splice(i),r;i++}return t}}class Ebe{}class Abe{constructor(t,e,i,r,s,o,a){this.injector=t,this.rootComponentType=e,this.config=i,this.urlTree=r,this.url=s,this.paramsInheritanceStrategy=o,this.urlSerializer=a}recognize(){const t=iv(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo)).segmentGroup;return this.processSegmentGroup(this.injector,this.config,t,st).pipe(Ye(e=>{if(null===e)return null;const i=new Jy([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},st,this.rootComponentType,null,this.urlTree.root,-1,{}),r=new La(i,e),s=new pU(this.url,r);return this.inheritParamsAndData(s._root),s}))}inheritParamsAndData(t){const e=t.value,i=hU(e,this.paramsInheritanceStrategy);e.params=Object.freeze(i.params),e.data=Object.freeze(i.data),t.children.forEach(r=>this.inheritParamsAndData(r))}processSegmentGroup(t,e,i,r){return 0===i.segments.length&&i.hasChildren()?this.processChildren(t,e,i):this.processSegment(t,e,i,i.segments,r)}processChildren(t,e,i){return oi(Object.keys(i.children)).pipe(Cl(r=>{const s=i.children[r],o=vU(e,r);return this.processSegmentGroup(t,o,s,r)}),z3((r,s)=>r&&s?(r.push(...s),r):null),function Kge(n,t=!1){return Hn((e,i)=>{let r=0;e.subscribe(Tn(i,s=>{const o=n(s,r++);(o||t)&&i.next(s),!o&&i.complete()}))})}(r=>null!==r),Uy(null),U3(),Ye(r=>{if(null===r)return null;const s=TU(r);return function Mbe(n){n.sort((t,e)=>t.value.outlet===st?-1:e.value.outlet===st?1:t.value.outlet.localeCompare(e.value.outlet))}(s),s}))}processSegment(t,e,i,r,s){return oi(e).pipe(Cl(o=>this.processSegmentAgainstRoute(o._injector??t,o,i,r,s)),wl(o=>!!o),Pa(o=>{if($E(o))return SU(i,r,s)?Fe([]):Fe(null);throw o}))}processSegmentAgainstRoute(t,e,i,r,s){if(e.redirectTo||!DU(e,i,r,s))return Fe(null);let o;if("**"===e.path){const a=r.length>0?W3(r).parameters:{},l=MU(i)+r.length;o=Fe({snapshot:new Jy(r,a,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,NU(e),Bs(e),e.component??e._loadedComponent??null,e,AU(i),l,RU(e)),consumedSegments:[],remainingSegments:[]})}else o=CU(i,e,r,t).pipe(Ye(({matched:a,consumedSegments:l,remainingSegments:c,parameters:d})=>{if(!a)return null;const u=MU(i)+l.length;return{snapshot:new Jy(l,d,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,NU(e),Bs(e),e.component??e._loadedComponent??null,e,AU(i),u,RU(e)),consumedSegments:l,remainingSegments:c}}));return o.pipe(qo(a=>{if(null===a)return Fe(null);const{snapshot:l,consumedSegments:c,remainingSegments:d}=a;t=e._injector??t;const u=e._loadedInjector??t,h=function Nbe(n){return n.children?n.children:n.loadChildren?n._loadedRoutes:[]}(e),{segmentGroup:p,slicedSegments:f}=iv(i,c,d,h.filter(g=>void 0===g.redirectTo));if(0===f.length&&p.hasChildren())return this.processChildren(u,h,p).pipe(Ye(g=>null===g?null:[new La(l,g)]));if(0===h.length&&0===f.length)return Fe([new La(l,[])]);const m=Bs(e)===s;return this.processSegment(u,h,p,f,m?st:s).pipe(Ye(g=>null===g?null:[new La(l,g)]))}))}}function Rbe(n){const t=n.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function TU(n){const t=[],e=new Set;for(const i of n){if(!Rbe(i)){t.push(i);continue}const r=t.find(s=>i.value.routeConfig===s.value.routeConfig);void 0!==r?(r.children.push(...i.children),e.add(r)):t.push(i)}for(const i of e){const r=TU(i.children);t.push(new La(i.value,r))}return t.filter(i=>!e.has(i))}function AU(n){let t=n;for(;t._sourceSegment;)t=t._sourceSegment;return t}function MU(n){let t=n,e=t._segmentIndexShift??0;for(;t._sourceSegment;)t=t._sourceSegment,e+=t._segmentIndexShift??0;return e-1}function NU(n){return n.data||{}}function RU(n){return n.resolve||{}}function OU(n){return"string"==typeof n.title||null===n.title}function zE(n){return qo(t=>{const e=n(t);return e?oi(e).pipe(Ye(()=>t)):Fe(t)})}const qu=new ne("ROUTES");let UE=(()=>{class n{constructor(e,i){this.injector=e,this.compiler=i,this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return Fe(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const i=Dl(e.loadComponent()).pipe(Ye(PU),di(s=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=s}),Hy(()=>{this.componentLoaders.delete(e)})),r=new V3(i,()=>new dt).pipe(bE());return this.componentLoaders.set(e,r),r}loadChildren(e,i){if(this.childrenLoaders.get(i))return this.childrenLoaders.get(i);if(i._loadedRoutes)return Fe({routes:i._loadedRoutes,injector:i._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(i);const s=this.loadModuleFactoryOrRoutes(i.loadChildren).pipe(Ye(a=>{this.onLoadEndListener&&this.onLoadEndListener(i);let l,c,d=!1;Array.isArray(a)?c=a:(l=a.create(e).injector,c=j3(l.get(qu,[],je.Self|je.Optional)));return{routes:c.map(LE),injector:l}}),Hy(()=>{this.childrenLoaders.delete(i)})),o=new V3(s,()=>new dt).pipe(bE());return this.childrenLoaders.set(i,o),o}loadModuleFactoryOrRoutes(e){return Dl(e()).pipe(Ye(PU),Pi(r=>r instanceof UP||Array.isArray(r)?Fe(r):oi(this.compiler.compileModuleAsync(r))))}}return n.\u0275fac=function(e){return new(e||n)(Y(Li),Y(A2))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function PU(n){return function Ube(n){return n&&"object"==typeof n&&"default"in n}(n)?n.default:n}let lv=(()=>{class n{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.lastSuccessfulNavigation=null,this.events=new dt,this.configLoader=lt(UE),this.environmentInjector=lt(va),this.urlSerializer=lt(Of),this.rootContexts=lt(Bf),this.navigationId=0,this.afterPreactivation=()=>Fe(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=r=>this.events.next(new I_e(r)),this.configLoader.onLoadStartListener=r=>this.events.next(new E_e(r))}complete(){this.transitions?.complete()}handleNavigationRequest(e){const i=++this.navigationId;this.transitions?.next({...this.transitions.value,...e,id:i})}setupNavigations(e){return this.transitions=new ls({id:0,targetPageId:0,currentUrlTree:e.currentUrlTree,currentRawUrl:e.currentUrlTree,extractedUrl:e.urlHandlingStrategy.extract(e.currentUrlTree),urlAfterRedirects:e.urlHandlingStrategy.extract(e.currentUrlTree),rawUrl:e.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:$f,restoredState:null,currentSnapshot:e.routerState.snapshot,targetSnapshot:null,currentRouterState:e.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(lr(i=>0!==i.id),Ye(i=>({...i,extractedUrl:e.urlHandlingStrategy.extract(i.rawUrl)})),qo(i=>{let r=!1,s=!1;return Fe(i).pipe(di(o=>{this.currentNavigation={id:o.id,initialUrl:o.rawUrl,extractedUrl:o.extractedUrl,trigger:o.source,extras:o.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),qo(o=>{const a=e.browserUrlTree.toString(),l=!e.navigated||o.extractedUrl.toString()!==a||a!==e.currentUrlTree.toString();if(!l&&"reload"!==(o.extras.onSameUrlNavigation??e.onSameUrlNavigation)){const d="";return this.events.next(new Qy(o.id,e.serializeUrl(i.rawUrl),d,0)),e.rawUrlTree=o.rawUrl,o.resolve(null),Mo}if(e.urlHandlingStrategy.shouldProcessUrl(o.rawUrl))return LU(o.source)&&(e.browserUrlTree=o.extractedUrl),Fe(o).pipe(qo(d=>{const u=this.transitions?.getValue();return this.events.next(new kE(d.id,this.urlSerializer.serialize(d.extractedUrl),d.source,d.restoredState)),u!==this.transitions?.getValue()?Mo:Promise.resolve(d)}),function kbe(n,t,e,i){return qo(r=>function Dbe(n,t,e,i,r){return new Sbe(n,t,e,i,r).apply()}(n,t,e,r.extractedUrl,i).pipe(Ye(s=>({...r,urlAfterRedirects:s}))))}(this.environmentInjector,this.configLoader,this.urlSerializer,e.config),di(d=>{this.currentNavigation={...this.currentNavigation,finalUrl:d.urlAfterRedirects},i.urlAfterRedirects=d.urlAfterRedirects}),function Fbe(n,t,e,i,r){return Pi(s=>function Tbe(n,t,e,i,r,s,o="emptyOnly"){return new Abe(n,t,e,i,r,o,s).recognize().pipe(qo(a=>null===a?function Ibe(n){return new Ze(t=>t.error(n))}(new Ebe):Fe(a)))}(n,t,e,s.urlAfterRedirects,i.serialize(s.urlAfterRedirects),i,r).pipe(Ye(o=>({...s,targetSnapshot:o}))))}(this.environmentInjector,this.rootComponentType,e.config,this.urlSerializer,e.paramsInheritanceStrategy),di(d=>{if(i.targetSnapshot=d.targetSnapshot,"eager"===e.urlUpdateStrategy){if(!d.extras.skipLocationChange){const h=e.urlHandlingStrategy.merge(d.urlAfterRedirects,d.rawUrl);e.setBrowserUrl(h,d)}e.browserUrlTree=d.urlAfterRedirects}const u=new w_e(d.id,this.urlSerializer.serialize(d.extractedUrl),this.urlSerializer.serialize(d.urlAfterRedirects),d.targetSnapshot);this.events.next(u)}));if(l&&e.urlHandlingStrategy.shouldProcessUrl(e.rawUrlTree)){const{id:d,extractedUrl:u,source:h,restoredState:p,extras:f}=o,m=new kE(d,this.urlSerializer.serialize(u),h,p);this.events.next(m);const g=uU(u,this.rootComponentType).snapshot;return Fe(i={...o,targetSnapshot:g,urlAfterRedirects:u,extras:{...f,skipLocationChange:!1,replaceUrl:!1}})}{const d="";return this.events.next(new Qy(o.id,e.serializeUrl(i.extractedUrl),d,1)),e.rawUrlTree=o.rawUrl,o.resolve(null),Mo}}),di(o=>{const a=new C_e(o.id,this.urlSerializer.serialize(o.extractedUrl),this.urlSerializer.serialize(o.urlAfterRedirects),o.targetSnapshot);this.events.next(a)}),Ye(o=>i={...o,guards:Z_e(o.targetSnapshot,o.currentSnapshot,this.rootContexts)}),function lbe(n,t){return Pi(e=>{const{targetSnapshot:i,currentSnapshot:r,guards:{canActivateChecks:s,canDeactivateChecks:o}}=e;return 0===o.length&&0===s.length?Fe({...e,guardsResult:!0}):function cbe(n,t,e,i){return oi(n).pipe(Pi(r=>function mbe(n,t,e,i,r){const s=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return s&&0!==s.length?Fe(s.map(a=>{const l=zf(t)??r,c=Wu(a,l);return Dl(function sbe(n){return n&&jf(n.canDeactivate)}(c)?c.canDeactivate(n,t,e,i):l.runInContext(()=>c(n,t,e,i))).pipe(wl())})).pipe(Gu()):Fe(!0)}(r.component,r.route,e,t,i)),wl(r=>!0!==r,!0))}(o,i,r,n).pipe(Pi(a=>a&&function tbe(n){return"boolean"==typeof n}(a)?function dbe(n,t,e,i){return oi(t).pipe(Cl(r=>Lb(function hbe(n,t){return null!==n&&t&&t(new T_e(n)),Fe(!0)}(r.route.parent,i),function ube(n,t){return null!==n&&t&&t(new M_e(n)),Fe(!0)}(r.route,i),function fbe(n,t,e){const i=t[t.length-1],s=t.slice(0,t.length-1).reverse().map(o=>function Q_e(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:n,guards:t}:null}(o)).filter(o=>null!==o).map(o=>Gb(()=>Fe(o.guards.map(l=>{const c=zf(o.node)??e,d=Wu(l,c);return Dl(function rbe(n){return n&&jf(n.canActivateChild)}(d)?d.canActivateChild(i,n):c.runInContext(()=>d(i,n))).pipe(wl())})).pipe(Gu())));return Fe(s).pipe(Gu())}(n,r.path,e),function pbe(n,t,e){const i=t.routeConfig?t.routeConfig.canActivate:null;if(!i||0===i.length)return Fe(!0);const r=i.map(s=>Gb(()=>{const o=zf(t)??e,a=Wu(s,o);return Dl(function ibe(n){return n&&jf(n.canActivate)}(a)?a.canActivate(t,n):o.runInContext(()=>a(t,n))).pipe(wl())}));return Fe(r).pipe(Gu())}(n,r.route,e))),wl(r=>!0!==r,!0))}(i,s,n,t):Fe(a)),Ye(a=>({...e,guardsResult:a})))})}(this.environmentInjector,o=>this.events.next(o)),di(o=>{if(i.guardsResult=o.guardsResult,Gc(o.guardsResult))throw mU(0,o.guardsResult);const a=new D_e(o.id,this.urlSerializer.serialize(o.extractedUrl),this.urlSerializer.serialize(o.urlAfterRedirects),o.targetSnapshot,!!o.guardsResult);this.events.next(a)}),lr(o=>!!o.guardsResult||(e.restoreHistory(o),this.cancelNavigationTransition(o,"",3),!1)),zE(o=>{if(o.guards.canActivateChecks.length)return Fe(o).pipe(di(a=>{const l=new S_e(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(l)}),qo(a=>{let l=!1;return Fe(a).pipe(function Pbe(n,t){return Pi(e=>{const{targetSnapshot:i,guards:{canActivateChecks:r}}=e;if(!r.length)return Fe(e);let s=0;return oi(r).pipe(Cl(o=>function Lbe(n,t,e,i){const r=n.routeConfig,s=n._resolve;return void 0!==r?.title&&!OU(r)&&(s[Nf]=r.title),function $be(n,t,e,i){const r=function Vbe(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}(n);if(0===r.length)return Fe({});const s={};return oi(r).pipe(Pi(o=>function Bbe(n,t,e,i){const r=zf(t)??i,s=Wu(n,r);return Dl(s.resolve?s.resolve(t,e):r.runInContext(()=>s(t,e)))}(n[o],t,e,i).pipe(wl(),di(a=>{s[o]=a}))),yE(1),function Xge(n){return Ye(()=>n)}(s),Pa(o=>$E(o)?Mo:$u(o)))}(s,n,t,i).pipe(Ye(o=>(n._resolvedData=o,n.data=hU(n,e).resolve,r&&OU(r)&&(n.data[Nf]=r.title),null)))}(o.route,i,n,t)),di(()=>s++),yE(1),Pi(o=>s===r.length?Fe(e):Mo))})}(e.paramsInheritanceStrategy,this.environmentInjector),di({next:()=>l=!0,complete:()=>{l||(e.restoreHistory(a),this.cancelNavigationTransition(a,"",2))}}))}),di(a=>{const l=new k_e(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(l)}))}),zE(o=>{const a=l=>{const c=[];l.routeConfig?.loadComponent&&!l.routeConfig._loadedComponent&&c.push(this.configLoader.loadComponent(l.routeConfig).pipe(di(d=>{l.component=d}),Ye(()=>{})));for(const d of l.children)c.push(...a(d));return c};return $S(a(o.targetSnapshot.root)).pipe(Uy(),fo(1))}),zE(()=>this.afterPreactivation()),Ye(o=>{const a=function B_e(n,t,e){const i=Vf(n,t._root,e?e._root:void 0);return new dU(i,t)}(e.routeReuseStrategy,o.targetSnapshot,o.currentRouterState);return i={...o,targetRouterState:a}}),di(o=>{e.currentUrlTree=o.urlAfterRedirects,e.rawUrlTree=e.urlHandlingStrategy.merge(o.urlAfterRedirects,o.rawUrl),e.routerState=o.targetRouterState,"deferred"===e.urlUpdateStrategy&&(o.extras.skipLocationChange||e.setBrowserUrl(e.rawUrlTree,o),e.browserUrlTree=o.urlAfterRedirects)}),((n,t,e)=>Ye(i=>(new X_e(t,i.targetRouterState,i.currentRouterState,e).activate(n),i)))(this.rootContexts,e.routeReuseStrategy,o=>this.events.next(o)),di({next:o=>{r=!0,this.lastSuccessfulNavigation=this.currentNavigation,e.navigated=!0,this.events.next(new qc(o.id,this.urlSerializer.serialize(o.extractedUrl),this.urlSerializer.serialize(e.currentUrlTree))),e.titleStrategy?.updateTitle(o.targetRouterState.snapshot),o.resolve(!0)},complete:()=>{r=!0}}),Hy(()=>{r||s||this.cancelNavigationTransition(i,"",1),this.currentNavigation?.id===i.id&&(this.currentNavigation=null)}),Pa(o=>{if(s=!0,bU(o)){_U(o)||(e.navigated=!0,e.restoreHistory(i,!0));const a=new Zy(i.id,this.urlSerializer.serialize(i.extractedUrl),o.message,o.cancellationCode);if(this.events.next(a),_U(o)){const l=e.urlHandlingStrategy.merge(o.url,e.rawUrlTree),c={skipLocationChange:i.extras.skipLocationChange,replaceUrl:"eager"===e.urlUpdateStrategy||LU(i.source)};e.scheduleNavigation(l,$f,null,c,{resolve:i.resolve,reject:i.reject,promise:i.promise})}else i.resolve(!1)}else{e.restoreHistory(i,!0);const a=new EE(i.id,this.urlSerializer.serialize(i.extractedUrl),o,i.targetSnapshot??void 0);this.events.next(a);try{i.resolve(e.errorHandler(o))}catch(l){i.reject(l)}}return Mo}))}))}cancelNavigationTransition(e,i,r){const s=new Zy(e.id,this.urlSerializer.serialize(e.extractedUrl),i,r);this.events.next(s),e.resolve(!1)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function LU(n){return n!==$f}let $U=(()=>{class n{buildTitle(e){let i,r=e.root;for(;void 0!==r;)i=this.getResolvedTitleForRoute(r)??i,r=r.children.find(s=>s.outlet===st);return i}getResolvedTitleForRoute(e){return e.data[Nf]}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:function(){return lt(Hbe)},providedIn:"root"}),n})(),Hbe=(()=>{class n extends $U{constructor(e){super(),this.title=e}updateTitle(e){const i=this.buildTitle(e);void 0!==i&&this.title.setTitle(i)}}return n.\u0275fac=function(e){return new(e||n)(Y(YL))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),jbe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:function(){return lt(Gbe)},providedIn:"root"}),n})();class Wbe{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}let Gbe=(()=>{class n extends Wbe{}return n.\u0275fac=function(){let t;return function(i){return(t||(t=function yi(n){return el(()=>{const t=n.prototype.constructor,e=t[fa]||sC(t),i=Object.prototype;let r=Object.getPrototypeOf(n.prototype).constructor;for(;r&&r!==i;){const s=r[fa]||sC(r);if(s&&s!==e)return s;r=Object.getPrototypeOf(r)}return s=>new s})}(n)))(i||n)}}(),n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const cv=new ne("",{providedIn:"root",factory:()=>({})});let Ybe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:function(){return lt(Kbe)},providedIn:"root"}),n})(),Kbe=(()=>{class n{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,i){return e}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Xbe(n){throw n}function Zbe(n,t,e){return t.parse("/")}const Qbe={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Jbe={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let jr=(()=>{class n{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){return this.location.getState()?.\u0275routerPageId}get events(){return this.navigationTransitions.events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=lt(lte),this.isNgZoneEnabled=!1,this.options=lt(cv,{optional:!0})||{},this.errorHandler=this.options.errorHandler||Xbe,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||Zbe,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=lt(Ybe),this.routeReuseStrategy=lt(jbe),this.urlCreationStrategy=lt(L_e),this.titleStrategy=lt($U),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=j3(lt(qu,{optional:!0})??[]),this.navigationTransitions=lt(lv),this.urlSerializer=lt(Of),this.location=lt(Pp),this.isNgZoneEnabled=lt(Qe)instanceof Qe&&Qe.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new Sl,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=uU(this.currentUrlTree,null),this.navigationTransitions.setupNavigations(this).subscribe(e=>{this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const e=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),$f,e)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const i="popstate"===e.type?"popstate":"hashchange";"popstate"===i&&setTimeout(()=>{this.navigateToSyncWithBrowser(e.url,i,e.state)},0)}))}navigateToSyncWithBrowser(e,i,r){const s={replaceUrl:!0},o=r?.navigationId?r:null;if(r){const l={...r};delete l.navigationId,delete l.\u0275routerPageId,0!==Object.keys(l).length&&(s.state=l)}const a=this.parseUrl(e);this.scheduleNavigation(a,i,o,s)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}resetConfig(e){this.config=e.map(LE),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,i={}){const{relativeTo:r,queryParams:s,fragment:o,queryParamsHandling:a,preserveFragment:l}=i,c=l?this.currentUrlTree.fragment:o;let d=null;switch(a){case"merge":d={...this.currentUrlTree.queryParams,...s};break;case"preserve":d=this.currentUrlTree.queryParams;break;default:d=s||null}return null!==d&&(d=this.removeEmptyProps(d)),this.urlCreationStrategy.createUrlTree(r,this.routerState,this.currentUrlTree,e,d,c??null)}navigateByUrl(e,i={skipLocationChange:!1}){const r=Gc(e)?e:this.parseUrl(e),s=this.urlHandlingStrategy.merge(r,this.rawUrlTree);return this.scheduleNavigation(s,$f,null,i)}navigate(e,i={skipLocationChange:!1}){return function eye(n){for(let t=0;t<n.length;t++){const e=n[t];if(null==e)throw new Q(4008,false)}}(e),this.navigateByUrl(this.createUrlTree(e,i),i)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let i;try{i=this.urlSerializer.parse(e)}catch(r){i=this.malformedUriErrorHandler(r,this.urlSerializer,e)}return i}isActive(e,i){let r;if(r=!0===i?{...Qbe}:!1===i?{...Jbe}:i,Gc(e))return q3(this.currentUrlTree,e,r);const s=this.parseUrl(e);return q3(this.currentUrlTree,s,r)}removeEmptyProps(e){return Object.keys(e).reduce((i,r)=>{const s=e[r];return null!=s&&(i[r]=s),i},{})}scheduleNavigation(e,i,r,s,o){if(this.disposed)return Promise.resolve(!1);let a,l,c,d;return o?(a=o.resolve,l=o.reject,c=o.promise):c=new Promise((u,h)=>{a=u,l=h}),d="computed"===this.canceledNavigationResolution?r&&r.\u0275routerPageId?r.\u0275routerPageId:s.replaceUrl||s.skipLocationChange?this.browserPageId??0:(this.browserPageId??0)+1:0,this.navigationTransitions.handleNavigationRequest({targetPageId:d,source:i,restoredState:r,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:e,extras:s,resolve:a,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(u=>Promise.reject(u))}setBrowserUrl(e,i){const r=this.urlSerializer.serialize(e),s={...i.extras.state,...this.generateNgRouterState(i.id,i.targetPageId)};this.location.isCurrentPathEqualTo(r)||i.extras.replaceUrl?this.location.replaceState(r,"",s):this.location.go(r,"",s)}restoreHistory(e,i=!1){if("computed"===this.canceledNavigationResolution){const r=this.currentPageId-e.targetPageId;"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==this.getCurrentNavigation()?.finalUrl||0===r?this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===r&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(r)}else"replace"===this.canceledNavigationResolution&&(i&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,i){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:i}:{navigationId:e}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class VU{}let iye=(()=>{class n{constructor(e,i,r,s,o){this.router=e,this.injector=r,this.preloadingStrategy=s,this.loader=o}setUpPreloading(){this.subscription=this.router.events.pipe(lr(e=>e instanceof qc),Cl(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,i){const r=[];for(const s of i){s.providers&&!s._injector&&(s._injector=sb(s.providers,e,`Route: ${s.path}`));const o=s._injector??e,a=s._loadedInjector??o;s.loadChildren&&!s._loadedRoutes&&void 0===s.canLoad||s.loadComponent&&!s._loadedComponent?r.push(this.preloadConfig(o,s)):(s.children||s._loadedRoutes)&&r.push(this.processRoutes(a,s.children??s._loadedRoutes))}return oi(r).pipe(Ad())}preloadConfig(e,i){return this.preloadingStrategy.preload(i,()=>{let r;r=i.loadChildren&&void 0===i.canLoad?this.loader.loadChildren(e,i):Fe(null);const s=r.pipe(Pi(o=>null===o?Fe(void 0):(i._loadedRoutes=o.routes,i._loadedInjector=o.injector,this.processRoutes(o.injector??e,o.routes))));return i.loadComponent&&!i._loadedComponent?oi([s,this.loader.loadComponent(i)]).pipe(Ad()):s})}}return n.\u0275fac=function(e){return new(e||n)(Y(jr),Y(A2),Y(va),Y(VU),Y(UE))},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const WE=new ne("");let BU=(()=>{class n{constructor(e,i,r,s,o={}){this.urlSerializer=e,this.transitions=i,this.viewportScroller=r,this.zone=s,this.options=o,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},o.scrollPositionRestoration=o.scrollPositionRestoration||"disabled",o.anchorScrolling=o.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof kE?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof qc&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof lU&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,i){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new lU(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,i))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}}return n.\u0275fac=function(e){bp()},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();var us=(()=>((us=us||{})[us.COMPLETE=0]="COMPLETE",us[us.FAILED=1]="FAILED",us[us.REDIRECTING=2]="REDIRECTING",us))();const Yu=!1;function kl(n,t){return{\u0275kind:n,\u0275providers:t}}const GE=new ne("",{providedIn:"root",factory:()=>!1});function UU(){const n=lt(Li);return t=>{const e=n.get(gu);if(t!==e.components[0])return;const i=n.get(jr),r=n.get(HU);1===n.get(qE)&&i.initialNavigation(),n.get(jU,null,je.Optional)?.setUpPreloading(),n.get(WE,null,je.Optional)?.init(),i.resetRootComponentType(e.componentTypes[0]),r.closed||(r.next(),r.unsubscribe())}}const HU=new ne(Yu?"bootstrap done indicator":"",{factory:()=>new dt}),qE=new ne(Yu?"initial navigation":"",{providedIn:"root",factory:()=>1});function lye(){let n=[];return n=Yu?[{provide:V_,multi:!0,useFactory:()=>{const t=lt(jr);return()=>t.events.subscribe(e=>{console.group?.(`Router Event: ${e.constructor.name}`),console.log(function R_e(n){if(!("type"in n))return`Unknown Router Event: ${n.constructor.name}`;switch(n.type){case 14:return`ActivationEnd(path: '${n.snapshot.routeConfig?.path||""}')`;case 13:return`ActivationStart(path: '${n.snapshot.routeConfig?.path||""}')`;case 12:return`ChildActivationEnd(path: '${n.snapshot.routeConfig?.path||""}')`;case 11:return`ChildActivationStart(path: '${n.snapshot.routeConfig?.path||""}')`;case 8:return`GuardsCheckEnd(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}', state: ${n.state}, shouldActivate: ${n.shouldActivate})`;case 7:return`GuardsCheckStart(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}', state: ${n.state})`;case 2:return`NavigationCancel(id: ${n.id}, url: '${n.url}')`;case 16:return`NavigationSkipped(id: ${n.id}, url: '${n.url}')`;case 1:return`NavigationEnd(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}')`;case 3:return`NavigationError(id: ${n.id}, url: '${n.url}', error: ${n.error})`;case 0:return`NavigationStart(id: ${n.id}, url: '${n.url}')`;case 6:return`ResolveEnd(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}', state: ${n.state})`;case 5:return`ResolveStart(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}', state: ${n.state})`;case 10:return`RouteConfigLoadEnd(path: ${n.route.path})`;case 9:return`RouteConfigLoadStart(path: ${n.route.path})`;case 4:return`RoutesRecognized(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}', state: ${n.state})`;case 15:return`Scroll(anchor: '${n.anchor}', position: '${n.position?`${n.position[0]}, ${n.position[1]}`:null}')`}}(e)),console.log(e),console.groupEnd?.()})}}]:[],kl(1,n)}const jU=new ne(Yu?"router preloader":"");function cye(n){return kl(0,[{provide:jU,useExisting:iye},{provide:VU,useExisting:n}])}const Gf=!1,WU=new ne(Gf?"router duplicate forRoot guard":"ROUTER_FORROOT_GUARD"),dye=[Pp,{provide:Of,useClass:vE},jr,Bf,{provide:ju,useFactory:function zU(n){return n.routerState.root},deps:[jr]},UE,Gf?{provide:GE,useValue:!0}:[]];function uye(){return new L2("Router",jr)}let GU=(()=>{class n{constructor(e){}static forRoot(e,i){return{ngModule:n,providers:[dye,Gf&&i?.enableTracing?lye().\u0275providers:[],{provide:qu,multi:!0,useValue:e},{provide:WU,useFactory:mye,deps:[[jr,new Is,new ba]]},{provide:cv,useValue:i||{}},i?.useHash?{provide:kc,useClass:Kte}:{provide:kc,useClass:oL},{provide:WE,useFactory:()=>{const n=lt(bie),t=lt(Qe),e=lt(cv),i=lt(lv),r=lt(Of);return e.scrollOffset&&n.setOffset(e.scrollOffset),new BU(r,i,n,t,e)}},i?.preloadingStrategy?cye(i.preloadingStrategy).\u0275providers:[],{provide:L2,multi:!0,useFactory:uye},i?.initialNavigation?gye(i):[],[{provide:qU,useFactory:UU},{provide:T2,multi:!0,useExisting:qU}]]}}static forChild(e){return{ngModule:n,providers:[{provide:qu,multi:!0,useValue:e}]}}}return n.\u0275fac=function(e){return new(e||n)(Y(WU,8))},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[FE]}),n})();function mye(n){if(Gf&&n)throw new Q(4007,"The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.");return"guarded"}function gye(n){return["disabled"===n.initialNavigation?kl(3,[{provide:db,multi:!0,useFactory:()=>{const t=lt(jr);return()=>{t.setUpLocationChangeListener()}}},{provide:qE,useValue:2}]).\u0275providers:[],"enabledBlocking"===n.initialNavigation?kl(2,[{provide:qE,useValue:0},{provide:db,multi:!0,deps:[Li],useFactory:t=>{const e=t.get(qte,Promise.resolve());return()=>e.then(()=>new Promise(i=>{const r=t.get(jr),s=t.get(HU);(function rye(n,t){n.events.pipe(lr(e=>e instanceof qc||e instanceof Zy||e instanceof EE||e instanceof Qy),Ye(e=>e instanceof qc||e instanceof Qy?us.COMPLETE:e instanceof Zy&&(0===e.code||1===e.code)?us.REDIRECTING:us.FAILED),lr(e=>e!==us.REDIRECTING),fo(1)).subscribe(()=>{t()})})(r,()=>{i(!0)}),t.get(lv).afterPreactivation=()=>(i(!0),s.closed?Fe(void 0):s),r.initialNavigation()}))}}]).\u0275providers:[]]}const qU=new ne(Gf?"Router Initializer":""),yye=new ne("mat-sanity-checks",{providedIn:"root",factory:function bye(){return!0}});let on=(()=>{class n{constructor(e,i,r){this._sanityChecks=i,this._document=r,this._hasDoneGlobalChecks=!1,e._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!MS()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}}return n.\u0275fac=function(e){return new(e||n)(Y(x$),Y(yye,8),Y(bt))},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[qp,qp]}),n})();function vye(n){return class extends n{get disabled(){return this._disabled}set disabled(t){this._disabled=cs(t)}constructor(...t){super(...t),this._disabled=!1}}}function xye(n,t){return class extends n{get color(){return this._color}set color(e){const i=e||this.defaultColor;i!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),i&&this._elementRef.nativeElement.classList.add(`mat-${i}`),this._color=i)}constructor(...e){super(...e),this.defaultColor=t,this.color=t}}}function wye(n){return class extends n{get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=cs(t)}constructor(...t){super(...t),this._disableRipple=!1}}}class Dye{constructor(t,e,i,r=!1){this._renderer=t,this.element=e,this.config=i,this._animationForciblyDisabledThroughCss=r,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const ZU=vu({passive:!0,capture:!0});class Sye{constructor(){this._events=new Map,this._delegateEventHandler=t=>{const e=ll(t);e&&this._events.get(t.type)?.forEach((i,r)=>{(r===e||r.contains(e))&&i.forEach(s=>s.handleEvent(t))})}}addHandler(t,e,i,r){const s=this._events.get(e);if(s){const o=s.get(i);o?o.add(r):s.set(i,new Set([r]))}else this._events.set(e,new Map([[i,new Set([r])]])),t.runOutsideAngular(()=>{document.addEventListener(e,this._delegateEventHandler,ZU)})}removeHandler(t,e,i){const r=this._events.get(t);if(!r)return;const s=r.get(e);s&&(s.delete(i),0===s.size&&r.delete(e),0===r.size&&(this._events.delete(t),document.removeEventListener(t,this._delegateEventHandler,ZU)))}}const QU={enterDuration:225,exitDuration:150},JU=vu({passive:!0,capture:!0}),eH=["mousedown","touchstart"],tH=["mouseup","mouseleave","touchend","touchcancel"];class Ku{constructor(t,e,i,r){this._target=t,this._ngZone=e,this._platform=r,this._isPointerDown=!1,this._activeRipples=new Map,this._pointerUpEventsRegistered=!1,r.isBrowser&&(this._containerElement=Tc(i))}fadeInRipple(t,e,i={}){const r=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),s={...QU,...i.animation};i.centered&&(t=r.left+r.width/2,e=r.top+r.height/2);const o=i.radius||function Eye(n,t,e){const i=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),r=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(i*i+r*r)}(t,e,r),a=t-r.left,l=e-r.top,c=s.enterDuration,d=document.createElement("div");d.classList.add("mat-ripple-element"),d.style.left=a-o+"px",d.style.top=l-o+"px",d.style.height=2*o+"px",d.style.width=2*o+"px",null!=i.color&&(d.style.backgroundColor=i.color),d.style.transitionDuration=`${c}ms`,this._containerElement.appendChild(d);const u=window.getComputedStyle(d),p=u.transitionDuration,f="none"===u.transitionProperty||"0s"===p||"0s, 0s"===p||0===r.width&&0===r.height,m=new Dye(this,d,i,f);d.style.transform="scale3d(1, 1, 1)",m.state=0,i.persistent||(this._mostRecentTransientRipple=m);let g=null;return!f&&(c||s.exitDuration)&&this._ngZone.runOutsideAngular(()=>{const _=()=>this._finishRippleTransition(m),b=()=>this._destroyRipple(m);d.addEventListener("transitionend",_),d.addEventListener("transitioncancel",b),g={onTransitionEnd:_,onTransitionCancel:b}}),this._activeRipples.set(m,g),(f||!c)&&this._finishRippleTransition(m),m}fadeOutRipple(t){if(2===t.state||3===t.state)return;const e=t.element,i={...QU,...t.config.animation};e.style.transitionDuration=`${i.exitDuration}ms`,e.style.opacity="0",t.state=2,(t._animationForciblyDisabledThroughCss||!i.exitDuration)&&this._finishRippleTransition(t)}fadeOutAll(){this._getActiveRipples().forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._getActiveRipples().forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=Tc(t);!this._platform.isBrowser||!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,eH.forEach(i=>{Ku._eventManager.addHandler(this._ngZone,i,e,this)}))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._ngZone.runOutsideAngular(()=>{tH.forEach(e=>{this._triggerElement.addEventListener(e,this,JU)})}),this._pointerUpEventsRegistered=!0)}_finishRippleTransition(t){0===t.state?this._startFadeOutTransition(t):2===t.state&&this._destroyRipple(t)}_startFadeOutTransition(t){const e=t===this._mostRecentTransientRipple,{persistent:i}=t.config;t.state=1,!i&&(!e||!this._isPointerDown)&&t.fadeOut()}_destroyRipple(t){const e=this._activeRipples.get(t)??null;this._activeRipples.delete(t),this._activeRipples.size||(this._containerRect=null),t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),t.state=3,null!==e&&(t.element.removeEventListener("transitionend",e.onTransitionEnd),t.element.removeEventListener("transitioncancel",e.onTransitionCancel)),t.element.remove()}_onMousedown(t){const e=g$(t),i=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!e&&!i&&(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!_$(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let i=0;i<e.length;i++)this.fadeInRipple(e[i].clientX,e[i].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._getActiveRipples().forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_getActiveRipples(){return Array.from(this._activeRipples.keys())}_removeTriggerEvents(){const t=this._triggerElement;t&&(eH.forEach(e=>Ku._eventManager.removeHandler(e,t,this)),this._pointerUpEventsRegistered&&tH.forEach(e=>t.removeEventListener(e,this,JU)))}}Ku._eventManager=new Sye;const YE=new ne("mat-ripple-global-options");let nH=(()=>{class n{get disabled(){return this._disabled}set disabled(e){e&&this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}constructor(e,i,r,s,o){this._elementRef=e,this._animationMode=o,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=s||{},this._rippleRenderer=new Ku(this,i,e,r)}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:{...this._globalOptions.animation,..."NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{},...this.animation},terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,i=0,r){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,i,{...this.rippleConfig,...r}):this._rippleRenderer.fadeInRipple(0,0,{...this.rippleConfig,...e})}}return n.\u0275fac=function(e){return new(e||n)(V(Pt),V(Qe),V(Ar),V(YE,8),V(Da,8))},n.\u0275dir=we({type:n,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,i){2&e&&ar("mat-ripple-unbounded",i.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),n})(),iH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[on,on]}),n})(),Iye=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[on]}),n})();class rH{}class Tye{}const $a="*";function oH(n,t=null){return{type:2,steps:n,options:t}}function vn(n){return{type:6,styles:n,offset:null}}function dH(n){Promise.resolve().then(n)}class Yf{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){dH(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(i=>i()),e.length=0}}class uH{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,i=0,r=0;const s=this.players.length;0==s?dH(()=>this._onFinish()):this.players.forEach(o=>{o.onDone(()=>{++e==s&&this._onFinish()}),o.onDestroy(()=>{++i==s&&this._onDestroy()}),o.onStart(()=>{++r==s&&this._onStart()})}),this.totalTime=this.players.reduce((o,a)=>Math.max(o,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(i=>{const r=i.totalTime?Math.min(1,e/i.totalTime):1;i.setPosition(r)})}getPosition(){const t=this.players.reduce((e,i)=>null===e||i.totalTime>e.totalTime?i:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(i=>i()),e.length=0}}const KE="!";function Aye(n,t){}class dv{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.maxWidth="80vw",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.ariaModal=!0,this.autoFocus="first-tabbable",this.restoreFocus=!0,this.delayFocusTrap=!0,this.closeOnNavigation=!0}}const XE="mdc-dialog--open",hH="mdc-dialog--opening",pH="mdc-dialog--closing";let Rye=(()=>{class n extends L${constructor(e,i,r,s,o,a,l,c){super(e,i,r,s,o,a,l,c),this._animationStateChanged=new $t}_captureInitialFocus(){this._config.delayFocusTrap||this._trapFocus()}_openAnimationDone(e){this._config.delayFocusTrap&&this._trapFocus(),this._animationStateChanged.next({state:"opened",totalTime:e})}}return n.\u0275fac=function(e){return new(e||n)(V(Pt),V(VS),V(bt,8),V(dv),V($b),V(Qe),V(Yp),V(Bb))},n.\u0275cmp=bi({type:n,selectors:[["ng-component"]],features:[ct],decls:0,vars:0,template:function(e,i){},encapsulation:2}),n})();const fH="--mat-dialog-transition-duration";function mH(n){return null==n?null:"number"==typeof n?n:n.endsWith("ms")?Fb(n.substring(0,n.length-2)):n.endsWith("s")?1e3*Fb(n.substring(0,n.length-1)):"0"===n?0:null}let Oye=(()=>{class n extends Rye{constructor(e,i,r,s,o,a,l,c,d){super(e,i,r,s,o,a,l,d),this._animationMode=c,this._animationsEnabled="NoopAnimations"!==this._animationMode,this._hostElement=this._elementRef.nativeElement,this._openAnimationDuration=this._animationsEnabled?mH(this._config.enterAnimationDuration)??150:0,this._closeAnimationDuration=this._animationsEnabled?mH(this._config.exitAnimationDuration)??75:0,this._animationTimer=null,this._finishDialogOpen=()=>{this._clearAnimationClasses(),this._openAnimationDone(this._openAnimationDuration)},this._finishDialogClose=()=>{this._clearAnimationClasses(),this._animationStateChanged.emit({state:"closed",totalTime:this._closeAnimationDuration})}}_contentAttached(){super._contentAttached(),this._startOpenAnimation()}ngOnDestroy(){super.ngOnDestroy(),null!==this._animationTimer&&clearTimeout(this._animationTimer)}_startOpenAnimation(){this._animationStateChanged.emit({state:"opening",totalTime:this._openAnimationDuration}),this._animationsEnabled?(this._hostElement.style.setProperty(fH,`${this._openAnimationDuration}ms`),this._hostElement.classList.add(hH),this._hostElement.classList.add(XE),this._waitForAnimationToComplete(this._openAnimationDuration,this._finishDialogOpen)):(this._hostElement.classList.add(XE),Promise.resolve().then(()=>this._finishDialogOpen()))}_startExitAnimation(){this._animationStateChanged.emit({state:"closing",totalTime:this._closeAnimationDuration}),this._hostElement.classList.remove(XE),this._animationsEnabled?(this._hostElement.style.setProperty(fH,`${this._openAnimationDuration}ms`),this._hostElement.classList.add(pH),this._waitForAnimationToComplete(this._closeAnimationDuration,this._finishDialogClose)):Promise.resolve().then(()=>this._finishDialogClose())}_clearAnimationClasses(){this._hostElement.classList.remove(hH),this._hostElement.classList.remove(pH)}_waitForAnimationToComplete(e,i){null!==this._animationTimer&&clearTimeout(this._animationTimer),this._animationTimer=setTimeout(i,e)}}return n.\u0275fac=function(e){return new(e||n)(V(Pt),V(VS),V(bt,8),V(dv),V($b),V(Qe),V(Yp),V(Da,8),V(Bb))},n.\u0275cmp=bi({type:n,selectors:[["mat-dialog-container"]],hostAttrs:["tabindex","-1",1,"mat-mdc-dialog-container","mdc-dialog"],hostVars:8,hostBindings:function(e,i){2&e&&(eb("id",i._config.id),$i("aria-modal",i._config.ariaModal)("role",i._config.role)("aria-labelledby",i._config.ariaLabel?null:i._ariaLabelledBy)("aria-label",i._config.ariaLabel)("aria-describedby",i._config.ariaDescribedBy||null),ar("_mat-animation-noopable",!i._animationsEnabled))},features:[ct],decls:3,vars:0,consts:[[1,"mdc-dialog__container"],[1,"mat-mdc-dialog-surface","mdc-dialog__surface"],["cdkPortalOutlet",""]],template:function(e,i){1&e&&(kt(0,"div",0)(1,"div",1),wi(2,Aye,0,0,"ng-template",2),Lt()())},dependencies:[YS],styles:['.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:var(--mdc-dialog-z-index, 7)}.mdc-dialog .mdc-dialog__content{padding:20px 24px 20px 24px}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:none}@media(max-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px;width:560px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 112px)}}@media(max-width: 720px)and (min-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:560px}}@media(max-width: 720px)and (max-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:calc(100vh - 160px)}}@media(max-width: 720px)and (min-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px}}@media(max-width: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 400px),(max-width: 600px),(min-width: 720px)and (max-height: 400px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100vw;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(min-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 400px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim{opacity:0}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;transform:scale(0.8);opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}[dir=rtl] .mdc-dialog__surface,.mdc-dialog__surface[dir=rtl]{text-align:right}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-dialog__surface{outline:2px solid windowText}}.mdc-dialog__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-dialog__surface::before{border-color:CanvasText}}@media screen and (-ms-high-contrast: active),screen and (-ms-high-contrast: none){.mdc-dialog__surface::before{content:none}}.mdc-dialog__title{display:block;margin-top:0;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:0 24px 9px}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mdc-dialog__title,.mdc-dialog__title[dir=rtl]{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{margin-bottom:1px;padding-bottom:15px}.mdc-dialog--fullscreen .mdc-dialog__header{align-items:baseline;border-bottom:1px solid rgba(0,0,0,0);display:inline-flex;justify-content:space-between;padding:0 24px 9px;z-index:1}@media screen and (forced-colors: active){.mdc-dialog--fullscreen .mdc-dialog__header{border-bottom-color:CanvasText}}.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close{right:-12px}.mdc-dialog--fullscreen .mdc-dialog__title{margin-bottom:0;padding:0;border-bottom:0}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:0;margin-bottom:0}.mdc-dialog--fullscreen .mdc-dialog__close{top:5px}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--fullscreen--titleless .mdc-dialog__close{margin-top:4px}.mdc-dialog--fullscreen--titleless.mdc-dialog--scrollable .mdc-dialog__close{margin-top:0}.mdc-dialog__content{flex-grow:1;box-sizing:border-box;margin:0;overflow:auto}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content,.mdc-dialog__header+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__title+.mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:none}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{transform:none;opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim{opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{transition:opacity 75ms linear}.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim{transition:opacity 150ms linear}.mdc-dialog__surface-scrim{display:none;opacity:0;position:absolute;width:100%;height:100%;z-index:1}.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{display:block}.mdc-dialog-scroll-lock{overflow:hidden}.mdc-dialog--no-content-padding .mdc-dialog__content{padding:0}.mdc-dialog--sheet .mdc-dialog__close{right:12px;top:9px;position:absolute;z-index:1}.mdc-dialog__scrim--removed{pointer-events:none}.mdc-dialog__scrim--removed .mdc-dialog__scrim,.mdc-dialog__scrim--removed .mdc-dialog__surface-scrim{display:none}.mat-mdc-dialog-content{max-height:65vh}.mat-mdc-dialog-container{position:static;display:block}.mat-mdc-dialog-container,.mat-mdc-dialog-container .mdc-dialog__container,.mat-mdc-dialog-container .mdc-dialog__surface{max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mat-mdc-dialog-container .mdc-dialog__surface{display:block;width:100%;height:100%}.mat-mdc-dialog-container{outline:0}.mat-mdc-dialog-container .mdc-dialog__surface{background-color:var(--mdc-dialog-container-color, white)}.mat-mdc-dialog-container .mdc-dialog__surface{box-shadow:var(--mdc-dialog-container-elevation, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}.mat-mdc-dialog-container .mdc-dialog__surface{border-radius:var(--mdc-dialog-container-shape, var(--mdc-shape-medium, 4px))}.mat-mdc-dialog-container.mdc-dialog--scrollable .mdc-dialog__title,.mat-mdc-dialog-container.mdc-dialog--scrollable .mdc-dialog__actions,.mat-mdc-dialog-container.mdc-dialog--scrollable.mdc-dialog-scroll-divider-footer .mdc-dialog__actions{border-color:var(--mdc-dialog-with-divider-divider-color, black)}.mat-mdc-dialog-container.mdc-dialog--scrollable .mdc-dialog__title{border-bottom-color:var(--mdc-dialog-with-divider-divider-color, black)}.mat-mdc-dialog-container .mdc-dialog__title{font-family:var(--mdc-dialog-subhead-font, "Arial");line-height:var(--mdc-dialog-subhead-line-height, 14px);font-size:var(--mdc-dialog-subhead-size, 14px);font-weight:var(--mdc-dialog-subhead-weight, 500);letter-spacing:var(--mdc-dialog-subhead-tracking, 1px)}.mat-mdc-dialog-container .mdc-dialog__title{color:var(--mdc-dialog-subhead-color, black)}.mat-mdc-dialog-container .mdc-dialog__content{font-family:var(--mdc-dialog-supporting-text-font, "Arial");line-height:var(--mdc-dialog-supporting-text-line-height, 14px);font-size:var(--mdc-dialog-supporting-text-size, 14px);font-weight:var(--mdc-dialog-supporting-text-weight, 500);letter-spacing:var(--mdc-dialog-supporting-text-tracking, 1px)}.mat-mdc-dialog-container .mdc-dialog__content{color:var(--mdc-dialog-supporting-text-color, black)}.mat-mdc-dialog-container .mdc-dialog__container{transition-duration:var(--mat-dialog-transition-duration, 0ms)}.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__container{transition:none}.mat-mdc-dialog-content{display:block}.mat-mdc-dialog-actions{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}'],encapsulation:2}),n})();class Fye{constructor(t,e,i){this._ref=t,this._containerInstance=i,this._afterOpened=new dt,this._beforeClosed=new dt,this._state=0,this.disableClose=e.disableClose,this.id=t.id,i._animationStateChanged.pipe(lr(r=>"opened"===r.state),fo(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),i._animationStateChanged.pipe(lr(r=>"closed"===r.state),fo(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),t.overlayRef.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._finishDialogClose()}),n_(this.backdropClick(),this.keydownEvents().pipe(lr(r=>27===r.keyCode&&!this.disableClose&&!xu(r)))).subscribe(r=>{this.disableClose||(r.preventDefault(),function Pye(n,t,e){n._closeInteractionType=t,n.close(e)}(this,"keydown"===r.type?"keyboard":"mouse"))})}close(t){this._result=t,this._containerInstance._animationStateChanged.pipe(lr(e=>"closing"===e.state),fo(1)).subscribe(e=>{this._beforeClosed.next(t),this._beforeClosed.complete(),this._ref.overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),e.totalTime+100)}),this._state=1,this._containerInstance._startExitAnimation()}afterOpened(){return this._afterOpened}afterClosed(){return this._ref.closed}beforeClosed(){return this._beforeClosed}backdropClick(){return this._ref.backdropClick}keydownEvents(){return this._ref.keydownEvents}updatePosition(t){let e=this._ref.config.positionStrategy;return t&&(t.left||t.right)?t.left?e.left(t.left):e.right(t.right):e.centerHorizontally(),t&&(t.top||t.bottom)?t.top?e.top(t.top):e.bottom(t.bottom):e.centerVertically(),this._ref.updatePosition(),this}updateSize(t="",e=""){return this._ref.updateSize(t,e),this}addPanelClass(t){return this._ref.addPanelClass(t),this}removePanelClass(t){return this._ref.removePanelClass(t),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._ref.close(this._result,{focusOrigin:this._closeInteractionType}),this.componentInstance=null}}const Lye=new ne("MatMdcDialogData"),$ye=new ne("mat-mdc-dialog-default-options"),gH=new ne("mat-mdc-dialog-scroll-strategy"),Bye={provide:gH,deps:[cl],useFactory:function Vye(n){return()=>n.scrollStrategies.block()}};let zye=0,Uye=(()=>{class n{get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const e=this._parentDialog;return e?e._getAfterAllClosed():this._afterAllClosedAtThisLevel}constructor(e,i,r,s,o,a,l,c,d,u){this._overlay=e,this._defaultOptions=r,this._parentDialog=s,this._dialogRefConstructor=l,this._dialogContainerType=c,this._dialogDataToken=d,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new dt,this._afterOpenedAtThisLevel=new dt,this._idPrefix="mat-dialog-",this.dialogConfigClass=dv,this.afterAllClosed=Gb(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Wp(void 0))),this._scrollStrategy=a,this._dialog=i.get(V$)}open(e,i){let r;(i={...this._defaultOptions||new dv,...i}).id=i.id||`${this._idPrefix}${zye++}`,i.scrollStrategy=i.scrollStrategy||this._scrollStrategy();const s=this._dialog.open(e,{...i,positionStrategy:this._overlay.position().global().centerHorizontally().centerVertically(),disableClose:!0,closeOnDestroy:!1,closeOnOverlayDetachments:!1,container:{type:this._dialogContainerType,providers:()=>[{provide:this.dialogConfigClass,useValue:i},{provide:qb,useValue:i}]},templateContext:()=>({dialogRef:r}),providers:(o,a,l)=>(r=new this._dialogRefConstructor(o,i,l),r.updatePosition(i?.position),[{provide:this._dialogContainerType,useValue:l},{provide:this._dialogDataToken,useValue:a.data},{provide:this._dialogRefConstructor,useValue:r}])});return r.componentInstance=s.componentInstance,this.openDialogs.push(r),this.afterOpened.next(r),r.afterClosed().subscribe(()=>{const o=this.openDialogs.indexOf(r);o>-1&&(this.openDialogs.splice(o,1),this.openDialogs.length||this._getAfterAllClosed().next())}),r}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(e){return this.openDialogs.find(i=>i.id===e)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_closeDialogs(e){let i=e.length;for(;i--;)e[i].close()}}return n.\u0275fac=function(e){bp()},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})(),_H=(()=>{class n extends Uye{constructor(e,i,r,s,o,a,l,c){super(e,i,s,a,l,o,Fye,Oye,Lye,c),this._idPrefix="mat-mdc-dialog-"}}return n.\u0275fac=function(e){return new(e||n)(Y(cl),Y(Li),Y(Pp,8),Y($ye,8),Y(gH),Y(n,12),Y(Wb),Y(Da,8))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})(),bH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({providers:[_H,Bye],imports:[B$,Kp,Ac,on,on]}),n})();const Hye=["mat-button",""],jye=[[["",8,"material-icons",3,"iconPositionEnd",""],["mat-icon",3,"iconPositionEnd",""],["","matButtonIcon","",3,"iconPositionEnd",""]],"*",[["","iconPositionEnd","",8,"material-icons"],["mat-icon","iconPositionEnd",""],["","matButtonIcon","","iconPositionEnd",""]]],Wye=[".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])","*",".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]"],Gye=[{selector:"mat-button",mdcClasses:["mdc-button","mat-mdc-button"]},{selector:"mat-flat-button",mdcClasses:["mdc-button","mdc-button--unelevated","mat-mdc-unelevated-button"]},{selector:"mat-raised-button",mdcClasses:["mdc-button","mdc-button--raised","mat-mdc-raised-button"]},{selector:"mat-stroked-button",mdcClasses:["mdc-button","mdc-button--outlined","mat-mdc-outlined-button"]},{selector:"mat-fab",mdcClasses:["mdc-fab","mat-mdc-fab"]},{selector:"mat-mini-fab",mdcClasses:["mdc-fab","mdc-fab--mini","mat-mdc-mini-fab"]},{selector:"mat-icon-button",mdcClasses:["mdc-icon-button","mat-mdc-icon-button"]}],qye=xye(vye(wye(class{constructor(n){this._elementRef=n}})));let Yye=(()=>{class n extends qye{constructor(e,i,r,s){super(e),this._platform=i,this._ngZone=r,this._animationMode=s,this._focusMonitor=lt(Bb),this._isFab=!1;const o=e.nativeElement.classList;for(const a of Gye)this._hasHostAttributes(a.selector)&&a.mdcClasses.forEach(l=>{o.add(l)})}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(e="program",i){e?this._focusMonitor.focusVia(this._elementRef.nativeElement,e,i):this._elementRef.nativeElement.focus(i)}_hasHostAttributes(...e){return e.some(i=>this._elementRef.nativeElement.hasAttribute(i))}_isRippleDisabled(){return this.disableRipple||this.disabled}}return n.\u0275fac=function(e){bp()},n.\u0275dir=we({type:n,viewQuery:function(e,i){if(1&e&&pu(nH,5),2&e){let r;Ms(r=Ns())&&(i.ripple=r.first)}},features:[ct]}),n})(),Xye=(()=>{class n extends Yye{constructor(e,i,r,s){super(e,i,r,s)}}return n.\u0275fac=function(e){return new(e||n)(V(Pt),V(Ar),V(Qe),V(Da,8))},n.\u0275cmp=bi({type:n,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-flat-button",""],["button","mat-stroked-button",""]],hostVars:7,hostBindings:function(e,i){2&e&&($i("disabled",i.disabled||null),ar("_mat-animation-noopable","NoopAnimations"===i._animationMode)("mat-unthemed",!i.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[ct],attrs:Hye,ngContentSelectors:Wye,decls:8,vars:6,consts:[[1,"mat-mdc-button-persistent-ripple"],[1,"mdc-button__label"],[1,"mat-mdc-focus-indicator"],["matRipple","",1,"mat-mdc-button-ripple",3,"matRippleDisabled","matRippleTrigger"],[1,"mat-mdc-button-touch-target"]],template:function(e,i){1&e&&(rl(jye),Ci(0,"span",0),Vi(1),kt(2,"span",1),Vi(3,1),Lt(),Vi(4,2),Ci(5,"span",2)(6,"span",3)(7,"span",4)),2&e&&(ar("mdc-button__ripple",!i._isFab)("mdc-fab__ripple",i._isFab),xi(6),ai("matRippleDisabled",i._isRippleDisabled())("matRippleTrigger",i._elementRef.nativeElement))},dependencies:[nH],styles:['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button{position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0)}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__progress-indicator{font-size:0;position:absolute;transform:translate(-50%, -50%);top:50%;left:50%;line-height:initial}.mdc-button .mdc-button__label{position:relative}.mdc-button .mdc-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    );display:none}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring{border-color:CanvasText}}.mdc-button .mdc-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring::after{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{display:block}}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button{padding:0 8px 0 8px}.mdc-button--unelevated{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--unelevated.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--unelevated.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--raised{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--raised.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--raised.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--outlined{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--outlined .mdc-button__ripple{border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button{height:var(--mdc-text-button-container-height, 36px);border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, inherit)}.mat-mdc-button:disabled{color:var(--mdc-text-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button{height:var(--mdc-filled-button-container-height, 36px);border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button:not(:disabled){background-color:var(--mdc-filled-button-container-color, transparent)}.mat-mdc-unelevated-button:disabled{background-color:var(--mdc-filled-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, inherit)}.mat-mdc-unelevated-button:disabled{color:var(--mdc-filled-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button{height:var(--mdc-protected-button-container-height, 36px);border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px));box-shadow:var(--mdc-protected-button-container-elevation, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){background-color:var(--mdc-protected-button-container-color, transparent)}.mat-mdc-raised-button:disabled{background-color:var(--mdc-protected-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, inherit)}.mat-mdc-raised-button:disabled{color:var(--mdc-protected-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button.mdc-ripple-upgraded--background-focused,.mat-mdc-raised-button:not(.mdc-ripple-upgraded):focus{box-shadow:var(--mdc-protected-button-focus-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled):active{box-shadow:var(--mdc-protected-button-pressed-container-elevation, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button{height:var(--mdc-outlined-button-container-height, 36px);border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px));padding:0 15px 0 15px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, inherit)}.mat-mdc-outlined-button:disabled{color:var(--mdc-outlined-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-outlined-button .mdc-button__ripple{border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-outlined-button:not(:disabled){border-color:var(--mdc-outlined-button-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button:disabled{border-color:var(--mdc-outlined-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button.mdc-button--icon-trailing{padding:0 11px 0 15px}.mat-mdc-outlined-button.mdc-button--icon-leading{padding:0 15px 0 11px}.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button .mdc-button__touch{left:calc(-1 * var(--mdc-outlined-button-outline-width, 1px));width:calc(100% + 2 * var(--mdc-outlined-button-outline-width, 1px))}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-button .mat-ripple-element,.mat-mdc-unelevated-button .mat-ripple-element,.mat-mdc-raised-button .mat-ripple-element,.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-button .mdc-button__label,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-outlined-button .mdc-button__label{z-index:1}.mat-mdc-button .mat-mdc-focus-indicator,.mat-mdc-unelevated-button .mat-mdc-focus-indicator,.mat-mdc-raised-button .mat-mdc-focus-indicator,.mat-mdc-outlined-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-unelevated-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-raised-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-outlined-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-button[disabled],.mat-mdc-unelevated-button[disabled],.mat-mdc-raised-button[disabled],.mat-mdc-outlined-button[disabled]{cursor:default;pointer-events:none}.mat-mdc-button .mat-mdc-button-touch-target,.mat-mdc-unelevated-button .mat-mdc-button-touch-target,.mat-mdc-raised-button .mat-mdc-button-touch-target,.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}[dir=rtl] .mat-mdc-button>.mat-icon,.mat-mdc-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}.mat-mdc-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon,.mat-mdc-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem;margin-left:-4px;margin-right:8px}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon,.mat-mdc-raised-button .mdc-button__label+.mat-icon,.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon,.mat-mdc-unelevated-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-raised-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-outlined-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:-1px}.mat-mdc-unelevated-button .mat-mdc-focus-indicator::before,.mat-mdc-raised-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-outlined-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 3px) * -1)}',".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"],encapsulation:2,changeDetection:0}),n})(),uv=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[on,iH,on]}),n})();class Kf{constructor(t,e){this.router=t,this.dialog=e}ngOnInit(){}onOpenUserLoginDialog(){}onOpenUserRegistrationDialog(){}onOpenLinearRegression(){this.router.navigate(["/linear-regression"])}onOpenMnistHandwriting(){this.router.navigate(["/mnist-handwriting"])}}function vH(n,t,e,i,r,s,o){try{var a=n[s](o),l=a.value}catch(c){return void e(c)}a.done?t(l):Promise.resolve(l).then(i,r)}function ie(n){return function(){var t=this,e=arguments;return new Promise(function(i,r){var s=n.apply(t,e);function o(l){vH(s,i,r,o,a,"next",l)}function a(l){vH(s,i,r,o,a,"throw",l)}o(void 0)})}}Kf.\u0275fac=function(t){return new(t||Kf)(V(jr),V(_H))},Kf.\u0275cmp=bi({type:Kf,selectors:[["app-welcome-page"]],decls:19,vars:0,consts:[[1,"page-main"],[1,"page-header"],[1,"page-animation"],["src","https://media1.giphy.com/media/gkpnGTiy8Sq08/giphy.gif?cid=ecf05e473jirga20m0a29kqe2ubzf83o6q5mg1cfqh5tirld&rid=giphy.gif&ct=g","alt","Smart Crow","title","Smart Crow GIF By GIPHY","width","300"],["href","https://giphy.com/gifs/gkpnGTiy8Sq08","target","_blank","rel","noopener noreferrer"],[1,"page-actions"],["mat-raised-button","","color","default",2,"margin-left","10px",3,"click"]],template:function(t,e){1&t&&(kt(0,"div",0)(1,"div",1)(2,"h1"),as(3,"Welcome to Musto Smart App"),Lt()(),kt(4,"div",2),Ci(5,"img",3),kt(6,"p")(7,"a",4),as(8,"via GIPHY"),Lt()()(),kt(9,"div",5)(10,"button",6),An("click",function(){return e.onOpenUserLoginDialog()}),as(11,"Login"),Lt(),kt(12,"button",6),An("click",function(){return e.onOpenUserRegistrationDialog()}),as(13,"Sign Up"),Lt(),Ci(14,"br"),kt(15,"button",6),An("click",function(){return e.onOpenLinearRegression()}),as(16,"Linear Regression"),Lt(),kt(17,"button",6),An("click",function(){return e.onOpenMnistHandwriting()}),as(18,"MNIST Handwriting"),Lt()()())},dependencies:[Xye],styles:[".page-main[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;height:100%;width:95%;margin:0 auto}.page-header[_ngcontent-%COMP%]{padding:1rem;margin:2rem 0;text-align:center;border-radius:.375rem;box-shadow:1px 1px 15px #00000030}.page-animation[_ngcontent-%COMP%]{padding:1rem;text-align:center;border-radius:.375rem}.page-animation[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{border-radius:.375rem}@media all and (max-width: 576px){.page-animation[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{display:block;margin:0 auto;width:80%}}.page-actions[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;width:100%}.page-actions[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{margin:0 .5rem}"]});class xH{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class ZE{refCount(t){return Wr("refCount")}incRef(t){return Wr("incRef")}timerAvailable(){return!0}time(t){return Wr("time")}read(t){return Wr("read")}readSync(t){return Wr("readSync")}readToGPU(t,e){return Wr("readToGPU")}numDataIds(){return Wr("numDataIds")}disposeData(t,e){return Wr("disposeData")}write(t,e,i){return Wr("write")}move(t,e,i,r,s){return Wr("move")}createTensorFromGPUData(t,e,i){return Wr("createTensorFromGPUData")}memory(){return Wr("memory")}floatPrecision(){return Wr("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Wr("dispose")}}function Wr(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function wH(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Il(n,t,e)}function Yc(n,t,e){return Math.max(n,Math.min(t,e))}function QE(n){return n%2==0?n:n+1}function Il(n,t,e){const i=n[t];n[t]=n[e],n[e]=i}function S(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function zs(n,t,e=""){S(Ut(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function JE(n){S(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function K(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function Ut(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Xu(n){return n%1==0}function eI(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Zu(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function CH(n,t=(r=>0),e,i){return new Promise((r,s)=>{let o=0;const a=()=>{if(n())return void r();o++;const l=t(o);null!=e&&o>=e?s():null!=i?i(a,l):setTimeout(a,l)};a()})}function DH(n,t){let e=1,i=-1;for(let s=0;s<n.length;++s)if(n[s]>=0)e*=n[s];else if(-1===n[s]){if(-1!==i)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${i} and dim ${s}`);i=s}else if(n[s]<0)throw Error(`Shapes can not be < 0. Found ${n[s]} at dim ${s}`);if(-1===i){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const r=n.slice();return r[i]=t/e,r}function yt(n,t){const e=t.length;return S((n=null==n?t.map((i,r)=>r):[].concat(n)).every(i=>i>=-e&&i<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),S(n.every(i=>Xu(i)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(i=>i<0?e+i:i)}function Tl(n,t){const e=[],i=[],r=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||r?null:yt(t,n).sort();let o=0;for(let a=0;a<n.length;++a){if(null!=s){if(s[o]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==s[o]||s[o]>a)&&1===n[a]&&(e.push(n[a]),i.push(a)),s[o]<=a&&o++}1!==n[a]&&(e.push(n[a]),i.push(a))}return{newShape:e,keptDims:i}}function zi(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);e=new Uint8Array(t)}return e}function ii(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function SH(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function hv(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function Xf(n){return"string"==typeof n||n instanceof String}function tI(n){return"number"==typeof n}function Zf(n){return Array.isArray(n)?Zf(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":tI(n)?"float32":Xf(n)?"string":function rve(n){return"boolean"==typeof n}(n)?"bool":"float32"}function nI(n){return!!(n&&n.constructor&&n.call&&n.apply)}function iI(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Le(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let i=t-3;i>=0;--i)e[i]=e[i+1]*n[i+1];return e}function kH(n,t,e,i=!1){const r=new Array;if(1===t.length){const s=t[0]*(i?2:1);for(let o=0;o<s;o++)r[o]=e[n+o]}else{const s=t[0],o=t.slice(1),a=o.reduce((l,c)=>l*c)*(i?2:1);for(let l=0;l<s;l++)r[l]=kH(n+l*a,o,e,i)}return r}function _o(n,t,e=!1){if(0===n.length)return t[0];const i=n.reduce((r,s)=>r*s)*(e?2:1);if(0===i)return[];if(i!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return kH(0,n,t,e)}function rI(n,t){const e=Xi(n,t);for(let i=0;i<e.length;i++)e[i]=1;return e}function Xi(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function EH(n,t){const e=n.reduce((i,r)=>i*r,1);if(null==t||"float32"===t)return _o(n,new Float32Array(e));if("int32"===t)return _o(n,new Int32Array(e));if("bool"===t)return _o(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Ba(n){n.forEach(t=>{S(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Xo(n,t,e){if(0===t)return 0;if(1===t)return n[0];let i=n[n.length-1];for(let r=0;r<n.length-1;++r)i+=e[r]*n[r];return i}function Qu(n,t,e){if(0===t)return[];if(1===t)return[n];const i=new Array(t);for(let r=0;r<i.length-1;++r)i[r]=Math.floor(n/e[r]),n-=i[r]*e[r];return i[i.length-1]=n,i}function sI(n){return n&&n.then&&"function"==typeof n.then}const IH="tfjsflags";class ove{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=ave,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(q().getBool("IS_TEST")||q().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,i){if(this.flagRegistry[t]={evaluationFn:e,setHook:i},null!=this.urlFlags[t]){const r=this.urlFlags[t];q().getBool("IS_TEST")||q().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}getAsync(t){var e=this;return ie(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(sI(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);IH in t&&t[IH].split(",").forEach(i=>{const[r,s]=i.split(":");this.urlFlags[r]=function cve(n,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${n}.`)}(r,s)})}}function ave(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...i)=>(function lve(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,i[0],i[1]),i.join("="))),t}function q(){return TH}let oI,TH=null;function AH(){if(null==oI){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");n=self}oI=n}return oI}function aI(n,t){const e=function uve(){const n=AH();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const i=t();return e.set(n,i),e.get(n)}}const pv="Abs",Qf="Acos",Jf="Acosh",Ju="Add",lI="AddN",fv="ArgMax",mv="ArgMin",em="Asin",tm="Asinh",nm="Atan",im="Atanh",rm="Atan2",gv="AvgPool",uI="AvgPoolGrad",_v="AvgPool3D",hI="AvgPool3DGrad",bv="BatchMatMul",yv="BatchToSpaceND",pI="Bincount",MH="BroadcastArgs",sm="Cast",om="Ceil",am="ClipByValue",fI="Complex",vv="ComplexAbs",xv="Concat",wv="Conv2D",mI="Conv2DBackpropFilter",Cv="Conv2DBackpropInput",Dv="Conv3D",gI="Conv3DBackpropFilterV2",_I="Conv3DBackpropInputV2",lm="Cos",cm="Cosh",bI="Cumprod",Sv="Cumsum",yI="CropAndResize",vI="DenseBincount",xI="DepthToSpace",kv="DepthwiseConv2dNative",wI="DepthwiseConv2dNativeBackpropFilter",CI="DepthwiseConv2dNativeBackpropInput",Ev="Dilation2D",DI="Dilation2DBackpropInput",SI="Dilation2DBackpropFilter",dm="RealDiv",um="Elu",kI="EluGrad",hm="Erf",Iv="Equal",pm="Exp",Tv="ExpandDims",fm="Expm1",II="Fill",TI="FlipLeftRight",mm="Floor",gm="FloorDiv",Av="FusedBatchNorm",Mv="GatherV2",OH="GatherNd",Nv="Greater",_m="GreaterEqual",bm="Identity",AI="IFFT",MI="Imag",ym="IsFinite",vm="IsInf",xm="IsNan",Rv="LeakyRelu",Ov="Less",Fv="LessEqual",FH="LinSpace",wm="Log",Cm="Log1p",Pv="LogicalAnd",Lv="LogicalNot",$v="LogicalOr",Vv="LRN",NI="LRNGrad",Bv="Max",Dm="Maximum",zv="MaxPool",RI="MaxPoolGrad",Uv="MaxPool3D",OI="MaxPool3DGrad",PH="MaxPoolWithArgmax",Hv="Mean",jv="Min",Sm="Minimum",Wv="MirrorPad",km="Mod",LH="Multinomial",Em="Multiply",Gv="Neg",qv="NotEqual",FI="NonMaxSuppressionV3",PI="NonMaxSuppressionV4",LI="NonMaxSuppressionV5",Yv="OnesLike",Kv="OneHot",Xv="Pack",Zv="PadV2",Im="Pow",Qv="Prelu",Jv="Prod",$H="RaggedGather",VH="RaggedRange",BH="RaggedTensorToTensor",$I="Range",VI="Real",Tm="Reciprocal",Am="Relu",ex="Reshape",tx="ResizeNearestNeighbor",BI="ResizeNearestNeighborGrad",nx="ResizeBilinear",zI="ResizeBilinearGrad",Mm="Relu6",ix="Reverse",Nm="Round",Rm="Rsqrt",zH="ScatterNd",UH="SearchSorted",rx="Select",Om="Selu",sx="Slice",Fm="Sin",Pm="Sinh",Lm="Sign",$m="Sigmoid",Vm="Softplus",Bm="Sqrt",ox="Sum",ax="SpaceToBatchND",lx="SplitV",cx="Softmax",UI="SparseFillEmptyRows",HI="SparseReshape",jI="SparseSegmentMean",WI="SparseSegmentSum",HH="SparseToDense",zm="SquaredDifference",GI="Square",qI="StridedSlice",YI="StringNGrams",KI="StringSplit",XI="StringToHashBucketFast",Um="Sub",Hm="Tan",jm="Tanh",Wm="Tile",ZI="TopK",QI="Transform",eh="Transpose",JI="Unique",dx="Unpack",ux="UnsortedSegmentSum",hx="ZerosLike",Gm="Step",e1="FromPixels",t1="RotateWithOffset",px="_FusedMatMul",fx="FusedConv2D",mx="FusedDepthwiseConv2D";function hs(...n){q().getBool("IS_TEST")||q().getBool("PROD")||console.warn(...n)}function fve(...n){q().getBool("IS_TEST")||q().getBool("PROD")||console.log(...n)}const th=aI("kernelRegistry",()=>new Map),qm=aI("gradRegistry",()=>new Map);function n1(n,t){const e=o1(n,t);return th.get(e)}function jH(n){return qm.get(n)}function r1(n){const t=th.entries(),e=[];for(;;){const{done:i,value:r}=t.next();if(i)break;const[s,o]=r,[a]=s.split("_");a===n&&e.push(o)}return e}function s1(n){const{kernelName:t,backendName:e}=n,i=o1(t,e);th.has(i)&&hs(`The kernel '${t}' for backend '${e}' is already registered`),th.set(i,n)}function mve(n){const{kernelName:t}=n;qm.has(t)&&q().getBool("DEBUG")&&hs(`Overriding the gradient for '${t}'`),qm.set(t,n)}function o1(n,t){return`${t}_${n}`}var WH=fe(658);const Kc=fe.n(WH)()||WH;function gx(n){return Kc.fromString(n,!0,16)}const GH=gx("c3a5c85c97cb3127"),Xc=gx("b492b66fbe98f273"),hr=gx("9ae16a3b2f90404f");function a1(n){return n.xor(n.shru(47))}function qH(n,t,e){const i=n.slice(t,t+e);return Kc.fromBytes(Array.from(i),!0,!0)}function cn(n,t){return qH(n,t,8)}function YH(n,t){return qH(n,t,4)}function Ei(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function Al(n,t,e=gx("9ddfea08eb382d69")){let i=n.xor(t).mul(e);i=i.xor(i.shru(47));let r=t.xor(i).mul(e);return r=r.xor(r.shru(47)),r=r.mul(e),r}function _x(n,t,e,i){return function _ve(n,t,e,i,r,s){r=r.add(n),s=Ei(s.add(r).add(i),21);const o=r;return r=(r=r.add(t)).add(e),s=s.add(Ei(r,44)),[r.add(i),s.add(o)]}(cn(n,t),cn(n,t+8),cn(n,t+16),cn(n,t+24),e,i)}function xve(n,t=n.length){const e=Kc.fromNumber(81,!0);if(t<=32)return t<=16?function bve(n,t=n.length){if(t>=8){const e=hr.add(2*t),i=cn(n,0).add(hr),r=cn(n,t-8);return Al(Ei(r,37).mul(e).add(i),Ei(i,25).add(r).mul(e),e)}if(t>=4){const e=hr.add(2*t);return Al(YH(n,0).shl(3).add(t),YH(n,t-4),e)}if(t>0){const o=t+(n[t-1]<<2);return a1(hr.mul(n[0]+(n[t>>1]<<8)).xor(GH.mul(o))).mul(hr)}return hr}(n,t):function yve(n,t=n.length){const e=hr.add(2*t),i=cn(n,0).mul(Xc),r=cn(n,8),s=cn(n,t-8).mul(e),o=cn(n,t-16).mul(hr);return Al(Ei(i.add(r),43).add(Ei(s,30)).add(o),i.add(Ei(r.add(hr),18)).add(s),e)}(n,t);if(t<=64)return function vve(n,t=n.length){const e=hr.add(2*t),i=cn(n,0).mul(hr),r=cn(n,8),s=cn(n,t-8).mul(e),o=cn(n,t-16).mul(hr),a=Ei(i.add(r),43).add(Ei(s,30)).add(o),l=Al(a,i.add(Ei(r.add(hr),18)).add(s),e),c=cn(n,16).mul(e),d=cn(n,24),u=a.add(cn(n,t-32)).mul(e),h=l.add(cn(n,t-24)).mul(e);return Al(Ei(c.add(d),43).add(Ei(u,30)).add(h),c.add(Ei(d.add(i),18)).add(u),e)}(n,t);let i=e,r=e.mul(Xc).add(113),s=a1(r.mul(hr).add(113)).mul(hr),o=[Kc.UZERO,Kc.UZERO],a=[Kc.UZERO,Kc.UZERO];i=i.mul(hr).add(cn(n,0));let l=0;const c=64*(t-1>>6),d=c+(t-1&63)-63;do{i=Ei(i.add(r).add(o[0]).add(cn(n,l+8)),37).mul(Xc),r=Ei(r.add(o[1]).add(cn(n,l+48)),42).mul(Xc),i=i.xor(a[1]),r=r.add(o[0]).add(cn(n,l+40)),s=Ei(s.add(a[0]),33).mul(Xc),o=_x(n,l,o[1].mul(Xc),i.add(a[0])),a=_x(n,l+32,s.add(a[1]),r.add(cn(n,l+16))),[s,i]=[i,s],l+=64}while(l!==c);const u=Xc.add(s.and(255).shl(1));return l=d,a[0]=a[0].add(t-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),i=Ei(i.add(r).add(o[0]).add(cn(n,l+8)),37).mul(u),r=Ei(r.add(o[1]).add(cn(n,l+48)),42).mul(u),i=i.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(cn(n,l+40))),s=Ei(s.add(a[0]),33).mul(u),o=_x(n,l,o[1].mul(u),i.add(a[0])),a=_x(n,l+32,s.add(a[1]),r.add(cn(n,l+16))),[s,i]=[i,s],Al(Al(o[0],a[0],u).add(a1(r).mul(GH)).add(s),Al(o[1],a[1],u).add(i),u)}function Ml(n,t){return"string"===t?Nl(n):Zc([n],t)}function Zc(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Qc(n)),q().getBool("DEBUG")&&function tve(n,t){for(let e=0;e<n.length;e++){const i=n[e];if(isNaN(i)||!isFinite(i))throw Error(`A tensor of type ${t} being uploaded contains ${i}.`)}}(n,t),function wve(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let i=0;i<e.length;++i)0!==Math.round(n[i])&&(e[i]=1);return e}throw new Error(`Unknown data type ${t}`)}function Fr(){return q().platform.now()}function Nl(n,t="utf-8"){return t=t||"utf-8",q().platform.encode(n,t)}function Rl(n,t="utf-8"){return t=t||"utf-8",q().platform.decode(n,t)}function bo(n){return q().platform.isTypedArray(n)}function Qc(n,t=[],e=!1){if(null==t&&(t=[]),"boolean"==typeof n||"number"==typeof n||"string"==typeof n||sI(n)||null==n||bo(n)&&e)t.push(n);else if(Array.isArray(n)||bo(n))for(let i=0;i<n.length;++i)Qc(n[i],t,e);else{let i=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(i=Math.max(i,Number(r)));for(let r=0;r<=i;r++)Qc(n[r],t,e)}return t}class Cve{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Sve)}profileKernel(t,e,i){let r;const s=()=>{r=i()};let o;const a=Fr();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:Fr()-a})}if(q().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const d=r[c];d.data().then(u=>{Dve(u,d.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>null!=c.getExtraProfileInfo?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:i,timeMs:r,inputs:s,extraInfo:o}=t;i.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],s,l[2])})})}}function Dve(n,t,e){if("float32"!==t)return!1;for(let i=0;i<n.length;i++){const r=n[i];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${e}'`),!0}return!1}class Sve{logKernelProfile(t,e,i,r,s,o){const a="number"==typeof r?Zu(`${r}ms`,9):r.error,l=Zu(t,25),c=e.rank,d=e.size,u=Zu(e.shape.toString(),14);let h="";for(const p in s){const f=s[p];if(null!=f){const m=f.shape||e.shape,g=m.length;h+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}\t%c${a}\t%c${c}D ${u}\t%c${d}\t%c${h}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const KH=20,Ym=3,l1=7;function Ive(n,t,e,i){const r=Le(t),s=function Tve(n,t,e,i){const r=K(t),s=i[i.length-1],o=new Array(s).fill(0),a=t.length,l="complex64"===e?Xm(n):n;if(a>1)for(let c=0;c<r/s;c++){const d=c*s;for(let u=0;u<s;u++)o[u]=Math.max(o[u],Km(l[d+u],0,e).length)}return o}(n,t,e,r),o=t.length,a=bx(n,t,e,r,s),l=["Tensor"];return i&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join("\n")),l.join("\n")}function Km(n,t,e){let i;return i=Array.isArray(n)?`${parseFloat(n[0].toFixed(l1))} + ${parseFloat(n[1].toFixed(l1))}j`:Xf(n)?`'${n}'`:"bool"===e?XH(n):parseFloat(n.toFixed(l1)).toString(),Zu(i,t)}function XH(n){return 0===n?"false":"true"}function bx(n,t,e,i,r,s=!0){const o="complex64"===e?2:1,a=t[0],l=t.length;if(0===l)return"complex64"===e?[Km(Xm(n)[0],0,e)]:"bool"===e?[XH(n[0])]:[n[0].toString()];if(1===l){if(a>KH){let _=Array.from(n.slice(0,Ym*o)),b=Array.from(n.slice((a-Ym)*o,a*o));return"complex64"===e&&(_=Xm(_),b=Xm(b)),["["+_.map((y,v)=>Km(y,r[v],e)).join(", ")+", ..., "+b.map((y,v)=>Km(y,r[a-Ym+v],e)).join(", ")+"]"]}return["["+("complex64"===e?Xm(n):Array.from(n)).map((g,_)=>Km(g,r[_],e)).join(", ")+"]"]}const c=t.slice(1),d=i.slice(1),u=i[0]*o,h=[];if(a>KH){for(let m=0;m<Ym;m++){const g=m*u;h.push(...bx(n.slice(g,g+u),c,e,d,r,!1))}h.push("...");for(let m=a-Ym;m<a;m++){const g=m*u;h.push(...bx(n.slice(g,g+u),c,e,d,r,m===a-1))}}else for(let m=0;m<a;m++){const g=m*u;h.push(...bx(n.slice(g,g+u),c,e,d,r,m===a-1))}const p=2===l?",":"";h[0]="["+(a>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function Xm(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class Zi{constructor(t,e,i){if(this.dtype=e,this.shape=t.slice(),this.size=K(t),null!=i){const r=i.length;S(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=i||ii(e,this.size),this.strides=Le(t)}set(t,...e){0===e.length&&(e=[0]),S(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const i=this.locToIndex(e);this.values[i]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let i=t[t.length-1];for(let r=0;r<t.length-1;++r)i+=this.strides[r]*t[r];return this.values[i]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let i=0;i<t.length-1;++i)e+=this.strides[i]*t[i];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let i=0;i<e.length-1;++i)e[i]=Math.floor(t/this.strides[i]),t-=e[i]*this.strides[i];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return yo().makeTensor(this.values,this.shape,this.dtype)}}let yo=null,nh=null,ZH=null;class qn{constructor(t,e,i,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=K(t),this.strides=Le(t),this.dataId=i,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return ie(function*(){const e=yield t.data();return nh.buffer(t.shape,t.dtype,e)})()}bufferSync(){return nh.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return ie(function*(){const e=yield t.data();return _o(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return _o(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return ie(function*(){t.throwIfDisposed();const e=yo().read(t.dataId);if("string"===t.dtype){const i=yield e;try{return i.map(r=>Rl(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),yo().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=yo().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>Rl(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return ie(function*(){t.throwIfDisposed();const e=yield yo().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(yo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return nh.print(this,t)}clone(){return this.throwIfDisposed(),nh.clone(this)}toString(t=!1){return Ive(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),nh.cast(this,t)}variable(t=!0,e,i){return this.throwIfDisposed(),yo().makeVariable(this,t,e,i)}}function X(){return aI("Tensor",()=>qn)}Object.defineProperty(qn,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),X();class yx extends qn{constructor(t,e,i,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=i}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Ut(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);yo().disposeTensor(this),this.dataId=t.dataId,yo().incRef(this,null)}dispose(){yo().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(yx,Symbol.hasInstance,{value:n=>n instanceof qn&&null!=n.assign&&n.assign instanceof Function});var vx=(()=>(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"}(vx||(vx={})),vx))(),xx=(()=>(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"}(xx||(xx={})),xx))(),wx=(()=>(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"}(wx||(wx={})),wx))(),Cx=(()=>(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"}(Cx||(Cx={})),Cx))();const Rve={float32:wx,int32:vx,bool:xx,complex64:Cx};function Gr(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return Rve[n][t]}function c1(n){return Gr(n,"int32")}function Vn(n,t){if(n.dtype===t.dtype)return[n,t];const e=Gr(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function QH(n){const t=[];return JH(n,t,new Set),t}function JH(n,t,e){if(null==n)return;if(n instanceof qn)return void t.push(n);if(!function Ove(n){return Array.isArray(n)||"object"==typeof n}(n))return;const i=n;for(const r in i){const s=i[r];e.has(s)||(e.add(s),JH(s,t,e))}}function d1(n){return null!=n.kernelName}class e4{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let Fve=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new e4}ready(){var e=this;return ie(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const i=e.getSortedBackends();for(let r=0;r<i.length;r++){const s=i[r];if(yield e.initializeBackend(s).success)return void(yield e.setBackend(s))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:i}=this.initializeBackendsAndReturnBest();if(i)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:i}=this.initializeBackend(e);if(i)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,i,r=1){return e in this.registryFactory?(hs(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:i,priority:r},!0)}setBackend(e){var i=this;return ie(function*(){if(null==i.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(i.backendName=e,null==i.registry[e]){i.backendInstance=null;const{success:r,asyncInit:s}=i.initializeBackend(e);if(!(s?yield r:r))return!1}return i.backendInstance=i.registry[e],i.setupRegisteredKernels(),i.profiler=new Cve(i.backendInstance),!0})()}setupRegisteredKernels(){r1(this.backendName).forEach(i=>{null!=i.setupFunc&&i.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){r1(e).forEach(r=>{null!=r.disposeFunc&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const i=this.registryFactory[e];if(null==i)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=i.factory();if(!r||r instanceof ZE||"function"!=typeof r.then)return this.registry[e]=r,{success:!0,asyncInit:!1};{const s=++this.pendingBackendInitId,o=r.then(a=>!(s<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,hs(`Initialization of backend ${e} failed`),hs(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(r){return hs(`Initialization of backend ${e} failed`),hs(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,i)=>this.registryFactory[i].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let i=0;i<e.length;i++){const r=e[i],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,i){const r=this.state.tensorInfo.get(i),s=r.backend,o=this.readSync(i),a=s.refCount(i);s.disposeData(i,!0),r.backend=e,e.move(i,o,r.shape,r.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,i){let s,r=null;if(null==i){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");i=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof i)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=i(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,i,r){e();try{const s=r();return i(),s}catch(s){throw i(),s}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const i=O.runKernel(bm,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[i],a=>({x:()=>O.runKernel(sm,{x:a},{dtype:"float32"})}),[],{}),i}runKernel(e,i,r){if(null==n1(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:i,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,i,r){const s=this.backend.numDataIds();let o=0;r.forEach(c=>{o+="complex64"===c.dtype?3:1});const l=s-i-o-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let i,r=[];const s=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;let l,c;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const d=d1(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(d1(e)){const{kernelName:m,inputs:g,attrs:_}=e,b=n1(m,this.backendName);S(null!=b,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),l=()=>{const y=this.backend.numDataIds();c=b.kernelFunc({inputs:g,attrs:_,backend:this.backend});const v=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,y,v);const x=v.map(w=>null!=w.rank?w:this.makeTensorFromTensorInfo(w));if(s){const w=this.getTensorsForGradient(m,g,x);r=this.saveTensorsForBackwardMode(w)}return x}}else{const{forwardFunc:m}=e,g=_=>{s&&(r=_.map(b=>this.keep(this.clone(b))))};l=()=>{const _=this.backend.numDataIds();c=this.tidy(()=>m(this.backend,g));const b=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,_,b),b}}const{inputs:u,attrs:h}=e,p=d1(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(d,u,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),i=f.outputs):i=l()}),s&&this.addTapeNode(d,u,i,p,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(m=>null!=u[m]?u[m].shape:null),outputShapes:i.map(m=>m.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(c)?i:i[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,i,r){const s=jH(e);if(null!=s){const o=s.inputsToSave||[],a=s.outputsToSave||[];let l;s.saveAllInputs?(S(Array.isArray(i),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(i).map(d=>i[d])):l=o.map(d=>i[d]);const c=r.filter((d,u)=>a[u]);return l.concat(c)}return[]}makeTensor(e,i,r,s){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");s=s||this.backend;let o=e;"string"===(r=r||"float32")&&Xf(e[0])&&(o=e.map(c=>Nl(c)));const a=s.write(o,i,r),l=new qn(i,r,a,this.nextTensorId());if(this.trackTensor(l,s),"string"===r){const c=this.state.tensorInfo.get(a),d=function ive(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(o);this.state.numBytes+=d-c.bytes,c.bytes=d}return l}makeTensorFromDataId(e,i,r,s){return this.makeTensorFromTensorInfo({dataId:e,shape:i,dtype:r=r||"float32"},s)}makeTensorFromTensorInfo(e,i){const{dataId:r,shape:s,dtype:o}=e,a=new qn(s,o,r,this.nextTensorId());return this.trackTensor(a,i),a}makeVariable(e,i=!0,r,s){r=r||this.nextVariableId().toString(),null!=s&&s!==e.dtype&&(e=e.cast(s));const o=new yx(e,i,r,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,i){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let r=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(r=e.size*hv(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:i||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof yx||this.track(e)}incRef(e,i){this.trackTensor(e,i),this.backend.incRef(e.dataId)}removeDataId(e,i){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===i&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const i=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=i.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const r=e.size*hv(e.dtype);this.state.numBytes-=r}i.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,i.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var i=this;return ie(function*(){i.state.profiling=!0;const r=i.state.numBytes,s=i.state.numTensors;i.state.activeProfile.kernels=[],i.state.activeProfile.result=yield e(),i.state.profiling=!1,i.state.activeProfile.peakBytes=Math.max(...i.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),i.state.activeProfile.newBytes=i.state.numBytes-r,i.state.activeProfile.newTensors=i.state.numTensors-s;for(const o of i.state.activeProfile.kernels)o.kernelTimeMs=yield o.kernelTimeMs,o.extraInfo=yield o.extraInfo;return i.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,i,r,s,o,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:i,outputs:r,saved:o},c=jH(e);null!=c&&(s=c.gradFunc),null!=s&&(l.gradient=d=>(d=d.map((u,h)=>{if(null==u){const p=r[h],f=Xi(p.size,p.dtype);return this.makeTensor(f,p.shape,p.dtype)}return u}),s(d.length>1?d:d[0],o,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const i={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(i.name=e),this.state.scopeStack.push(i),this.state.activeScope=i}endScope(e){const i=QH(e),r=new Set(i.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!r.has(a.id)&&a.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],i.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(e,i,r,s=!1){if(S(i.length>0,()=>"gradients() received an empty list of xs."),null!=r&&"float32"!==r.dtype)throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(o instanceof qn,()=>"The result y returned by f() must be a tensor.");const a=function kve(n,t,e){const i={},r={};for(let l=0;l<t.length;l++)i[t[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],d=c.inputs;for(const u in d){const h=d[u];let p=!1;for(let f=0;f<t.length;f++)if(i[h.id]){c.outputs.forEach(m=>i[m.id]=!0),p=!0,r[c.id]=!0;break}if(p)break}}const s={};s[e.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],d=c.inputs;for(let u=0;u<c.outputs.length;u++)if(s[c.outputs[u].id]){for(const h in d)s[d[h].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(r[c.id]&&o[c.id]){const d={};for(const h in c.inputs){const p=c.inputs[h];i[p.id]&&(d[h]=p)}const u=Object.assign({},c);u.inputs=d,u.outputs=c.outputs,a.push(u)}}return a}(this.state.activeTape,i,o);if(!s&&0===a.length&&i.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[o.id]=r??function Pve(n){const t=rI(K(n),"float32");return O.makeTensor(t,n,"float32")}(o.shape),function Eve(n,t,e,i){for(let r=t.length-1;r>=0;r--){const s=t[r],o=[];if(s.outputs.forEach(l=>{const c=n[l.id];o.push(null!=c?c:null)}),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(o);for(const l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=e(()=>a[l]());if("float32"!==c.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const d=s.inputs[l];if(!Ut(c.shape,d.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${d.shape}'`);if(null==n[d.id])n[d.id]=c;else{const u=n[d.id];n[d.id]=i(u,c),u.dispose()}}}}(l,a,d=>this.tidy(d),Lve);const c=i.map(d=>l[d.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(d=>{for(const u of d.saved)u.dispose()}),this.state.activeTape=null),{value:o,grads:c}})}customGrad(e){return S(nI(e),()=>"The f passed in customGrad(f) must be a function."),(...i)=>{let r;S(i.every(l=>l instanceof qn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const s={};return i.forEach((l,c)=>{s[c]=l}),this.runKernelFunc({forwardFunc:(l,c)=>(r=e(...i,c),S(r.value instanceof qn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(nI(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(l,c)=>{const d=r.gradFunc(l,c),u=Array.isArray(d)?d:[d];S(u.length===i.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(u.every(p=>p instanceof qn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((p,f)=>{h[f]=()=>p}),h},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,i){return this.state.tensorInfo.get(e).backend.readToGPU(e,i)}time(e){var i=this;return ie(function*(){const r=Fr(),s=yield i.backend.time(e);return s.wallMs=Fr()-r,s})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new e4;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function t4(){const n=AH();if(null==n._tfengine){const t=new ove(n);n._tfengine=new Fve(t)}return function dve(n){TH=n}(n._tfengine.ENV),function Ave(n){yo=n}(()=>n._tfengine),n._tfengine}const O=t4();function Lve(n,t){return O.runKernel(Ju,{a:n,b:t})}let u1;function n4(n){if(void 0!==u1)return u1;if(n||function $ve(){return typeof navigator<"u"&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");return t?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)):n.userAgentData&&n.userAgentData.mobile}return!1}function r4(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const ps=q();function Zm(n,t){let e=n;if(bo(n))return"string"===t?[]:[n.length];if("object"==typeof n){if("texture"in n)return[n.height,n.width*(n.channels||"RGBA").length];if("buffer"in n&&!(n.buffer instanceof ArrayBuffer))return[n.buffer.size/(null==t?4:hv(t))]}if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||bo(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&q().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&s4(n,r,[]),r}function s4(n,t,e){if(e=e||[],!Array.isArray(n)&&!bo(n))return void S(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);S(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),S(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const i=t.slice(1);for(let r=0;r<n.length;++r)s4(n[r],i,e.concat(r))}function o4(n,t,e,i){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${i}' must be ${n} tensor, but got ${t} tensor`)}}function E(n,t,e,i="numeric"){if(n instanceof qn)return o4(i,n.dtype,t,e),n;let r=Zf(n);if("string"!==r&&["bool","int32","float32"].indexOf(i)>=0&&(r=i),o4(i,r,t,e),null==n||!bo(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const s=Zm(n,r);!bo(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==r?Zc(n,r):Qc(n,[],!0);return O.makeTensor(a,s,r)}function a4(n,t,e,i="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,o)=>E(s,`${t}[${o}]`,e,i))}ps.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ps.registerFlag("IS_BROWSER",()=>r4()),ps.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),ps.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ps.registerFlag("PROD",()=>!1),ps.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ps.getBool("DEBUG")),ps.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ps.registerFlag("IS_TEST",()=>!1),ps.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),ps.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),ps.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),ps.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const Vve="__op";function P(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const i=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=Vve;const r=(...s)=>{O.startScope(e);try{const o=i(...s);return sI(o)&&console.error("Cannot return a Promise inside of tidy."),O.endScope(o),o}catch(o){throw O.endScope(null),o}};return Object.defineProperty(r,"name",{value:e,configurable:!0}),r}const Jc=P({complex_:function Bve(n,t){const e=E(n,"real","complex"),i=E(t,"imag","complex");return zs(e.shape,i.shape,`real and imag shapes, ${e.shape} and ${i.shape}, must match in call to tf.complex().`),O.runKernel(fI,{real:e,imag:i})}});function Qm(n,t,e,i){if(null==i)i=Zf(n);else if("complex64"===i)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if("object"==typeof n&&("texture"in n||"buffer"in n&&!(n.buffer instanceof ArrayBuffer))){if("float32"!==i&&"int32"!==i)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${i}.`);return O.backend.createTensorFromGPUData(n,t||e,i)}if(!bo(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Ba(t);const r=K(t),s=K(e);S(r===s,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${s}`);for(let o=0;o<e.length;++o){const l=o!==e.length-1||e[o]!==K(t.slice(o));S(e[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!bo(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==i?Zc(n,i):Qc(n,[],!0),O.makeTensor(n,t,i)}function Jm(n,t,e){return Qm(n,t,Zm(n,e),e)}const h1={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Dx=4;function l4(n,t){return p1.apply(this,arguments)}function p1(){return p1=ie(function*(n,t){const e=[],i=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(n)?n[o].tensor:n[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const d=new Promise(function(){var u=ie(function*(h){const p=yield l.bytes(),f=p.reduce((_,b)=>_+b.length,0)+Dx*p.length,m=new Uint8Array(f);let g=0;for(let _=0;_<p.length;_++){const b=p[_],y=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(y,g),g+=Dx,m.set(b,g),g+=b.length}h(m)});return function(h){return u.apply(this,arguments)}}());i.push(d)}else i.push(l.data());null!=t&&(c.group=t),e.push(c)}return{data:zve(yield Promise.all(i)),specs:e}}),p1.apply(this,arguments)}function zve(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});const i=new Uint8Array(t);let r=0;return e.forEach(s=>{i.set(new Uint8Array(s.buffer),r),r+=s.byteLength}),i.buffer}const f1=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function d4(n){return f1?Buffer.byteLength(n):new Blob([n]).size}function m1(n){if(1===n.length)return n[0];let t=0;n.forEach(r=>{t+=r.byteLength});const e=new Uint8Array(t);let i=0;return n.forEach(r=>{e.set(new Uint8Array(r),i),i+=r.byteLength}),e.buffer}function h4(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function g1(){return g1=ie(function*(n,t){let e,i;return null!=n.weightsManifest&&([e,i]=yield t(n.weightsManifest)),function jve(n,t,e){const i={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(i.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");i.weightSpecs=t,i.weightData=e}return null!=n.signature&&(i.signature=n.signature),null!=n.userDefinedMetadata&&(i.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(i.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(i.initializerSignature=n.initializerSignature),i}(n,e,i)}),g1.apply(this,arguments)}function Sx(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:d4(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:d4(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}function Kve(){const n=function Gve(){const n=e=>{let i=e<<13,r=0;for(;!(8388608&i);)r-=8388608,i<<=1;return i&=-8388609,r+=947912704,i|r},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function qve(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function Yve(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return i=>{const r=new ArrayBuffer(4*i.length),s=new Uint32Array(r);for(let o=0;o<i.length;o++){const a=i[o];s[o]=n[e[a>>10]+(1023&a)]+t[a>>10]}return new Float32Array(r)}}class Nn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Nn.instance&&(Nn.instance=new Nn),Nn.instance}static registerSaveRouter(t){Nn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Nn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Nn.getHandlers(t,"save")}static getLoadHandlers(t,e){return Nn.getHandlers(t,"load",e)}static getHandlers(t,e,i){const r=[];return("load"===e?Nn.getInstance().loadRouters:Nn.getInstance().saveRouters).forEach(o=>{const a=o(t,i);null!==a&&r.push(a)}),r}}const Zve=(n,t)=>Nn.getLoadHandlers(n,t),kx="tensorflowjs",ed="models_store",Ol="model_info_store";function y1(){if(!q().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function v1(n){const t=n.result;t.createObjectStore(ed,{keyPath:"modelPath"}),t.createObjectStore(Ol,{keyPath:"modelPath"})}let ih=(()=>{class n{constructor(e){if(this.indexedDB=y1(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var i=this;return ie(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return i.databaseAction(i.modelPath,e)})()}load(){var e=this;return ie(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,i){return new Promise((r,s)=>{const o=this.indexedDB.open(kx,1);o.onupgradeneeded=()=>v1(o),o.onsuccess=()=>{const a=o.result;if(null==i){const l=a.transaction(ed,"readonly"),d=l.objectStore(ed).get(this.modelPath);d.onsuccess=()=>{if(null==d.result)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(d.result.modelArtifacts)},d.onerror=u=>(a.close(),s(d.error)),l.oncomplete=()=>a.close()}else{const l=Sx(i),c=a.transaction(Ol,"readwrite");let d=c.objectStore(Ol);const u=d.put({modelPath:this.modelPath,modelArtifactsInfo:l});let h;u.onsuccess=()=>{h=a.transaction(ed,"readwrite");const f=h.objectStore(ed).put({modelPath:this.modelPath,modelArtifacts:i,modelArtifactsInfo:l});f.onsuccess=()=>r({modelArtifactsInfo:l}),f.onerror=m=>{d=c.objectStore(Ol);const g=d.delete(this.modelPath);g.onsuccess=()=>(a.close(),s(f.error)),g.onerror=_=>(a.close(),s(f.error))}},u.onerror=p=>(a.close(),s(u.error)),c.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},o.onerror=a=>s(o.error)})}}return n.URL_SCHEME="indexeddb://",n})();const f4=n=>q().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ih.URL_SCHEME)?function Qve(n){return new ih(n)}(n.slice(ih.URL_SCHEME.length)):null;Nn.registerSaveRouter(f4),Nn.registerLoadRouter(f4);class exe{constructor(){this.indexedDB=y1()}listModels(){var t=this;return ie(function*(){return new Promise((e,i)=>{const r=t.indexedDB.open(kx,1);r.onupgradeneeded=()=>v1(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(Ol,"readonly"),l=o.objectStore(Ol).getAll();l.onsuccess=()=>{const c={};for(const d of l.result)c[d.modelPath]=d.modelArtifactsInfo;e(c)},l.onerror=c=>(s.close(),i(l.error)),o.oncomplete=()=>s.close()},r.onerror=s=>i(r.error)})})()}removeModel(t){var e=this;return ie(function*(){return t=function Jve(n){return n.startsWith(ih.URL_SCHEME)?n.slice(ih.URL_SCHEME.length):n}(t),new Promise((i,r)=>{const s=e.indexedDB.open(kx,1);s.onupgradeneeded=()=>v1(s),s.onsuccess=()=>{const o=s.result,a=o.transaction(Ol,"readwrite"),l=a.objectStore(Ol),c=l.get(t);let d;c.onsuccess=()=>{if(null==c.result)return o.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const u=l.delete(t),h=()=>{d=o.transaction(ed,"readwrite");const f=d.objectStore(ed).delete(t);f.onsuccess=()=>i(c.result.modelArtifactsInfo),f.onerror=m=>r(c.error)};u.onsuccess=h,u.onerror=p=>(h(),o.close(),r(c.error))}},c.onerror=u=>(o.close(),r(c.error)),a.oncomplete=()=>{null==d?o.close():d.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})})()}}const Zo="/",td="tensorflowjs_models",m4="info",txe="model_topology",nxe="weight_specs",ixe="weight_data",rxe="model_metadata";function g4(n){return{info:[td,n,m4].join(Zo),topology:[td,n,txe].join(Zo),weightSpecs:[td,n,nxe].join(Zo),weightData:[td,n,ixe].join(Zo),modelMetadata:[td,n,rxe].join(Zo)}}function _4(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function b4(n){const t=n.split(Zo);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Zo)}let rh=(()=>{class n{constructor(e){if(!q().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=g4(this.modelPath)}save(e){var i=this;return ie(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const r=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),o=Sx(e);try{return i.LS.setItem(i.keys.info,JSON.stringify(o)),i.LS.setItem(i.keys.topology,r),i.LS.setItem(i.keys.weightSpecs,s),i.LS.setItem(i.keys.weightData,function Uve(n){if(f1)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let i=0,r=t.length;i<r;i++)e+=String.fromCharCode(t[i]);return btoa(e)}(e.weightData)),i.LS.setItem(i.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:o}}catch{throw _4(i.keys),new Error(`Failed to save model '${i.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})()}load(){var e=this;return ie(function*(){const i=JSON.parse(e.LS.getItem(e.keys.info));if(null==i)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==i.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const r={},s=JSON.parse(e.LS.getItem(e.keys.topology));if(null==s)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);r.modelTopology=s;const o=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);r.weightSpecs=o;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const c=JSON.parse(a);r.format=c.format,r.generatedBy=c.generatedBy,r.convertedBy=c.convertedBy,null!=c.signature&&(r.signature=c.signature),null!=c.userDefinedMetadata&&(r.userDefinedMetadata=c.userDefinedMetadata),null!=c.modelInitializer&&(r.modelInitializer=c.modelInitializer),null!=c.initializerSignature&&(r.initializerSignature=c.initializerSignature),null!=c.trainingConfig&&(r.trainingConfig=c.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return r.weightData=function Hve(n){if(f1){const i=Buffer.from(n,"base64");return i.buffer.slice(i.byteOffset,i.byteOffset+i.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let i=0;i<t.length;++i)e.set([t.charCodeAt(i)],i);return e.buffer}(l),r})()}}return n.URL_SCHEME="localstorage://",n})();const y4=n=>q().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(rh.URL_SCHEME)?function oxe(n){return new rh(n)}(n.slice(rh.URL_SCHEME.length)):null;Nn.registerSaveRouter(y4),Nn.registerLoadRouter(y4);class axe{constructor(){S(q().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return ie(function*(){const e={},i=td+Zo,r=Zo+m4;for(let s=0;s<t.LS.length;++s){const o=t.LS.key(s);o.startsWith(i)&&o.endsWith(r)&&(e[b4(o)]=JSON.parse(t.LS.getItem(o)))}return e})()}removeModel(t){var e=this;return ie(function*(){t=function sxe(n){return n.startsWith(rh.URL_SCHEME)?n.slice(rh.URL_SCHEME.length):n}(t);const i=g4(t);if(null==e.LS.getItem(i.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(e.LS.getItem(i.info));return _4(i),r})()}}class pr{constructor(){this.managers={}}static getInstance(){return null==pr.instance&&(pr.instance=new pr),pr.instance}static registerManager(t,e){S(null!=t,()=>"scheme must not be undefined or null."),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),S(t.length>0,()=>"scheme must not be an empty string.");const i=pr.getInstance();S(null==i.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),i.managers[t]=e}static getManager(t){const e=pr.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(pr.getInstance().managers)}}class lxe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){typeof window>"u"||!q().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(t,e):(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",i=>{i.source===window&&i.data.name===this.messageName&&(i.stopPropagation(),(0,this.functionRefs[i.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}}if(q().get("IS_BROWSER")){q().setPlatform("browser",new lxe);try{pr.registerManager(rh.URL_SCHEME,new axe)}catch{}try{pr.registerManager(ih.URL_SCHEME,new exe)}catch{}}let oh;function vt(n,t="float32",e){return t=t||"float32",Ba(n),new Zi(n,t,e)}q().get("IS_NODE")&&!q().get("IS_BROWSER")&&q().setPlatform("node",new class dxe{constructor(){this.util=fe(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=q().global.fetch?q().global.fetch(t,e):(null==oh&&(oh=fe(410)),oh(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}});const be=P({cast_:function uxe(n,t){const e=E(n,"x","cast");if(!function nve(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return O.runKernel(sm,{x:e},{dtype:t})}}),nd=P({clone_:function hxe(n){const e={x:E(n,"x","clone","string_or_numeric")};return O.runKernel(bm,e)}});function Qo(){return O}function k1(){return O.memory()}function G(n,t){return O.tidy(n,t)}function mt(n){QH(n).forEach(e=>e.dispose())}function Jo(n){return O.keep(n)}function x4(n,t,e=1){return O.registerBackend(n,t,e)}t4(),function Mve(n){nh=n}({buffer:vt,cast:be,clone:nd,print:function pxe(n,t=!1){console.log(n.toString(t))}}),function Nve(n){ZH=n}(function fxe(n){q().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const ue=P({add_:function gxe(n,t){let e=E(n,"a","add"),i=E(t,"b","add");return[e,i]=Vn(e,i),O.runKernel(Ju,{a:e,b:i})}}),w4=P({floorDiv_:function _xe(n,t){let e=E(n,"a","floorDiv"),i=E(t,"b","floorDiv");return[e,i]=Vn(e,i),O.runKernel(gm,{a:e,b:i})}}),$e=P({div_:function bxe(n,t){let e=E(n,"a","div"),i=E(t,"b","div");return[e,i]=Vn(e,i),"int32"===e.dtype&&"int32"===i.dtype?w4(e,i):O.runKernel(dm,{a:e,b:i},{})}}),N=P({mul_:function yxe(n,t){let e=E(n,"a","mul"),i=E(t,"b","mul");return[e,i]=Vn(e,i),O.runKernel(Em,{a:e,b:i})}}),fr=P({sqrt_:function vxe(n){const e={x:E(n,"x","sqrt","float32")};return O.runKernel(Bm,e)}}),dn=P({square_:function xxe(n){const t=E(n,"x","square");return O.runKernel("Square",{x:t},{})}}),Nt=P({zerosLike_:function wxe(n){const e={x:E(n,"x","zerosLike")};return O.runKernel(hx,e)}});function za(n){return O.customGrad(n)}function Ke(n,t){if((bo(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&bo(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Qm(n,[],[],t)}class ah{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Us{constructor(){this.classNameMap={}}static getMap(){return null==Us.instance&&(Us.instance=new Us),Us.instance}static register(t){Us.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ce(n){S(null!=n.className,()=>"Class being registered does not have the static className property defined."),S("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),S(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Us.register(n)}class Fl extends ah{minimize(t,e=!1,i){const{value:r,grads:s}=this.computeGradients(t,i);if(null!=i){const o=i.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(o)}else this.applyGradients(s);return mt(s),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function Cxe(n,t){S(nI(n),()=>"The f passed in variableGrads(f) must be a function"),S(null==t||Array.isArray(t)&&t.every(c=>c instanceof yx),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const c in O.registeredVariables)t.push(O.registeredVariables[c])}const i=e?t.filter(c=>!c.trainable):null,r=t.length;S((t=t.filter(c=>c.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const{value:o,grads:a}=O.gradients(n,t,null,!0);S(a.some(c=>null!=c),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(0===o.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((c,d)=>{null!=a[d]&&(l[c.name]=a[d])}),i?.forEach(c=>l[c.name]=null),{value:o,grads:l}}(t,e)}dispose(){null!=this.iterations_&&mt(this.iterations_)}saveIterations(){var t=this;return ie(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Ke(t.iterations_,"int32")}})()}getWeights(){return ie(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return ie(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return ie(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(Fl,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});class C4 extends Fl{constructor(t,e,i=null){super(),this.learningRate=t,this.rho=e,this.epsilon=i,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==i&&(this.epsilon=O.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,r)=>{const s=O.registeredVariables[i];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${i}/accum_grad`,variable:G(()=>Nt(s).variable(!1))}),null==this.accumulatedUpdates[r]&&(this.accumulatedUpdates[r]={originalName:`${i}/accum_var`,variable:G(()=>Nt(s).variable(!1))});const a=Array.isArray(t)?t[r].tensor:t[i];if(null==a)return;const l=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;G(()=>{const d=ue(N(l,this.rho),N(dn(a),1-this.rho)),u=N($e(fr(ue(c,this.epsilon)),fr(ue(l,this.epsilon))),a),h=ue(N(c,this.rho),N(dn(u),1-this.rho));l.assign(d),c.assign(h);const p=ue(N(u,-this.learningRate),s);s.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(mt(this.accumulatedGrads.map(t=>t.variable)),mt(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return ie(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(i=>({name:i.originalName,tensor:i.variable})))})()}setWeights(t){var e=this;return ie(function*(){const i=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,i).map(s=>({originalName:s.name,variable:s.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(i,2*i).map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function eg(n,t,e){return Ba(n),O.runKernel(II,{},{shape:n,value:t,dtype:e})}class D4 extends Fl{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,r)=>{const s=O.registeredVariables[i];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${i}/accumulator`,variable:G(()=>eg(s.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[i];if(null==o)return;const a=this.accumulatedGrads[r].variable;G(()=>{const l=ue(a,dn(o));a.assign(l);const c=ue(N($e(o,fr(ue(l,O.backend.epsilon()))),-this.learningRate),s);s.assign(c)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&mt(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return ie(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return ie(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const lh=P({pow_:function Dxe(n,t){let e=E(n,"base","pow"),i=E(t,"exp","pow");return[e,i]=Vn(e,i),O.runKernel(Im,{a:e,b:i})}}),Me=P({sub_:function Sxe(n,t){let e=E(n,"a","sub"),i=E(t,"b","sub");return[e,i]=Vn(e,i),O.runKernel(Um,{a:e,b:i})}});class S4 extends Fl{constructor(t,e,i,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=i,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],G(()=>{this.accBeta1=Ke(e).variable(),this.accBeta2=Ke(i).variable()}),null==r&&(this.epsilon=O.backend.epsilon())}static get className(){return"Adam"}applyGradients(t){const e=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);G(()=>{const i=Me(1,this.accBeta1),r=Me(1,this.accBeta2);e.forEach((s,o)=>{const a=O.registeredVariables[s];null==this.accumulatedFirstMoment[o]&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:G(()=>Nt(a).variable(!1))}),null==this.accumulatedSecondMoment[o]&&(this.accumulatedSecondMoment[o]={originalName:`${s}/v`,variable:G(()=>Nt(a).variable(!1))});const c=Array.isArray(t)?t[o].tensor:t[s];if(null==c)return;const d=this.accumulatedFirstMoment[o].variable,u=this.accumulatedSecondMoment[o].variable,h=ue(N(d,this.beta1),N(c,1-this.beta1)),p=ue(N(u,this.beta2),N(dn(c),1-this.beta2)),f=$e(h,i),m=$e(p,r);d.assign(h),u.assign(p);const g=ue(N($e(f,ue(fr(m),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(N(this.accBeta1,this.beta1)),this.accBeta2.assign(N(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&mt(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&mt(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return ie(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(i=>({name:i.originalName,tensor:i.variable})))})()}setWeights(t){var e=this;return ie(function*(){t=yield e.extractIterations(t),G(()=>{e.accBeta1.assign(lh(e.beta1,e.iterations_+1)),e.accBeta2.assign(lh(e.beta2,e.iterations_+1))});const i=t.length/2;e.accumulatedFirstMoment=t.slice(0,i).map(s=>({originalName:s.name,variable:s.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(i,2*i).map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const Ii=P({abs_:function kxe(n){const t=E(n,"x","abs");return O.runKernel("complex64"===t.dtype?vv:pv,{x:t})}});function ch(n,t){const e=n.length,i=[];for(let r=0;r<e;r++){const s=e-1-r;(t[t.length-1-r]||1)>1&&1===(n[s]||1)&&i.unshift(s)}return i}function hi(n,t){const e=[];for(let i=0;i<t.length;i++){const r=n[n.length-i-1],s=t.length-i-1;(null==r||1===r&&t[s]>1)&&e.unshift(s)}return e}function Je(n,t){const e=[],i=Math.max(n.length,t.length);for(let r=0;r<i;r++){let s=n[n.length-r-1];null==s&&(s=1);let o=t[t.length-r-1];if(null==o&&(o=1),1===s)e.unshift(o);else if(1===o)e.unshift(s);else{if(s!==o)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);e.unshift(s)}}return e}const Pl=P({maximum_:function Exe(n,t){let e=E(n,"a","maximum"),i=E(t,"b","maximum");return[e,i]=Vn(e,i),"bool"===e.dtype&&(e=be(e,"int32"),i=be(i,"int32")),Je(e.shape,i.shape),O.runKernel(Dm,{a:e,b:i})}});class k4 extends Fl{constructor(t,e,i,r=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=i,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],G(()=>{this.iteration=Ke(0).variable(),this.accBeta1=Ke(e).variable()}),null==r&&(this.epsilon=O.backend.epsilon())}static get className(){return"Adamax"}applyGradients(t){const e=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);G(()=>{const i=Me(1,this.accBeta1),r=$e(-this.learningRate,ue(N(this.iteration,this.decay),1));e.forEach((s,o)=>{const a=O.registeredVariables[s];null==this.accumulatedFirstMoment[o]&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:Nt(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[o]&&(this.accumulatedWeightedInfNorm[o]={originalName:`${s}/v`,variable:Nt(a).variable(!1)});const c=Array.isArray(t)?t[o].tensor:t[s];if(null==c)return;const d=this.accumulatedFirstMoment[o].variable,u=this.accumulatedWeightedInfNorm[o].variable,h=ue(N(d,this.beta1),N(c,1-this.beta1)),p=N(u,this.beta2),f=Ii(c),m=Pl(p,f);d.assign(h),u.assign(m);const g=ue(N($e(r,i),$e(h,ue(m,this.epsilon))),a);a.assign(g)}),this.iteration.assign(ue(this.iteration,1)),this.accBeta1.assign(N(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&mt(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&mt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return ie(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return ie(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class E1 extends Fl{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}static get className(){return"SGD"}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,r)=>{const s=Array.isArray(t)?t[r].tensor:t[i];if(null==s)return;const o=O.registeredVariables[i];G(()=>{const a=ue(N(this.c,s),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=Jo(Ke(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return ie(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return ie(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class E4 extends E1{constructor(t,e,i=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=i,this.accumulations=[],this.m=Ke(this.momentum)}static get className(){return"Momentum"}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,r)=>{const s=O.registeredVariables[i];null==this.accumulations[r]&&(this.accumulations[r]={originalName:`${i}/momentum`,variable:G(()=>Nt(s).variable(!1))});const o=this.accumulations[r].variable,a=Array.isArray(t)?t[r].tensor:t[i];null!=a&&G(()=>{let l;const c=ue(N(this.m,o),a);l=ue(N(this.c,this.useNesterov?ue(a,N(c,this.m)):c),s),o.assign(c),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&mt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return ie(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return ie(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class I4 extends Fl{constructor(t,e=.9,i=0,r=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=i,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=O.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,r)=>{const s=O.registeredVariables[i],o=!1;null==this.accumulatedMeanSquares[r]&&(this.accumulatedMeanSquares[r]={originalName:`${i}/rms`,variable:G(()=>Nt(s).variable(o))}),null==this.accumulatedMoments[r]&&(this.accumulatedMoments[r]={originalName:`${i}/momentum`,variable:G(()=>Nt(s).variable(o))}),null==this.accumulatedMeanGrads[r]&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${i}/mg`,variable:G(()=>Nt(s).variable(o))});const a=Array.isArray(t)?t[r].tensor:t[i];if(null==a)return;const l=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;G(()=>{const d=ue(N(l,this.decay),N(dn(a),1-this.decay));if(this.centered){const u=this.accumulatedMeanGrads[r].variable,h=ue(N(u,this.decay),N(a,1-this.decay)),p=$e(N(a,this.learningRate),fr(Me(d,ue(dn(h),this.epsilon)))),f=ue(N(c,this.momentum),p);l.assign(d),u.assign(h),c.assign(f);const m=Me(s,f);s.assign(m)}else{const u=ue(N(l,this.decay),N(dn(a),1-this.decay)),h=ue(N(c,this.momentum),$e(N(a,this.learningRate),fr(ue(u,this.epsilon))));l.assign(u),c.assign(h);const p=Me(s,h);s.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&mt(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&mt(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&mt(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return ie(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(i=>({name:i.originalName,tensor:i.variable})))})()}setWeights(t){var e=this;return ie(function*(){t=yield e.extractIterations(t);const i=e.centered?t.length/3:t.length/2,r=!1;e.accumulatedMeanSquares=t.slice(0,i).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),e.accumulatedMoments=t.slice(i,2*i).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*i,3*i).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const Ixe=[C4,D4,S4,k4,E4,I4,E1];function T4(n){return new Promise(t=>setTimeout(t)).then(n)}let I1=(()=>{class n{constructor(e){if(!q().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var i=this;return ie(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const r=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const o=h4(e,[{paths:["./"+i.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),l=null==i.modelJsonAnchor?document.createElement("a"):i.modelJsonAnchor;if(l.download=i.modelJsonFileName,l.href=a,yield T4(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const c=null==i.weightDataAnchor?document.createElement("a"):i.weightDataAnchor;c.download=i.weightDataFileName,c.href=r,yield T4(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Sx(e)}}})()}}return n.URL_SCHEME="downloads://",n})();function A4(n,t,e,i){(function o(l){S(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function a(l,c){S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),S(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),S(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}(e=e??0,i=i??1);let r=0;return Promise.all(n.map(l=>(l.then(c=>{const d=e+ ++r/n.length*(i-e);return t(d),c}),l)))}function M4(n,t){return T1.apply(this,arguments)}function T1(){return T1=ie(function*(n,t){null==t&&(t={});const e=null==t.fetchFunc?q().platform.fetch:t.fetchFunc,i=n.map(u=>e(u,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(i):yield A4(i,t.onProgress,0,.5)).map(u=>u.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield A4(a,t.onProgress,.5,1)}),T1.apply(this,arguments)}Nn.registerSaveRouter(n=>q().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(I1.URL_SCHEME)?function Fxe(n="model"){return new I1(n)}(n.slice(I1.URL_SCHEME.length)):null);let N4=(()=>{class n{constructor(e,i){if(this.DEFAULT_METHOD="POST",null==i&&(i={}),this.weightPathPrefix=i.weightPathPrefix,this.onProgress=i.onProgress,this.weightUrlConverter=i.weightUrlConverter,null!=i.fetchFunc?(S("function"==typeof i.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=i.fetchFunc):this.fetch=q().platform.fetch,S(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=i.requestInit&&null!=i.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=i.requestInit||{}}save(e){var i=this;return ie(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const r=Object.assign({method:i.DEFAULT_METHOD},i.requestInit);r.body=new FormData;const o=h4(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);r.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=e.weightData&&r.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield i.fetch(i.path,r);if(a.ok)return{modelArtifactsInfo:Sx(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return ie(function*(){const i=yield e.fetch(e.path,e.requestInit);if(!i.ok)throw new Error(`Request to ${e.path} failed with status code ${i.status}. Please verify this URL points to the model JSON of the model to load.`);let r;try{r=yield i.json()}catch{let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==r.modelTopology&&null==r.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return function p4(n,t){return g1.apply(this,arguments)}(r,a=>e.loadWeights(a))})()}loadWeights(e){var i=this;return ie(function*(){const r=Array.isArray(i.path)?i.path[1]:i.path,[s,o]=function Vxe(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(r),a=i.weightPathPrefix||s,l=function Wve(n){const t=[];for(const e of n)t.push(...e.weights);return t}(e),c=[],d=[];for(const h of e)for(const p of h.paths)null!=i.weightUrlConverter?d.push(i.weightUrlConverter(p)):c.push(a+p+o);return i.weightUrlConverter&&c.push(...yield Promise.all(d)),[l,m1(yield M4(c,{requestInit:i.requestInit,fetchFunc:i.fetch,onProgress:i.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function R4(n){return null!=n.match(N4.URL_SCHEME_REGEX)}const O4=(n,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(i=>R4(i)):R4(n),e)return F4(n,t)}return null};function F4(n,t){return new N4(n,t)}let id;Nn.registerSaveRouter(O4),Nn.registerLoadRouter(O4);const Yxe=P({fromPixels_:function L4(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,i=!1,r=!1,s=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)i=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)s=!0;else if(null!=n.getContext)o=!0;else{if(!(typeof ImageBitmap<"u"&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);a=!0}if(null!=n1(e1,O.backendName))return O.runKernel(e1,{pixels:n},{numChannels:t});const[c,d]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let u,h;if(o)u=n.getContext("2d").getImageData(0,0,c,d).data;else if(i||e)u=n.data;else if(s||r||a){if(null==id)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");id=new OffscreenCanvas(1,1).getContext("2d")}else id=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});id.canvas.width=c,id.canvas.height=d,id.drawImage(n,0,0,c,d),u=id.getImageData(0,0,c,d).data}if(4===t)h=new Int32Array(u);else{const f=c*d;h=new Int32Array(f*t);for(let m=0;m<f;m++)for(let g=0;g<t;++g)h[m*t+g]=u[4*m+g]}return function Hxe(n,t,e){if(JE(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const i=Zm(n,e);if(3!==i.length&&1!==i.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Qm(n,t,i,e)}(h,[d,c,t],"int32")}}),O1=-2,Kxe=-1;function F1(n,t,e){const i=n.shape.length;S(i===t.length,()=>`Error in slice${i}D: Length of begin ${t} must match the rank of the array (${i}).`),S(i===e.length,()=>`Error in slice${i}D: Length of size ${e} must match the rank of the array (${i}).`);for(let r=0;r<i;++r)S(t[r]+e[r]<=n.shape[r],()=>`Error in slice${i}D: begin[${r}] + size[${r}] (${t[r]+e[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function Xxe(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function P1(n,t,e){const i=[];for(let r=0;r<n.length;r++)i[r]=Math.ceil((t[r]-n[r])/e[r]);return i}function $4(n,t,e,i){const r=[...n];for(let s=r.length;s<i.length;s++)r.push(1);for(let s=0;s<e;s++)0===s?r[t]=1:(r.splice(t,0,1),r.pop());return r}function V4(n,t,e){return e<=n?e:e-(t-1)}function B4(n,t){const e=[];for(let i=0;i<n;i++)e.push(t+i);return e}function Zxe(n,t,e,i,r,s,o,a,l){const c=n.length;let d=new Array(c),u=new Array(c),h=new Array(c);if(t.length&&e>0){const p=t[0],f=e+1;d=z4(o,p,f,i,n),u=U4(a,p,f,r,n),h=$4(s,p,f,n)}else for(let p=0;p<c;p++)d[p]=j4(o,i,s,n,p,l),u[p]=W4(a,r,s,n,p,l),h[p]=H4(s,p,l);return{begin:d,end:u,strides:h}}function z4(n,t,e,i,r){const s=[...r],o=B4(e,t);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=0;else{const l=V4(t,e,a);let c=i[l];n&1<<l&&(c=0),s[a]=c}return s}function U4(n,t,e,i,r){const s=[...r],o=B4(e,t);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{const l=V4(t,e,a);let c=i[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),s[a]=c}for(let a=0;a<s.length;a++)s[a]<0&&(s[a]+=r[a]),s[a]=Yc(0,s[a],r[a]);return s}function H4(n,t,e){let i=n[t];return(e&1<<t||null==i)&&(i=1),i}function j4(n,t,e,i,r,s){let o=t[r];(n&1<<r||s&1<<r||null==o)&&(o=(e[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=i[r];return o<0&&(o+=l),o=Yc(0,o,l-1),o}function W4(n,t,e,i,r,s){let o=t[r];const a=e[r]||1;(n&1<<r||s&1<<r||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=i[r];return o<0&&(o+=l),o=a>0?Yc(0,o,l):Yc(-1,o,l-1),o}function L1(n,t,e){let i=e.length;for(let r=0;r<e.length;r++)if(e[r]>1){i=r;break}for(let r=i+1;r<e.length;r++)if(t[r]>0||e[r]!==n[r])return!1;return!0}function $1(n,t){let e=n.length>0?n[n.length-1]:1;for(let i=0;i<n.length-1;i++)e+=n[i]*t[i];return e}function Tx(n,t,e){let i;const r=n.shape.length;let s;return i="number"==typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),i.forEach(o=>{S(-1!==o,()=>"slice() does not support negative begin indexing.")}),s=null==e?new Array(r).fill(-1):"number"==typeof e?[e,...new Array(r-1).fill(-1)]:e.length<r?e.concat(new Array(r-e.length).fill(-1)):e,s=s.map((o,a)=>o>=0?o:(S(-1===o,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-i[a])),[i,s]}function V1(n,t,e,i,r,s,o,a,l){let c;if(null==i?(c=new Array(t.length),c.fill(1)):c=i,null!=o&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const u={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:c.slice(),beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let y=0;y<u.dims;y++)d&&1<<y&a&&u.numAddAxisAfterEllipsis++,1<<y&o&&(d=!0);d||(u.ellipsisMask|=1<<u.dims,u.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function Qxe(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let i=0;i<n.dims;i++)if(1<<i&n.ellipsisMask){const r=Math.min(t.dims-(n.dims-i)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<r;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=i}else if(1<<i&n.newAxisMask)t.finalShapeGatherIndices.push(O1),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[i]),null!=n.end&&(t.end[e]=n.end[i]),t.strides[e]=n.strides[i],n.beginMask&1<<i&&(t.beginMask|=1<<e),n.endMask&1<<i&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<i?(t.finalShapeGatherIndices.push(Kxe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(i)),t.inputShapeGatherIndicesSparse[e]=i,e++}}(u,h);let p=!0,f=!0,m=!0;const g=[],_=[];for(let y=0;y<n.length;++y){if(0===h.strides[y])throw Error(`strides[${y}] must be non-zero`);const v=!!(h.shrinkAxisMask&1<<y),x=n[y];if(-1===x){g.push(v?1:-1);continue}const w=[h.beginMask&1<<y,h.endMask&1<<y],C=[h.strides[y]>0?0:-1,h.strides[y]>0?x:x-1];if(v&&h.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[y];const D=!!(h.beginMask&1<<y&&h.endMask&1<<y);if(h.beginValid&&h.endValid){if(v){const $=h.begin[y]<0?x+h.begin[y]:h.begin[y];if(h.begin[y]=$,h.end[y]=h.begin[y]+1,$<0||$>=x)throw Error(`slice index ${h.begin[y]} of dimension ${y} out of bounds.`)}else h.begin[y]=G4(h.begin[y],0,h.strides[y],x,w,C),h.end[y]=G4(h.end[y],1,h.strides[y],x,w,C);const A=1===h.strides[y]&&0===h.begin[y]&&h.end[y]===x;p=p&&A,f=f&&(0===y&&1===h.strides[y]||A)}else p=p&&1===h.strides[y]&&D,f=f&&(0===y&&1===h.strides[y]||D);let k,I=!1;if(h.beginValid&&h.endValid?(k=h.end[y]-h.begin[y],I=!0):v?(k=1,I=!0):D&&x>=0&&(k=h.strides[y]<0?-x:x,I=!0),I){let A;A=0===k||k<0!=h.strides[y]<0?0:Math.trunc(k/h.strides[y])+(k%h.strides[y]!=0?1:0),g.push(A)}else g.push(-1)}for(let y=0;y<h.finalShapeGatherIndices.length;++y){const v=h.finalShapeGatherIndices[y];v>=0?_.push(g[v]):v===O1&&_.push(1)}return{finalShapeSparse:_.filter((y,v)=>h.finalShapeGatherIndices[v]!==O1),finalShape:_,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function G4(n,t,e,i,r,s){if(r[t])return e>0?s[t]:s[t+1&1];{const o=n<0?i+n:n;return o<s[0]?s[0]:o>s[1]?s[1]:o}}const q4=P({all_:function e0e(n,t=null,e=!1){const r={x:E(n,"x","all","bool")};return O.runKernel("All",r,{axis:t,keepDims:e})}}),B1=P({any_:function t0e(n,t=null,e=!1){const r={x:E(n,"x","any","bool")};return O.runKernel("Any",r,{axis:t,keepDims:e})}}),tg=P({argMax_:function n0e(n,t=0){const i={x:E(n,"x","argMax")};return O.runKernel(fv,i,{axis:t})}});function ng(n,t,e,i,r="NHWC",s){return Ti(n,[...t,n[3]],e,s,i,null,null,Ha(r))}function Hs(n,t,e,i,r,s,o="channelsLast"){const[a,l]=ig(t);let c;if("channelsLast"===o)c=[a,l,n[3],n[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);c=[a,l,n[1],n[1]]}return Ti(n,c,e,i,r,s,!1,o)}function Ua(n,t,e,i,r,s,o="NDHWC"){const[a,l,c]=U1(t);let d,u;if("NDHWC"===o)u="channelsLast",d=[a,l,c,n[4],n[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);u="channelsFirst",d=[a,l,c,n[1],n[1]]}return Ll(n,d,e,i,r,!1,u,s)}function Ti(n,t,e,i,r,s,o=!1,a="channelsLast"){let[l,c,d,u]=[-1,-1,-1,-1];if("channelsLast"===a)[l,c,d,u]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,u,c,d]=n}const[h,p,,f]=t,[m,g]=ig(e),[_,b]=ig(i),y=dh(h,_),v=dh(p,b),{padInfo:x,outHeight:w,outWidth:C}=function s0e(n,t,e,i,r,s,o,a,l){let c,d,u;if("number"==typeof n){c={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const p=function i0e(n,t,e,i,r){null==i&&(i=z1(n,t,e));const o=n[1];return[rg((n[0]-t+2*i)/e+1,r),rg((o-t+2*i)/e+1,r)]}([t,e],s,i,n,a);d=p[0],u=p[1]}else if("same"===n){d=Math.ceil(t/i),u=Math.ceil(e/r);const h=Math.max(0,(d-1)*i+s-t),p=Math.max(0,(u-1)*r+o-e),f=Math.floor(h/2),m=h-f,g=Math.floor(p/2);c={top:f,bottom:m,left:g,right:p-g,type:"SAME"}}else if("valid"===n)c={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-s+1)/i),u=Math.ceil((e-o+1)/r);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const h="channelsLast"===l?n[1][0]:n[2][0],p="channelsLast"===l?n[1][1]:n[2][1],f="channelsLast"===l?n[2][0]:n[3][0],m="channelsLast"===l?n[2][1]:n[3][1];c={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},d=rg((t-s+h+p)/i+1,a),u=rg((e-o+f+m)/r+1,a)}}return{padInfo:c,outHeight:d,outWidth:u}}(r,c,d,m,g,y,v,s,a),D=o?f*u:f;let k;return"channelsFirst"===a?k=[l,D,w,C]:"channelsLast"===a&&(k=[l,w,C,D]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:d,inChannels:u,outHeight:w,outWidth:C,outChannels:D,padInfo:x,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:y,effectiveFilterWidth:v,dilationHeight:_,dilationWidth:b,inShape:n,outShape:k,filterShape:t}}function Ll(n,t,e,i,r,s=!1,o="channelsLast",a){let[l,c,d,u,h]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,d,u,h]=n;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,c,d,u]=n}const[p,f,m,,g]=t,[_,b,y]=U1(e),[v,x,w]=U1(i),C=dh(p,v),D=dh(f,x),k=dh(m,w),{padInfo:I,outDepth:A,outHeight:$,outWidth:H}=function o0e(n,t,e,i,r,s,o,a,l,c,d){let u,h,p,f;if("valid"===n&&(n=0),"number"==typeof n){u={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const g=function r0e(n,t,e,i,r,s){null==r&&(r=z1(n,t[0],i[0]));const o=[0,0,0,e];for(let a=0;a<3;a++)n[a]+2*r>=t[a]&&(o[a]=rg((n[a]-t[a]+2*r)/i[a]+1,s));return o}([t,e,i,1],[a,l,c],1,[r,s,o],n,d);h=g[0],p=g[1],f=g[2]}else{if("same"!==n)throw Error(`Unknown padding parameter: ${n}`);{h=Math.ceil(t/r),p=Math.ceil(e/s),f=Math.ceil(i/o);const m=(h-1)*r+a-t,g=(p-1)*s+l-e,_=(f-1)*o+c-i,b=Math.floor(m/2),y=m-b,v=Math.floor(g/2),x=g-v,w=Math.floor(_/2);u={top:v,bottom:x,left:w,right:_-w,front:b,back:y,type:"SAME"}}}return{padInfo:u,outDepth:h,outHeight:p,outWidth:f}}(r,c,d,u,_,b,y,C,D,k,a),W=s?g*h:g;let z;return"channelsFirst"===o?z=[l,W,A,$,H]:"channelsLast"===o&&(z=[l,A,$,H,W]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:d,inWidth:u,inChannels:h,outDepth:A,outHeight:$,outWidth:H,outChannels:W,padInfo:I,strideDepth:_,strideHeight:b,strideWidth:y,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:C,effectiveFilterHeight:D,effectiveFilterWidth:k,dilationDepth:v,dilationHeight:x,dilationWidth:w,inShape:n,outShape:z,filterShape:t}}function z1(n,t,e,i=1){const r=dh(t,i);return Math.floor((n[0]*(e-1)-e+r)/2)}function ig(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function U1(n){return"number"==typeof n?[n,n,n]:n}function dh(n,t){return t<=1?n:n+(n-1)*(t-1)}function rg(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function $l(n){const[t,e,i]=ig(n);return 1===t&&1===e&&1===i}function Ui(n,t){return $l(n)||$l(t)}function rd(n){return ig(n).every(t=>t>0)}function Ha(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function mr(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)S(Xu(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(i=>{i.forEach(r=>{S(Xu(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${r}.`)})})}}}const B=P({reshape_:function a0e(n,t){const i={x:E(n,"x","reshape","string_or_numeric")};return O.runKernel(ex,i,{shape:t})}}),H1=P({avgPool_:function l0e(n,t,e,i,r){const s=E(n,"x","avgPool","float32");S(Ui(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=s,l=!1;3===s.rank&&(l=!0,a=B(s,[1,s.shape[0],s.shape[1],s.shape[2]])),S(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),mr("avgPool",i,r);let u=O.runKernel(gv,{x:a},{filterSize:t,strides:e,pad:i,dimRoundingMode:r});return u=be(u,s.dtype),l?B(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),d0e=P({avgPool3d_:function c0e(n,t,e,i,r,s="NDHWC"){const o=E(n,"x","avgPool3d","float32");let a=o,l=!1;4===o.rank&&(l=!0,a=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===s,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),S("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),mr("avgPool3d",i,r);let u=O.runKernel(_v,{x:a},{filterSize:t,strides:e,pad:i,dimRoundingMode:r,dataFormat:s});return u=be(u,a.dtype),l?B(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}});function u0e(n){let t;return t=0===n.rank||1===n.rank?B(n,[1,1,1,n.size]):2===n.rank?B(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?B(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const Ax=P({batchNorm_:function h0e(n,t,e,i,r,s){null==s&&(s=.001);const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,d;null!=r&&(c=E(r,"scale","batchNorm")),null!=i&&(d=E(i,"offset","batchNorm")),S(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==d||a.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:u0e(o),scale:c,offset:d,mean:a,variance:l},f=O.runKernel(Av,h,{varianceEpsilon:s});return B(f,o.shape)}}),f0e=P({batchNorm2d_:function p0e(n,t,e,i,r,s){const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,d;return null!=r&&(c=E(r,"scale","batchNorm")),null!=i&&(d=E(i,"offset","batchNorm")),S(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),S(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),S(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&S(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),null!=d&&S(2===d.rank||1===d.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),Ax(o,a,l,d,c,s)}}),g0e=P({batchNorm3d_:function m0e(n,t,e,i,r,s){const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,d;return null!=r&&(c=E(r,"scale","batchNorm")),null!=i&&(d=E(i,"offset","batchNorm")),S(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),S(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),S(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&S(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),null!=d&&S(3===d.rank||1===d.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),Ax(o,a,l,d,c,s)}}),b0e=P({batchNorm4d_:function _0e(n,t,e,i,r,s){const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,d;return null!=r&&(c=E(r,"scale","batchNorm")),null!=i&&(d=E(i,"offset","batchNorm")),S(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),S(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),S(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&S(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),null!=d&&S(4===d.rank||1===d.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),Ax(o,a,l,d,c,s)}}),sg=P({broadcastTo_:function y0e(n,t){let e=E(n,"broadcastTo","x");const i=e.shape;if(Ba(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=B(e,c)}const r=e.shape,s=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])s[c]=1;else if(1!==e.shape[c])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${t}].`);return 0===s.map((c,d)=>c>1?d:-1).filter(c=>c>=0).length?nd(e):O.runKernel(Wm,{x:e},{reps:s})}}),fs=P({clipByValue_:function v0e(n,t,e){const i=E(n,"x","clipByValue");return S(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?eg(i.shape,t,i.dtype):O.runKernel(am,{x:i},{clipValueMin:t,clipValueMax:e})}}),Qi=P({concat_:function x0e(n,t=0){S(n.length>=1,()=>"Pass at least one tensor to concat");const e=a4(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(s=>{if("complex64"!==s.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${s.dtype}. `)}),1===e.length?nd(e[0]):O.runKernel(xv,e,{axis:t})}}),C0e=P({concat1d_:function w0e(n){return Qi(n,0)}}),S0e=P({concat2d_:function D0e(n,t){return Qi(n,t)}}),E0e=P({concat3d_:function k0e(n,t){return Qi(n,t)}}),T0e=P({concat4d_:function I0e(n,t){return Qi(n,t)}}),sd=P({conv2d_:function A0e(n,t,e,i,r="NHWC",s=[1,1],o){const a=E(n,"x","conv2d","float32"),l=E(t,"filter","conv2d","float32");let c=a,d=!1;3===a.rank&&(d=!0,c=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===c.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),mr("conv2d",i,o);const u="NHWC"===r?c.shape[3]:c.shape[1];S(u===l.shape[2],()=>`Error in conv2d: depth of input (${u}) must match input depth for filter ${l.shape[2]}.`),S(Ui(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),S(rd(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),S(rd(e),()=>"Error in conv2D: Strides should be larger than 0.");const f=O.runKernel(wv,{x:c,filter:l},{strides:e,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o});return d?B(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Y4=P({conv1d_:function M0e(n,t,e,i,r="NWC",s=1,o){const a=E(n,"x","conv1d"),l=E(t,"filter","conv1d");let c=a,d=!1;2===a.rank&&(d=!0,c=B(a,[1,a.shape[0],a.shape[1]])),S(3===c.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),S(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),mr("conv1d",i,o),S(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),S(Ui(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),S(rd(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),S(rd(e),()=>"Error in conv1D: Stride should be larger than 0."),S("NWC"===r,()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const u=B(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=B(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=sd(h,u,[1,e],i,"NHWC",[1,s],o);return B(g,d?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}}),j1=P({conv2DBackpropInput_:function N0e(n,t,e,i,r,s="NHWC",o){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,c=!1;3===t.rank&&(c=!0,l=B(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),S(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),S(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),S(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const d="NHWC"===s?a[3]:a[1],u="NHWC"===s?l.shape[3]:l.shape[1];S(d===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${e.shape[2]}.`),S(u===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[3]}.`),mr("conv2dDerInput",r,o);const f=O.runKernel(Cv,{dy:l,filter:e},{strides:i,pad:r,dataFormat:s,dimRoundingMode:o,inputShape:a});return c?B(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),K4=P({conv2dTranspose_:function R0e(n,t,e,i,r,s){const o=E(n,"x","conv2dTranspose"),a=E(t,"filter","conv2dTranspose");return j1(e,o,a,i,r,"NHWC",s)}}),F0e=P({conv3d_:function O0e(n,t,e,i,r="NDHWC",s=[1,1,1]){const o=E(n,"x","conv3d"),a=E(t,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),S(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),S(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),S(Ui(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),S("NDHWC"===r,()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),S(rd(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),S(rd(e),()=>"Error in conv3D: Strides should be larger than 0.");const h=O.runKernel(Dv,{x:l,filter:a},{strides:e,pad:i,dataFormat:r,dilations:s});return c?B(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),X4=P({conv3DBackpropInput_:function P0e(n,t,e,i,r){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let s=n,o=t,a=!1;4===t.rank&&(a=!0,o=B(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,n[0],n[1],n[2],n[3]]);const l=s[4],c=o.shape[4];S(5===s.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),S(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),S(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),S(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),S(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const h=O.runKernel(_I,{dy:o,filter:e},{pad:r,strides:i,inputShape:s});return a?B(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),$0e=P({conv3dTranspose_:function L0e(n,t,e,i,r){const s=E(n,"x","conv3dTranspose"),o=E(t,"filter","conv3dTranspose");return X4(e,s,o,i,r)}}),Z4=P({denseBincount_:function V0e(n,t,e,i=!1){const r=E(n,"x","denseBincount"),s=E(t,"weights","denseBincount");return S("int32"===r.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),S(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(s.size===r.size||0===s.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`),O.runKernel(vI,{x:r,weights:s},{size:e,binaryOutput:i})}}),Mx=P({depthwiseConv2d_:function B0e(n,t,e,i,r="NHWC",s=[1,1],o){const a=E(n,"x","depthwiseConv2d","float32"),l=E(t,"filter","depthwiseConv2d","float32");let c=a,d=!1;3===a.rank&&(d=!0,c=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===c.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const u="NHWC"===r?c.shape[3]:c.shape[1];S(u===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u}) must match the inChannels dimension in filter ${l.shape[2]}.`),mr("depthwiseConv2d",i,o);const f=O.runKernel(kv,{x:c,filter:l},{strides:e,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o});return d?B(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Nx=P({elu_:function z0e(n){const e={x:E(n,"x","elu","float32")};return O.runKernel(um,e)}}),ea=P({equal_:function U0e(n,t){let e=E(n,"a","equal","string_or_numeric"),i=E(t,"b","equal","string_or_numeric");return[e,i]=Vn(e,i),Je(e.shape,i.shape),O.runKernel(Iv,{a:e,b:i})}}),js=P({exp_:function H0e(n){const e={x:E(n,"x","exp")};return O.runKernel(pm,e)}}),qr=P({expandDims_:function j0e(n,t=0){const e=E(n,"x","expandDims","string_or_numeric");return S(t<=e.rank,()=>"Axis must be <= rank of the tensor"),O.runKernel(Tv,{input:e},{dim:t})}}),vo=P({tile_:function W0e(n,t){const e=E(n,"x","tile","string_or_numeric");return S(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),O.runKernel(Wm,{x:e},{reps:t})}}),Q4=P({eye_:function G0e(n,t,e,i="float32"){null==t&&(t=n);const r=vt([n,t],i),s=n<=t?n:t;for(let a=0;a<s;++a)r.set(1,a,a);const o=B(r.toTensor(),[n,t]);if(null==e)return o;if(1===e.length)return vo(qr(o,0),[e[0],1,1]);if(2===e.length)return vo(qr(qr(o,0),0),[e[0],e[1],1,1]);if(3===e.length)return vo(qr(qr(qr(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),Rx=P({floor_:function q0e(n){const e={x:E(n,"x","floor","float32")};return O.runKernel(mm,e)}}),W1=P({gather_:function Y0e(n,t,e=0,i=0){const r=E(n,"x","gather"),s=E(t,"indices","gather","int32");return O.runKernel(Mv,{x:r,indices:s},{axis:e,batchDims:i})}}),ms=P({greater_:function K0e(n,t){let e=E(n,"a","greater","string_or_numeric"),i=E(t,"b","greater","string_or_numeric");return[e,i]=Vn(e,i),Je(e.shape,i.shape),O.runKernel(Nv,{a:e,b:i})}}),od=P({greaterEqual_:function X0e(n,t){let e=E(n,"a","greaterEqual","string_or_numeric"),i=E(t,"b","greaterEqual","string_or_numeric");return[e,i]=Vn(e,i),Je(e.shape,i.shape),O.runKernel(_m,{a:e,b:i})}}),G1=P({leakyRelu_:function Z0e(n,t=.2){const i={x:E(n,"x","leakyRelu")};return O.runKernel(Rv,i,{alpha:t})}}),Ws=P({log_:function Q0e(n){const e={x:E(n,"x","log","float32")};return O.runKernel(wm,e)}}),q1=P({log1p_:function J0e(n){const e={x:E(n,"x","log1p")};return O.runKernel(Cm,e)}}),xo=P({max_:function ewe(n,t=null,e=!1){const r={x:E(n,"x","max")};return O.runKernel(Bv,r,{reductionIndices:t,keepDims:e})}}),Ne=P({sum_:function twe(n,t=null,e=!1){let i=E(n,"x","sum");return"bool"===i.dtype&&(i=be(i,"int32")),O.runKernel(ox,{x:i},{axis:t,keepDims:e})}}),J4=P({logSoftmax_:function nwe(n,t=-1){const e=E(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return za((r,s)=>{const a=xo(r,t,!0),l=Me(r,a),c=Me(be(l,"float32"),Ws(Ne(js(l),t,!0)));return s([c]),{value:c,gradFunc:(u,h)=>{const[p]=h,m=js(p);return Me(u,N(Ne(u,t,!0),m))}}})(e)}}),ja=P({logicalAnd_:function iwe(n,t){const e=E(n,"a","logicalAnd","bool"),i=E(t,"b","logicalAnd","bool");return Je(e.shape,i.shape),O.runKernel(Pv,{a:e,b:i})}}),Ht=P({matMul_:function rwe(n,t,e=!1,i=!1){let r=E(n,"a","matMul"),s=E(t,"b","matMul");return[r,s]=Vn(r,s),O.runKernel(bv,{a:r,b:s},{transposeA:e,transposeB:i})}}),Y1=P({maxPool_:function swe(n,t,e,i,r){const s=E(n,"x","maxPool");let a=s,l=!1;3===s.rank&&(l=!0,a=B(s,[1,s.shape[0],s.shape[1],s.shape[2]])),S(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),S(Ui(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),mr("maxPool",i,r);const u=O.runKernel(zv,{x:a},{filterSize:t,strides:e,pad:i,dimRoundingMode:r});return l?B(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),awe=P({maxPool3d_:function owe(n,t=[1,1,1],e,i,r,s="NDHWC"){const o=E(n,"x","maxPool3d");let a=o,l=!1;4===o.rank&&(l=!0,a=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===s,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),mr("maxPool3d",i,r);const u=O.runKernel(Uv,{x:a},{filterSize:t,strides:e,pad:i,dimRoundingMode:r,dataFormat:s});return l?B(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),Yn=P({mean_:function lwe(n,t=null,e=!1){const r={x:E(n,"x","mean")};return O.runKernel(Hv,r,{axis:t,keepDims:e})}}),Ox=P({min_:function cwe(n,t=null,e=!1){const r={x:E(n,"x","min")};return O.runKernel(jv,r,{axis:t,keepDims:e})}}),Fx=P({minimum_:function dwe(n,t){let e=E(n,"a","minimum"),i=E(t,"b","minimum");return[e,i]=Vn(e,i),"bool"===e.dtype&&(e=be(e,"int32"),i=be(i,"int32")),Je(e.shape,i.shape),O.runKernel(Sm,{a:e,b:i})}});function K1(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function ej(n,t,e){const i=n.length+t.length,r=[];let s=0,o=0;for(let a=0;a<i;a++)-1===e.indexOf(a)?r.push(n[s++]):r.push(t[o++]);return r}function Ai(n,t){const e=[],i=n.length;for(let s=0;s<i;s++)-1===t.indexOf(s)&&e.push(n[s]);return[e,t.map(s=>n[s])]}function Kn(n,t){return ej(n,t.map(i=>1),t)}function Hi(n,t,e){S(K1(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function Rn(n,t){if(K1(n,t))return null;const e=[];for(let i=0;i<t;++i)-1===n.indexOf(i)&&e.push(i);return n.forEach(i=>e.push(i)),e}function Vl(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Xn(n,t){const e=[];for(let i=t-n;i<t;++i)e.push(i);return e}const X1=P({moments_:function uwe(n,t=null,e=!1){const i=yt(t,(n=E(n,"x","moments")).shape),r=Yn(n,i,e);let s=r.shape;e||(s=Kn(r.shape,i));const o=dn(Me(be(n,"float32"),B(r,s)));return{mean:r,variance:Yn(o,i,e)}}}),On=P({neg_:function hwe(n){const e={x:E(n,"x","neg")};return O.runKernel(Gv,e)}}),og=P({notEqual_:function pwe(n,t){let e=E(n,"a","notEqual","string_or_numeric"),i=E(t,"b","notEqual","string_or_numeric");return[e,i]=Vn(e,i),Je(e.shape,i.shape),O.runKernel(qv,{a:e,b:i})}}),tj=P({oneHot_:function fwe(n,t,e=1,i=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:E(n,"indices","oneHot","int32")};return O.runKernel(Kv,o,{dtype:r,depth:t,onValue:e,offValue:i})}});function Mi(n,t="float32"){if(Ba(n),"complex64"===t){const i=Mi(n,"float32"),r=Mi(n,"float32");return Jc(i,r)}const e=Xi(K(n),t);return O.makeTensor(e,n,t)}function Bl(n,t="float32"){if(Ba(n),"complex64"===t){const i=Bl(n,"float32"),r=Mi(n,"float32");return Jc(i,r)}const e=rI(K(n),t);return O.makeTensor(e,n,t)}const Gs=P({onesLike_:function mwe(n){const e={x:E(n,"x","onesLike")};return O.runKernel(Yv,e)}}),Z1=P({pad_:function gwe(n,t,e=0){const i=E(n,"x","pad");if(0===i.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return O.runKernel(Zv,{x:i},{paddings:t,constantValue:e})}}),Q1=P({prelu_:function _we(n,t){const e=E(n,"x","prelu"),i=E(t,"alpha","prelu");return O.runKernel(Qv,{x:e,alpha:i})}});var J1=fe(340);class eT{constructor(t,e,i,r,s){this.mean=t,this.stdDev=e,this.dtype=i,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=s||Math.random();this.random=J1.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,e,i=!1;for(;!i;){let r,s,o;do{r=2*this.random()-1,s=2*this.random()-1,o=r*r+s*s}while(o>=1||0===o);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*a,e=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(t))&&(i=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class bwe{constructor(t=0,e=1,i,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=i,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=J1.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Cwe=P({randomNormal_:function wwe(n,t=0,e=1,i,r){if(Ba(n),null!=i&&"bool"===i)throw new Error(`Unsupported data type ${i}`);const s=new eT(t,e,i,!1,r),o=vt(n,i);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}}),Px=P({randomUniform_:function Dwe(n,t=0,e=1,i="float32",r){Ba(n);const s=vt(n,i),o=new bwe(t,e,null,r);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}});function ag(n,t,e=1,i="float32"){if(0===e)throw new Error("Cannot have a step of zero");return O.runKernel($I,{},{start:n,stop:t,step:e,dtype:i})}const Wa=P({relu_:function Swe(n){const e={x:E(n,"x","relu")};return O.runKernel(Am,e)}}),ad=P({reverse_:function kwe(n,t){const i={x:E(n,"x","reverse")};return O.runKernel(ix,i,{dims:t})}}),nj=P({selu_:function Ewe(n){const e={x:E(n,"x","selu")};return O.runKernel(Om,e)}}),ij=P({separableConv2d_:function Iwe(n,t,e,i,r,s=[1,1],o="NHWC"){const a=E(n,"x","separableConv2d"),l=E(t,"depthwiseFilter","separableConv2d"),c=E(e,"pointwiseFilter","separableConv2d");let d=a,u=!1;if(3===a.rank&&(u=!0,d=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(4===d.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),S(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),S(4===c.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),S(1===c.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),S(1===c.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const h=l.shape[2],p=l.shape[3];S(c.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${c.shape[2]}.`);const f=Mx(d,l,i,r,o,s),g=sd(f,c,1,"valid",o);return u?B(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),uh=P({sigmoid_:function Twe(n){const e={x:E(n,"x","sigmoid","float32")};return O.runKernel($m,e)}}),tn=P({slice_:function Awe(n,t,e){const i=E(n,"x","slice","string_or_numeric");if(0===i.rank)throw new Error("Slicing scalar is not possible");return O.runKernel(sx,{x:i},{begin:t,size:e})}}),nT=P({slice1d_:function Mwe(n,t,e){const i=E(n,"x","slice1d");return S(1===i.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${i.rank} tensor`),tn(i,[t],[e])}}),rj=P({slice2d_:function Nwe(n,t,e){const i=E(n,"x","slice2d");return S(2===i.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${i.rank} tensor`),tn(i,t,e)}}),iT=P({slice3d_:function Rwe(n,t,e){const i=E(n,"x","slice3d");return S(3===i.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${i.rank} tensor`),tn(i,t,e)}}),Lx=P({slice4d_:function Owe(n,t,e){const i=E(n,"x","slice4d");return S(4===i.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${i.rank} tensor`),tn(i,t,e)}}),rT=P({softmax_:function Fwe(n,t=-1){const e=E(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return O.runKernel(cx,{logits:e},{dim:t})}}),lg=P({softplus_:function Pwe(n){const e={x:E(n,"x","softplus")};return O.runKernel(Vm,e)}}),gs=P({split_:function Lwe(n,t,e=0){const r={x:E(n,"x","split")};return O.runKernel(lx,r,{numOrSizeSplits:t,axis:e})}}),cg=P({squeeze_:function $we(n,t){const e=E(n,"x","squeeze","string_or_numeric");return B(e,Tl(e.shape,t).newShape)}}),zl=P({stack_:function Vwe(n,t=0){const e=a4(n,"tensors","stack","string_or_numeric");return S(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&S(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),O.runKernel(Xv,e,{axis:t})}}),sT=P({tanh_:function Bwe(n){const e={x:E(n,"x","tanh","float32")};return O.runKernel(jm,e)}});function gr(n,t){JE(n);const e=Zm(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Qm(n,null,e,t)}function dg(n,t,e){if(JE(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const i=Zm(n,e);if(2!==i.length&&1!==i.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Qm(n,t,i,e)}const sj=P({truncatedNormal_:function zwe(n,t=0,e=1,i,r){if(Ba(n),null!=i&&"bool"===i)throw new Error("Unsupported data type $ { dtype }");const s=new eT(t,e,i,!0,r),o=vt(n,i);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}}),ld=P({unstack_:function Uwe(n,t=0){const e=E(n,"x","unstack","string_or_numeric");return S(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),O.runKernel(dx,{value:e},{axis:t})}}),Yr=P({where_:function jwe(n,t,e){const i=E(t,"a","where"),r=E(e,"b","where"),s=E(n,"condition","where","bool"),o=Je(Je(s.shape,i.shape),r.shape),a=sg(s,o),l=sg(i,o),c=sg(r,o);return O.runKernel(rx,{condition:a,t:l,e:c})}}),oT=P({imag_:function Wwe(n){const e={input:E(n,"input","imag")};return O.runKernel(MI,e)}}),$x=P({real_:function Gwe(n){const e={input:E(n,"input","real")};return O.runKernel(VI,e)}}),Mt=P({transpose_:function qwe(n,t,e){const i=E(n,"x","transpose");if(null==t&&(t=i.shape.map((o,a)=>a).reverse()),S(i.rank===t.length,()=>`Error in transpose: rank of input ${i.rank} must match length of perm ${t}.`),t.forEach(o=>{S(o>=0&&o<i.rank,()=>`All entries in 'perm' must be between 0 and ${i.rank-1} but got ${t}`)}),i.rank<=1)return i.clone();const r={x:i},s={perm:t};return"complex64"===i.dtype?G(()=>{let o=$x(i),a=oT(i);return o=O.runKernel(eh,{x:o},s),a=O.runKernel(eh,{x:a},s),e&&(a=On(a)),Jc(o,a)}):O.runKernel(eh,r,s)}}),Xwe=P({dropout_:function Kwe(n,t,e,i){const r=E(n,"x","dropout");if(S("float32"===r.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),S(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof qn?r.clone():r;const s=function Ywe(n,t){if(null==t)return n.shape.slice();if(Ut(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let i=0;i<n.shape.length;i++)e.push(null==t[i]&&null!=n.shape[i]?n.shape[i]:t[i]);return e}return t}(r,e),o=1-t,a=$e(Rx(ue(Px(s,0,1,"float32",i),o)),o);return N(r,a)}}),aT=P({fft_:function Zwe(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),O.runKernel("FFT",{input:n})}}),lT=P({rfft_:function Qwe(n,t){S("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const i=n.size/e;let r;if(null!=t&&t<e){const f=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=t,r=tn(n,f,m),e=t}else if(null!=t&&t>e){const f=n.shape.map(m=>m);f[n.shape.length-1]=t-e,r=Qi([n,Mi(f)],n.shape.length-1),e=t}else r=n;const s=Nt(r),o=B(Jc(r,s),[i,e]),a=aT(o),l=Math.floor(e/2)+1,c=$x(a),d=oT(a),u=gs(c,[l,e-l],c.shape.length-1),h=gs(d,[l,e-l],d.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,B(Jc(u[0],h[0]),p)}}),Vx=P({ifft_:function Jwe(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),O.runKernel(AI,{input:n})}}),oj=P({irfft_:function eCe(n){const t=n.shape[n.shape.length-1],e=n.size/t;let i;if(t<=2){const r=B(n,[e,t]);i=Vx(r)}else{const r=[e,2*(t-1)],s=B($x(n),[e,t]),o=B(oT(n),[e,t]),a=ad(tn(s,[0,1],[e,t-2]),1),l=N(ad(tn(o,[0,1],[e,t-2]),1),Ke(-1)),c=Qi([s,a],1),d=Qi([o,l],1),u=B(Jc(c,d),[r[0],r[1]]);i=Vx(u)}if(i=$x(i),3===n.rank&&0!==n.shape[0]){const r=i,s=n.shape[0];i=B(i,[s,i.shape[0]/s,i.shape[1]]),r.dispose()}return i}}),cT=P({conv2DBackpropFilter_:function tCe(n,t,e,i,r,s="NHWC",o){let a=n;3===n.rank&&(a=B(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=B(t,[1,t.shape[0],t.shape[1],t.shape[2]])),S(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),S(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),S(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c="NHWC"===s?a.shape[3]:a.shape[1],d="NHWC"===s?l.shape[3]:l.shape[1];return S(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),S(d===e[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${e[3]}).`),mr("conv2dDerFilter",r,o),O.runKernel(mI,{x:a,dy:l},{strides:i,pad:r,dataFormat:s,dimRoundingMode:o,filterShape:e})}}),aj=P({relu6_:function nCe(n){const e={x:E(n,"x","relu6")};return O.runKernel(Mm,e)}}),ug=P({step_:function iCe(n,t=0){const i={x:E(n,"x","step")};return O.runKernel(Gm,i,{alpha:t})}});function Bx(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return N(n,ug(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function zx(n,t){let e=t;const i=hi(n.shape,t.shape);return i.length>0&&(e=Ne(e,i)),B(e,n.shape)}function Ux(n,t,e,i){if("linear"===t)return n;if("relu"===t)return Wa(n);if("elu"===t)return Nx(n);if("relu6"===t)return aj(n);if("prelu"===t)return Q1(n,e);if("leakyrelu"===t)return G1(n,i);if("sigmoid"===t)return uh(n);throw new Error(`Unknown fused activation ${t}.`)}const Hx=(n,t)=>!(n>0)||"linear"===t,sCe=P({fusedConv2d_:function rCe({x:n,filter:t,strides:e,pad:i,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(!1===Hx(O.state.gradientDepth,l=l||"linear")){S("NHWC"===r,()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let w=sd(n,t,e,i,r,s,o);return null!=a&&(w=ue(w,a)),Ux(w,l,c,d)}const u=E(n,"x","conv2d","float32"),h=E(t,"filter","conv2d","float32");let p=u,f=!1;3===u.rank&&(f=!0,p=B(u,[1,u.shape[0],u.shape[1],u.shape[2]])),S(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),S(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),mr("fused conv2d",i,o);const m="NHWC"===r?p.shape[3]:p.shape[1];S(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),S(Ui(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);const g=Ti(p.shape,h.shape,e,s,i,o);let _,b;if(null!=a&&(_=E(a,"bias","fused conv2d"),[_]=Vn(_,u),"NHWC"===r?Je(g.outShape,_.shape):(S(_.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${_.shape.length}.`),S(0===_.shape.length||_.shape[0]===g.outChannels||1===_.shape[0],()=>`Error in fused conv2d: bias shape (${_.shape}) is not compatible with the number of output channels (${g.outChannels})`))),null!=c){const w=c.shape;if(S(w.length<=1||3===w.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${w.length}.`),1===w.length)S(1===w[0]||w[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the number of output channels (${g.outChannels}).`);else if(3===w.length)try{Je(w,g.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the output shape of the conv2d (${g.outShape}).`)}b=E(c,"prelu weights","fused conv2d")}const y=(w,C)=>{S("NHWC"===r,()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[D,k,I,A]=C,$=Bx(w,I,l);S($l(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const z=[j1(k.shape,$,D,e,i),cT(k,$,D.shape,e,i)];if(null!=A){const M=zx(A,$);z.push(M)}return z},v={x:p,filter:h,bias:_,preluActivationWeights:b},x={strides:e,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:d};return null==a?za((C,D,k)=>{let I=O.runKernel(fx,v,x);return k([D,C,I]),f&&(I=B(I,[I.shape[1],I.shape[2],I.shape[3]])),{value:I,gradFunc:y}})(p,h):za((C,D,k,I)=>{let A=O.runKernel(fx,v,x);return I([D,C,A,k]),f&&(A=B(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:y}})(p,h,_)}}),lj=P({depthwiseConv2dNativeBackpropFilter_:function oCe(n,t,e,i,r,s=[1,1],o){let a=n;3===n.rank&&(a=B(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=B(t,[1,t.shape[0],t.shape[1],t.shape[2]])),O.runKernel(wI,{x:a,dy:l},{strides:i,pad:r,dimRoundingMode:o,dilations:s,filterShape:e})}}),cj=P({depthwiseConv2dNativeBackpropInput_:function aCe(n,t,e,i,r,s=[1,1],o){let a=t,l=!1;3===t.rank&&(l=!0,a=B(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u=O.runKernel(CI,{dy:a,filter:e},{strides:i,pad:r,dimRoundingMode:o,dilations:s,inputShape:n});return l?B(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),dj=P({fusedMatMul_:function cCe({a:n,b:t,transposeA:e=!1,transposeB:i=!1,bias:r,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(!1===Hx(O.state.gradientDepth,s)){let A=Ht(n,t,e,i);return null!=r&&(A=ue(A,r)),Ux(A,s,o,a)}let l=E(n,"a","fused matMul"),c=E(t,"b","fused matMul");[l,c]=Vn(l,c);const d=e?l.shape[l.rank-2]:l.shape[l.rank-1],u=i?c.shape[c.rank-1]:c.shape[c.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],p=i?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=K(f),_=K(m);S(d===u,()=>`Error in fused matMul: inner shapes (${d}) and (${u}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${i} must match.`);const y=Je(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([h,p]),v=B(l,e?[g,d,h]:[g,h,d]),x=B(c,i?[_,p,u]:[_,u,p]);let w,C;null!=r&&(w=E(r,"bias","fused matMul"),[w]=Vn(w,l),Je(y,w.shape)),null!=o&&(C=E(o,"prelu weights","fused matMul"));const D=(A,$)=>{const[H,W,z,M]=$,F=Bx(B(A,z.shape),z,s);let L,j;return e||i?!e&&i?(L=Ht(F,W,!1,!1),j=Ht(F,H,!0,!1)):e&&!i?(L=Ht(W,F,!1,!0),j=Ht(H,F,!1,!1)):(L=Ht(W,F,!0,!0),j=Ht(F,H,!0,!0)):(L=Ht(F,W,!1,!0),j=Ht(H,F,!0,!1)),null!=r?[L,j,zx(M,F)]:[L,j]},k={a:v,b:x,bias:w,preluActivationWeights:C},I={transposeA:e,transposeB:i,activation:s,leakyreluAlpha:a};return null==r?za(($,H,W)=>{const z=O.runKernel(px,k,I);return W([$,H,z]),{value:B(z,y),gradFunc:D}})(v,x):za(($,H,W,z)=>{const M=O.runKernel(px,k,I);return z([$,H,M,W]),{value:B(M,y),gradFunc:D}})(v,x,w)}}),bCe=P({cropAndResize_:function _Ce(n,t,e,i,r="bilinear",s=0){const o=E(n,"image","cropAndResize"),a=E(t,"boxes","cropAndResize","float32"),l=E(e,"boxInd","cropAndResize","int32"),c=a.shape[0];return S(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),S(1===l.rank&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),S(2===i.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${i.length}.`),S(i[0]>=1&&i[1]>=1,()=>`cropSize must be atleast [1,1], but was ${i}`),S("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),O.runKernel(yI,{image:o,boxes:a,boxInd:l},{method:r,extrapolationValue:s,cropSize:i})}}),vCe=P({flipLeftRight_:function yCe(n){const t=E(n,"image","flipLeftRight","float32");return S(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),O.runKernel(TI,{image:t},{})}}),wCe=P({grayscaleToRGB_:function xCe(n){const t=E(n,"image","grayscaleToRGB"),e=t.rank-1,i=t.shape[e];S(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),S(1===i,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${i}.`);const r=new Array(t.rank);return r.fill(1,0,e),r[e]=3,vo(t,r)}}),DCe=P({rotateWithOffset_:function CCe(n,t,e=0,i=.5){const r=E(n,"image","rotateWithOffset","float32");return S(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),O.runKernel(t1,{image:r},{radians:t,fillValue:e,center:i})}});function hh(n,t,e,i,r,s){null==i&&(i=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=n.shape[0];return e=Math.min(e,o),S(0<=i&&i<=1,()=>`iouThreshold must be in [0, 1], but was '${i}'`),S(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),S(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),S(1===t.rank,()=>"scores must be a 1D tensor"),S(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),S(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:i,scoreThreshold:r,softNmsSigma:s}}const kCe=P({nonMaxSuppression_:function SCe(n,t,e,i=.5,r=Number.NEGATIVE_INFINITY){const s=E(n,"boxes","nonMaxSuppression","float32"),o=E(t,"scores","nonMaxSuppression","float32"),a=hh(s,o,e,i,r);return O.runKernel(FI,{boxes:s,scores:o},{maxOutputSize:e=a.maxOutputSize,iouThreshold:i=a.iouThreshold,scoreThreshold:r=a.scoreThreshold})}});function ECe(n,t,e){const i=function ICe(n,t,e){return function ACe(n,t,e){let i=0,r=n.length,s=0,o=!1;for(;i<r;){s=i+(r-i>>>1);const a=e(t,n[s]);a>0?i=s+1:(r=s,o=!a)}return o?i:-i-1}(n,t,e||TCe)}(n,t,e);n.splice(i<0?-(i+1):i,0,t)}function TCe(n,t){return n>t?1:n<t?-1:0}function dT(n,t,e,i,r){return pT(n,t,e,i,r,0)}function uT(n,t,e,i,r,s){return pT(n,t,e,i,r,0,!1,s,!0)}function hT(n,t,e,i,r,s){return pT(n,t,e,i,r,s,!0)}function pT(n,t,e,i,r,s,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<t.length;g++)t[g]>r&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort(fj);const d=s>0?-.5/s:0,u=[],h=[];for(;u.length<e&&c.length>0;){const g=c.pop(),{score:_,boxIndex:b,suppressBeginIndex:y}=g;if(_<r)break;let v=!1;for(let x=u.length-1;x>=y;--x){const w=MCe(n,b,u[x]);if(w>=i){v=!0;break}if(g.score=g.score*NCe(i,d,w),g.score<=r)break}g.suppressBeginIndex=u.length,v||(g.score===_?(u.push(b),h.push(g.score)):g.score>r&&ECe(c,g,fj))}const p=u.length,f=e-p;a&&f>0&&(u.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:u};return o&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function MCe(n,t,e){const i=n.subarray(4*t,4*t+4),r=n.subarray(4*e,4*e+4),s=Math.min(i[0],i[2]),o=Math.min(i[1],i[3]),a=Math.max(i[0],i[2]),l=Math.max(i[1],i[3]),c=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),u=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),p=(a-s)*(l-o),f=(u-c)*(h-d);if(p<=0||f<=0)return 0;const m=Math.max(s,c),g=Math.max(o,d),_=Math.min(a,u),b=Math.min(l,h),y=Math.max(_-m,0)*Math.max(b-g,0);return y/(p+f-y)}function NCe(n,t,e){const i=Math.exp(t*e*e);return e<=n?i:0}function fj(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function fT(){return fT=ie(function*(n,t,e,i=.5,r=Number.NEGATIVE_INFINITY){const s=E(n,"boxes","nonMaxSuppressionAsync"),o=E(t,"scores","nonMaxSuppressionAsync"),a=hh(s,o,e,i,r);e=a.maxOutputSize,i=a.iouThreshold,r=a.scoreThreshold;const l=yield Promise.all([s.data(),o.data()]),c=l[0],d=l[1],{selectedIndices:u}=dT(c,d,e,i,r);return s!==n&&s.dispose(),o!==t&&o.dispose(),gr(u,"int32")}),fT.apply(this,arguments)}const PCe=P({nonMaxSuppressionWithScore_:function FCe(n,t,e,i=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=E(n,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=hh(o,a,e,i,r,s),u=O.runKernel(LI,{boxes:o,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:i=l.iouThreshold,scoreThreshold:r=l.scoreThreshold,softNmsSigma:s=l.softNmsSigma});return{selectedIndices:u[0],selectedScores:u[1]}}});function mT(){return mT=ie(function*(n,t,e,i=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=E(n,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=hh(o,a,e,i,r,s);e=l.maxOutputSize,i=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;const c=yield Promise.all([o.data(),a.data()]),d=c[0],u=c[1],{selectedIndices:h,selectedScores:p}=hT(d,u,e,i,r,s);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:gr(h,"int32"),selectedScores:gr(p)}}),mT.apply(this,arguments)}const BCe=P({nonMaxSuppressionPadded_:function VCe(n,t,e,i=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=E(n,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=hh(o,a,e,i,r,null),f=O.runKernel(PI,{boxes:o,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s});return{selectedIndices:f[0],validOutputs:f[1]}}});function gT(){return gT=ie(function*(n,t,e,i=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=E(n,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=hh(o,a,e,i,r,null),c=l.maxOutputSize,d=l.iouThreshold,u=l.scoreThreshold,[h,p]=yield Promise.all([o.data(),a.data()]),{selectedIndices:f,validOutputs:m}=uT(h,p,c,d,u,s);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:gr(f,"int32"),validOutputs:Ke(m,"int32")}}),gT.apply(this,arguments)}const mj=P({resizeBilinear_:function HCe(n,t,e=!1,i=!1){const r=E(n,"images","resizeBilinear");S(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),S(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),S(!1===i||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=r,o=!1;3===r.rank&&(o=!0,s=B(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,c=O.runKernel(nx,{images:s},{alignCorners:e,halfPixelCenters:i,size:t});return o?B(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),gj=P({resizeNearestNeighbor_:function jCe(n,t,e=!1,i=!1){const r=E(n,"images","resizeNearestNeighbor");S(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),S(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),S("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),S(!1===i||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=r,o=!1;3===r.rank&&(o=!0,s=B(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,c=O.runKernel(tx,{images:s},{alignCorners:e,halfPixelCenters:i,size:t});return o?B(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),GCe=P({bincount_:function WCe(n,t,e){const i=E(n,"x","bincount"),r=E(t,"weights","bincount");return S("int32"===i.dtype,()=>`Error in bincount: input dtype must be int32, but got ${i.dtype}`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(r.size===i.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${i.shape}, weights shape: ${r.shape}.`),O.runKernel(pI,{x:i,weights:r},{size:e})}}),ph=P({lessEqual_:function qCe(n,t){let e=E(n,"a","lessEqual","string_or_numeric"),i=E(t,"b","lessEqual","string_or_numeric");return[e,i]=Vn(e,i),Je(e.shape,i.shape),O.runKernel(Fv,{a:e,b:i})}}),_j=P({round_:function YCe(n){const e={x:E(n,"x","round")};return O.runKernel(Nm,e)}}),ZCe=P({threshold_:function KCe(n,t="binary",e=!1,i=.5){const r=E(n,"image","threshold"),l=r.shape[0]*r.shape[1];let d,u,h,p,c=N(gr([i]),255);if(S(3===r.rank,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),S(3===r.shape[2]||1===r.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),S("int32"===r.dtype||"float32"===r.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),S("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===r.shape[2]){[d,u,h]=gs(r,[1,1,1],-1);const g=N(d,.2989),_=N(u,.587),b=N(h,.114);p=ue(ue(g,_),b)}else p=n;"otsu"===t&&(c=function XCe(n,t){let s,o,a,l,c,d,e=gr([-1]),i=gr([0]),r=gr([0]);for(let u=0;u<n.size-1;u++){s=tn(n,0,u+1),o=tn(n,u+1),c=$e(Ne(s),t),d=$e(Ne(o),t);const h=Ne(N(s,ag(0,s.size)));a=$e(h,Ne(s));const p=eg(o.shape,s.size),f=ue(ag(0,o.size),p),m=N(o,f);l=$e(Ne(m),Ne(o));const g=Me(a,l),_=Me(a,l),b=N(c,d);r=N(N(b,g),_);const y=ms(r,i);i=Yr(y,r,i),e=Yr(y,gr([u]),e)}return e}(GCe(be(_j(p),"int32"),Jm([]),256),l));const f=e?ph(p,c):ms(p,c);return be(N(f,255),"int32")}}),JCe=P({transform_:function QCe(n,t,e="nearest",i="constant",r=0,s){const o=E(n,"image","transform","float32"),a=E(t,"transforms","transform","float32");return S(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&(a.shape[0]===o.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(null==s||2===s.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`),O.runKernel(QI,{image:o,transforms:a},{interpolation:e,fillMode:i,fillValue:r,outputShape:s})}}),tDe=P({bandPart_:function eDe(n,t,e){S(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),S(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);const i=E(n,"a","bandPart");S(i.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${i.rank}.`);const r=i.shape,[s,o]=i.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(e<=o))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`);t<0&&(t=s),e<0&&(e=o);const a=B(ag(0,s,1,"int32"),[-1,1]),l=ag(0,o,1,"int32"),c=Me(a,l),d=ja(ph(c,Ke(+t,"int32")),od(c,Ke(-e,"int32"))),u=Mi([s,o],i.dtype);return B(zl(ld(B(i,[-1,s,o])).map(h=>Yr(d,h,u))),r)}});function bj(n,t,e=null){if(0===n.rank)return Ii(n);if(1!==n.rank&&null===e)return bj(B(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return Ne(Ii(n),e);if(t===1/0)return xo(Ii(n),e);if(t===-1/0)return Ox(Ii(n),e);if("euclidean"===t||2===t)return fr(Ne(lh(Ii(n),Ke(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return xo(Ne(Ii(n),e[0]),e[1]-1);if(t===1/0)return xo(Ne(Ii(n),e[1]),e[0]);if(t===-1/0)return Ox(Ne(Ii(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return fr(Ne(dn(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const jx=P({norm_:function nDe(n,t="euclidean",e=null,i=!1){const r=bj(n=E(n,"x","norm"),t,e);let s=r.shape;if(i){const o=yt(e,n.shape);s=Kn(r.shape,o)}return B(r,s)}}),rDe=P({gramSchmidt_:function iDe(n){let t;if(Array.isArray(n)){t=!1,S(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let s=1;s<n.length;++s)S(n[s].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[s].shape[0]} vs. ${r})`)}else t=!0,n=gs(n,n.shape[0],0).map(r=>cg(r,[0]));S(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],i=n;for(let r=0;r<n.length;++r)e.push(O.tidy(()=>{let s=i[r];if(r>0)for(let o=0;o<r;++o){const a=N(Ne(N(e[o],s)),e[o]);s=Me(s,a)}return $e(s,jx(s,"euclidean"))}));return t?zl(e,0):e}});function yj(n,t=!1){return O.tidy(()=>{S(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],i=n.shape[1];let r=Q4(e),s=nd(n);const o=dg([[1]],[1,1]);let a=nd(o);const l=e>=i?i:e;for(let c=0;c<l;++c){const d=s,u=a,h=r;[a,s,r]=O.tidy(()=>{const p=tn(s,[c,c],[e-c,1]),f=jx(p),m=tn(s,[c,c],[1,1]),g=Yr(ms(m,0),dg([[-1]]),dg([[1]])),_=Me(m,N(g,f)),b=$e(p,_);a=1===b.shape[0]?nd(o):Qi([o,tn(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const y=On($e(Ht(g,_),f)),v=tn(s,[c,0],[e-c,i]),x=N(y,a),w=Mt(a);if(0===c)s=Me(v,Ht(x,Ht(w,v)));else{const k=Me(v,Ht(x,Ht(w,v)));s=Qi([tn(s,[0,0],[c,i]),k],0)}const C=Mt(x),D=tn(r,[0,c],[e,r.shape[1]-c]);if(0===c)r=Me(D,Ht(Ht(D,a),C));else{const k=Me(D,Ht(Ht(D,a),C));r=Qi([tn(r,[0,0],[e,c]),k],1)}return[a,s,r]}),mt([d,u,h])}return!t&&e>i&&(r=tn(r,[0,0],[e,i]),s=tn(s,[0,0],[i,i])),[r,s]})}const oDe=P({qr_:function sDe(n,t=!1){if(S(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return yj(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),i=ld(B(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],s=[];return i.forEach(l=>{const[c,d]=yj(l,t);r.push(c),s.push(d)}),[B(zl(r,0),n.shape),B(zl(s,0),n.shape)]}}}),vj=P({squaredDifference_:function bDe(n,t){let e=E(n,"a","squaredDifference"),i=E(t,"b","squaredDifference");return[e,i]=Vn(e,i),Je(e.shape,i.shape),O.runKernel(zm,{a:e,b:i},{})}}),xj=P({logSumExp_:function DDe(n,t=null,e=!1){const i=E(n,"x","logSumExp"),r=yt(t,i.shape),s=xo(i,r,!0),o=Me(i,s),a=js(o),l=Ne(a,r),c=Ws(l),d=ue(B(s,c.shape),c);if(e){const u=Kn(d.shape,r);return B(d,u)}return d}}),cd={flipLeftRight:vCe,grayscaleToRGB:wCe,resizeNearestNeighbor:gj,resizeBilinear:mj,rotateWithOffset:DCe,cropAndResize:bCe,nonMaxSuppression:kCe,nonMaxSuppressionAsync:function RCe(n,t,e){return fT.apply(this,arguments)},nonMaxSuppressionWithScore:PCe,nonMaxSuppressionWithScoreAsync:function LCe(n,t,e){return mT.apply(this,arguments)},nonMaxSuppressionPadded:BCe,nonMaxSuppressionPaddedAsync:function zCe(n,t,e){return gT.apply(this,arguments)},threshold:ZCe,transform:JCe},UDe={bandPart:tDe,gramSchmidt:rDe,qr:oDe},fh=class HDe{static sgd(t){return new E1(t)}static momentum(t,e,i=!1){return new E4(t,e,i)}static rmsprop(t,e=.9,i=0,r=null,s=!1){return new I4(t,e,i,r,s)}static adam(t=.001,e=.9,i=.999,r=null){return new S4(t,e,i,r)}static adadelta(t=.001,e=.95,i=null){return new C4(t,e,i)}static adamax(t=.002,e=.9,i=.999,r=null,s=0){return new k4(t,e,i,r,s)}static adagrad(t,e=.1){return new D4(t,e)}},jDe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function wj(){return new Promise(n=>jDe(()=>n()))}function _T(n,t){const e=n[0].length;n.forEach((r,s)=>{S(r.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),S(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const i=n[0];n.forEach((r,s)=>{for(let o=0;o<e;o++)S(o===t||r[o]===i[o],()=>`Error in concat${e}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${i}) along the non-concatenated axis ${s}.`)})}function ta(n,t){const e=n[0].slice();for(let i=1;i<n.length;i++)e[t]+=n[i][t];return e}var qs=(()=>(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"}(qs||(qs={})),qs))();function Cj(n,t,e){let i=new Array;if(null==e&&null==t)return i;if(null==t)for(;i.length<n+e.length;)i.push(-1);else i=t.slice();if(null==e)return i;if(n+e.length!==i.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${i.length}`);for(let r=1;r<e.length;++r){const s=e[r],o=i[i.length-e.length+r],a=i[o];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+n}] = ${s} but shape[${r+n}] = ${a}`)}else i[o]=s}return i}function Dj(n){const t={FIRST_DIM_SIZE:qs.FIRST_DIM_SIZE,VALUE_ROWIDS:qs.VALUE_ROWIDS,ROW_LENGTHS:qs.ROW_LENGTHS,ROW_SPLITS:qs.ROW_SPLITS,ROW_LIMITS:qs.ROW_LIMITS,ROW_STARTS:qs.ROW_STARTS},e=[];for(const i of n){if(!(i in t))break;e.push(t[i])}return e}function Sj(n){return 0===n.length?0:n[0]===qs.FIRST_DIM_SIZE?n.length-1:n.length}function kj(n,t){if(null==n||null==t)return;const e=n.length,i=t.length;if(e>=i)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${i})`);for(let r=0;r<Math.min(e,i-1);++r){const s=n[r],o=t[r+1];if(s>=0&&o>=0&&1!==s&&s!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-n.length}] = ${s} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}const bT=30;function Wx(n){return n<=bT?n:iI(n,Math.floor(Math.sqrt(n)))}function yT(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function hg(n,t,e,i=!0){let r=[];if(i)r=r.concat(t.slice(0)),r.push(n[0]/e),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const s=t.length;for(let o=0;o<s;++o)r=r.concat([n[o+1]/t[o],t[o]]);r=r.concat(n.slice(s+1))}return r}function pg(n,t,e=!0){const i=[];if(e){i.push(t);for(let r=t+1;r<n;++r)r<=2*t?(i.push(r),i.push(r-(t+1))):i.push(r)}else{const r=[],s=[];for(let o=1;o<n;++o)o>=2*t+1||o%2==1?s.push(o):r.push(o);i.push(...r),i.push(0),i.push(...s)}return i}function fg(n,t,e,i=!0){const r=[];r.push(i?n[0]/e:n[0]*e);for(let s=1;s<n.length;++s)r.push(s<=t.length?i?t[s-1]*n[s]:n[s]/t[s-1]:n[s]);return r}function vT(n,t){const e=[0];for(let i=0;i<t;++i)e.push(n[i][0]);return e}function xT(n,t,e){const i=n.slice(0,1);for(let r=0;r<e;++r)i.push(n[r+1]-t[r][0]-t[r][1]);return i}function wT(n,t){const e=n.shape.length,i=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(i<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${i}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[i-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[i-1]} vs. ${e}`);if(0===K(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=t.shape,s=r[r.length-1];let o=1;for(let u=0;u<r.length-1;++u)o*=r[u];const a=n.shape,l=r.slice();l.pop();let c=1;for(let u=s;u<e;++u)c*=a[u],l.push(a[u]);const d=[...Le(n.shape).map(u=>u/c),1].slice(0,s);return[l,o,c,d]}function Ej(n,t,e){const i=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${i}, and batchDim: ${r}.`;if(e.rank<r)throw new Error(s+` update.rank < ${r}. `);if(n.length<i+(e.rank-r))throw new Error(s+` Output shape length < ${i+(e.rank-r)}`);if(e.rank!==r+n.length-i)throw new Error(s+" update.rank != "+(r+n.length-i));for(let o=0;o<r;++o)if(e.shape[o]!==t.shape[o])throw new Error(s+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-r;++o)if(e.shape[o+r]!==n[o+i])throw new Error(s+` updates.shape[${o+r}] (${e.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function WDe(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Ej(e,t,n)}function mg(n,t,e){const i=t.shape.length,r=i>1?t.shape[i-1]:1,s=e.length;let o=1;for(let u=r;u<s;++u)o*=e[u];const a=r<1?1:r;return{sliceRank:r,numUpdates:K(t.shape)/a,sliceSize:o,strides:[...Le(e.slice(0,r)),1],outputSize:K(e)}}const Gx=1.7580993408473768,qx=1.0507009873554805,CT=.3275911,DT=.254829592,ST=-.284496736,kT=1.421413741,ET=-1.453152027,IT=1.061405429;function qa(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let i=0;i<e.length;i+=2)e[i]=n[i/2],e[i+1]=t[i/2];return e}function Ij(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let i=0;i<n.length;i+=2)t[i/2]=n[i],e[i/2]=n[i+1];return{real:t,imag:e}}function Tj(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),i=new Float32Array(t);for(let r=0;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],i[Math.floor(r/4)]=n[r+1];return{real:e,imag:i}}function Aj(n){const t=Math.floor(n.length/4),e=new Float32Array(t),i=new Float32Array(t);for(let r=2;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],i[Math.floor(r/4)]=n[r+1];return{real:e,imag:i}}function TT(n,t){return{real:n[2*t],imag:n[2*t+1]}}function Mj(n,t,e,i){n[2*i]=t,n[2*i+1]=e}function Nj(n,t){const e=new Float32Array(n/2),i=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const s=(t?2:-2)*Math.PI*(r/n);e[r]=Math.cos(s),i[r]=Math.sin(s)}return{real:e,imag:i}}function Rj(n,t,e){const i=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(i),imag:Math.sin(i)}}const AT="->",GDe=/->/g,Oj=",",Fj="...";function MT(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(GDe,"").length)/AT.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${AT}").`);const[i,r]=n.split(AT);S(-1===i.indexOf(Fj),()=>`The ellipsis notation ("${Fj}") is not supported yet.`);const s=i.split(Oj),o=s.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<r.length;++h){const p=r[h];if(!s.some(f=>-1!==f.indexOf(p)))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);-1===a.indexOf(p)&&a.push(p)}for(let h=0;h<i.length;++h){const p=i[h];-1===a.indexOf(p)&&p!==Oj&&a.push(p)}const l=new Array(s.length);for(let h=0;h<o;++h){if(new Set(s[h].split("")).size!==s[h].length)throw new Error(`Found duplicate axes in input component ${s[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<s[h].length;++p)l[h].push(a.indexOf(s[h][p]))}const c=a.length,u=[];for(let h=r.length;h<c;++h)u.push(h);return{allDims:a,summedDims:u,idDims:l}}function NT(n,t){let e=new Array(n);e.fill(-1);for(let r=0;r<t.length;++r)e[t[r]]=r;const i=[];for(let r=0;r<n;++r)-1===e[r]&&i.push(r);return e=e.filter(r=>-1!==r),{permutationIndices:e,expandDims:i}}function RT(n,t,e){const i=new Array(n);for(let r=0;r<e.length;++r){const s=e[r].shape;for(let o=0;o<t[r].length;++o)void 0===i[t[r][o]]?i[t[r][o]]=s[o]:S(i[t[r][o]]===s[o],()=>`Expected dimension ${i[t[r][o]]} at axis ${o} of input shaped ${JSON.stringify(s)}, but got dimension ${s[o]}`)}}function OT(n,t){const e=n,i=[];let r=0;0===n.length&&e.push(-1),r=n.length+1;for(let o=0;o<r;++o)i.push([]);const s=[];for(let o=0;o<e.length;++o){const l=qDe(t,e[o]);for(const c of l)-1===s.indexOf(c)&&(i[o].push(c),s.push(c))}return{path:e,steps:i}}function FT(n){return n.every((t,e)=>t===e)}function qDe(n,t){const e=[];for(let i=0;i<n.length;++i)(0===n[i].length||-1!==n[i].indexOf(t)||-1===t)&&e.push(i);return e}function PT(n,t,e=0){let i=[];if("number"==typeof t)S(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),i=new Array(t).fill(n.shape[e]/t);else{S(t.reduce((o,a)=>(-1===a&&(o+=1),o),0)<=1,()=>"There should be only one negative value in split array.");const s=t.indexOf(-1);if(-1!==s){const o=t.reduce((a,l)=>l>0?a+l:a);t[s]=n.shape[e]-o}S(n.shape[e]===t.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),i=t}return i}function Pj(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function Lj(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function $j(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function Vj(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function Bj(n,t){return`size ${n} must be non-negative, not ${t}`}function zj(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Uj(n,t){return`Input to reshape is a SparseTensor with ${K(n)}\n  dense values, but the requested shape requires a multiple of ${K(t)}. inputShape=${n} outputShape= ${t}`}function Hj(n,t){return`Input to reshape is a tensor with ${K(n)} dense values, but the requested shape has ${K(t)}. inputShape=${n} outputShape=${t}`}function LT(){return"segment ids must be >= 0"}function jj(){return"segment ids are not increasing"}function Wj(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Gj(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function qj(n,t){let i,e=!1;for(n<=bT?(i=n,e=!0):i=iI(n,Math.floor(Math.sqrt(n)));!e;)i>t||i===n?e=!0:i=iI(n,i+1);return i}function Yj(n,t,e){const i=[],r=n.length;for(let s=0;s<r;s++)i.push(s!==t?n[s]:e);return i}function $T(n,t,e,i){const r=t.shape.length,s=n.shape.length;if(0!==i&&(i<-r||i>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${i}`);if(i<0&&(i+=r),i>s)throw new Error(`batchDims (${i}) must be less than rank(x) (\n    ${s}).`);if(e<i)throw new Error(`batchDims (${i}) must be less than or equal to axis (${e}).`);for(let u=0;u<i;++u)if(n.shape[u]!==t.shape[u])throw new Error(`x.shape[${u}]: ${n.shape[u]} should be equal to indices.shape[${u}]: ${t.shape[u]}.`);const o=n.shape[e],a=[];let l=1,c=1,d=1;for(let u=0;u<i;++u)a.push(n.shape[u]),l*=n.shape[u];for(let u=i;u<e;u++)a.push(n.shape[u]),c*=n.shape[u];for(let u=i;u<r;u++)a.push(t.shape[u]);for(let u=e+1;u<s;u++)a.push(n.shape[u]),d*=n.shape[u];return{batchSize:l,sliceSize:d,outerSize:c,dimSize:o,outputShape:a}}function dd(n){try{return n.map(t=>Rl(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Kj(n){return n.map(t=>Nl(t))}function Xj(n,t){const e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);const i=vt(n,"int32"),r=vt([e.length,n.length],"int32");for(let s=0;s<e.length;s++){const o=i.indexToLoc(e[s]);r.values.set(o,s*n.length)}return r.toTensor()}!function Txe(){for(const n of Ixe)ce(n)}();const Zj={kernelName:pv,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(n,ug(be(e,"float32"),-1))}}},YDe={kernelName:Qf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const i=dn(be(e,"float32")),r=fr(Me(Ke(1),i));return On($e(n,r))}}}},KDe={kernelName:Jf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const i=fr(Me(dn(be(e,"float32")),1));return $e(n,i)}}}},XDe={kernelName:Ju,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t,r=Je(e.shape,i.shape);return{a:()=>{let a=n;const l=hi(e.shape,r);return l.length>0&&(a=Ne(a,l)),B(a,e.shape)},b:()=>{let a=n;const l=hi(i.shape,r);return l.length>0&&(a=Ne(a,l)),B(a,i.shape)}}}},ZDe={kernelName:lI,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((i,r)=>{e[r]=()=>n.clone()}),e}},QDe={kernelName:fv,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Nt(e)}}},JDe={kernelName:mv,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Nt(e)}}},eSe={kernelName:em,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,fr(Me(Ke(1),dn(be(e,"float32")))))}}},tSe={kernelName:tm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const i=fr(ue(Ke(1),dn(be(e,"float32"))));return $e(n,i)}}}},nSe={kernelName:rm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t,r=Je(e.shape,i.shape);return{a:()=>{const a=ue(dn(e),dn(i));let l=N(n,$e(i,a));const c=hi(e.shape,r);return c.length>0&&(l=Ne(l,c)),B(l,e.shape)},b:()=>{const a=ue(dn(e),dn(i));let l=On(N(n,$e(e,a)));const c=hi(i.shape,r);return c.length>0&&(l=Ne(l,c)),B(l,i.shape)}}}},iSe={kernelName:nm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,ue(dn(be(e,"float32")),1))}}},rSe={kernelName:im,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,Me(Ke(1),dn(be(e,"float32"))))}}},oSe=P({avgPool3dGrad_:function sSe(n,t,e,i,r,s){const o=E(n,"dy","avgPool3dGrad"),a=E(t,"input","avgPool3dGrad");let l=o,c=a,d=!1;4===a.rank&&(d=!0,l=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=B(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),S(5===c.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),mr("avgPool3dGrad",r,s);const p=O.runKernel(hI,{dy:l,input:c},{filterSize:e,strides:i,pad:r,dimRoundingMode:s});return d?B(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),aSe={kernelName:_v,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[i]=t,{filterSize:r,strides:s,pad:o,dimRoundingMode:a}=e;return{x:()=>oSe(n,i,r,s,o,a)}}},cSe=P({avgPoolGrad_:function lSe(n,t,e,i,r){const s=E(n,"dy","avgPoolGrad"),o=E(t,"input","avgPoolGrad");S(o.rank===s.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`);let a=o,l=s,c=!1;3===o.rank&&(c=!0,a=B(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=B(s,[1,s.shape[0],s.shape[1],s.shape[2]])),S(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),S(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=O.runKernel(uI,{dy:l,input:a},{filterSize:e,strides:i,pad:r});return c?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),dSe={kernelName:gv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[i]=t,{filterSize:r,strides:s,pad:o}=e;return{x:()=>cSe(n,i,r,s,o)}}},uSe={kernelName:bv,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[i,r]=t,{transposeA:s,transposeB:o}=e;return s||o?!s&&o?{a:()=>Ht(n,r,!1,!1),b:()=>Ht(n,i,!0,!1)}:s&&!o?{a:()=>Ht(r,n,!1,!0),b:()=>Ht(i,n,!1,!1)}:{a:()=>Ht(r,n,!0,!0),b:()=>Ht(n,i,!0,!0)}:{a:()=>Ht(n,r,!1,!0),b:()=>Ht(i,n,!0,!1)}}},VT=P({spaceToBatchND_:function hSe(n,t,e){const i=E(n,"x","spaceToBatchND");return S(i.rank>=1+t.length,()=>`input rank ${i.rank} should be > than [blockShape] ${t.length}`),S(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),S(i.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+e[l-1][0]+e[l-1][1])%t[l-1]==0:o,!0),()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),O.runKernel(ax,{x:i},{blockShape:t,paddings:e})}}),pSe={kernelName:yv,gradFunc:(n,t,e)=>{const{blockShape:i,crops:r}=e;return{x:()=>VT(n,i,r)}}},fSe={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const r=e.inputShape,s=e.shape,o=Array.from(s);for(let l=r.length-1;l>=0;l--)if(r[l]===s[l])o[l]=1;else if(1!==r[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Ne(n,a,!0)}}},mSe={kernelName:sm,gradFunc:n=>({x:()=>n.clone()})},gSe={kernelName:om,gradFunc:n=>({x:()=>Nt(n)})},_Se={kernelName:am,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[i]=t,{clipValueMin:r,clipValueMax:s}=e;return{x:()=>Yr(ja(od(i,r),ph(i,s)),n,Nt(n))}}},bSe={kernelName:vv,inputsToSave:["x"],gradFunc:Zj.gradFunc},ySe={kernelName:xv,saveAllInputs:!0,gradFunc:(n,t,e)=>{const i=t.map(l=>l.shape),{axis:r}=e,s=yt(r,t[0].shape)[0],o=i.map(l=>l[s]);return gs(n,o,s).map(l=>()=>l)}},vSe={kernelName:wv,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[i,r]=t,{dilations:s,strides:o,pad:a,dataFormat:l}=e;return S($l(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>j1(i.shape,n,r,o,a,l),filter:()=>cT(i,n,r.shape,o,a,l)}}},xSe={kernelName:Cv,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[i,r]=t,{strides:s,pad:o,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>sd(n,r,s,o,a,1,l),filter:()=>cT(n,i,r.shape,s,o,a,l)}}},CSe=P({conv3DBackpropFilter_:function wSe(n,t,e,i,r){let s=n;4===n.rank&&(s=B(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;return 4===o.rank&&(o=B(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),S(5===s.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),S(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),S(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),S(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),S(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`),O.runKernel(gI,{x:s,dy:o},{strides:i,pad:r,filterShape:e})}}),DSe={kernelName:Dv,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:i,strides:r,pad:s}=e;S($l(i),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const[o,a]=t;return{x:()=>X4(o.shape,n,a,r,s),filter:()=>CSe(o,n,a.shape,r,s)}}},Qj=P({sin_:function SSe(n){const e={x:E(n,"x","sin","float32")};return O.runKernel(Fm,e)}}),kSe={kernelName:lm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(On(Qj(be(e,"float32"))),n)}}},Jj=P({sinh_:function ESe(n){const e={x:E(n,"x","sinh")};return O.runKernel(Pm,e)}}),ISe={kernelName:cm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(Jj(be(e,"float32")),n)}}},eW=P({cumsum_:function TSe(n,t=0,e=!1,i=!1){const s={x:E(n,"x","cumsum")};return O.runKernel(Sv,s,{axis:t,exclusive:e,reverse:i})}}),ASe={kernelName:Sv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[i]=t,{axis:r,exclusive:s,reverse:o}=e;return{x:()=>{const a=Rn([r],i.rank);let l=eW(n,r,s,!o);return null!=a&&(l=Mt(l,a)),l}}}},MSe={kernelName:kv,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:i,strides:r,pad:s,dimRoundingMode:o}=e,a=i??[1,1];S($l(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=t;return S(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),S(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),S(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),S(Ui(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),mr("depthwiseConv2d",s,o),{x:()=>cj(l.shape,n,c,r,s,a,o),filter:()=>lj(l,n,c.shape,r,s,a,o)}}},NSe={kernelName:Ev,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[i,r]=t,s={x:i,filter:r,dy:n},o={x:i,filter:r,dy:n};return{x:()=>O.runKernel(DI,s,e),filter:()=>O.runKernel(SI,o,e)}}},RSe={kernelName:um,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,i={dy:n,y:e};return{x:()=>O.runKernel(kI,i)}}},OSe={kernelName:hm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,i=N(js(On(dn(e))),2/Math.sqrt(Math.PI));return{x:()=>N(n,i)}}},FSe={kernelName:pm,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(n,e)}}},PSe={kernelName:Tv,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>B(n,e.shape)}}},LSe={kernelName:fm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(n,js(e))}}},$Se={kernelName:mm,gradFunc:n=>({x:()=>Nt(n)})},VSe={kernelName:gm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t,r=Je(e.shape,i.shape);return{a:()=>{const a=$e(n,be(i,"float32")),l=hi(e.shape,r);return l.length>0?B(Ne(a,l),e.shape):a},b:()=>{let a=N(n,be(e,"float32"));const l=hi(i.shape,r);l.length>0&&(a=B(Ne(a,l),i.shape));const c=dn(i);return On($e(a,be(c,"float32")))}}}},tW=P({rsqrt_:function BSe(n){const e={x:E(n,"x","rsqrt","float32")};return O.runKernel(Rm,e)}}),zSe={kernelName:Av,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:i}=e,[r,s,o,a]=t,l=a??Ke(1),c=hi(s.shape,r.shape),d=[];if(1===s.rank){for(let v=0;v<r.shape.length-1;++v)d.push(r.shape[v]);d.push(1)}const u=Me(r,s),h=N(n,l),p=tW(ue(o,Ke(i))),f=N(N(N(p,p),p),Ke(-.5));return{x:()=>B(N(N(n,1===s.rank?vo(B(p,[1,1,1,s.shape[0]]),d):p),l),r.shape),mean:()=>{let v=N(N(p,Ke(-1)),h);return 1===s.rank&&(v=Ne(v,c)),B(v,s.shape)},variance:()=>{let v=N(N(f,u),h);return 1===s.rank&&(v=Ne(v,c)),B(v,s.shape)},scale:()=>{const v=N(u,p);let x=N(n,v);return 1===s.rank&&(x=Ne(x,c)),B(x,s.shape)},offset:()=>{let v=n;return 1===s.rank&&(v=Ne(v,c)),B(v,s.shape)}}}},nW=P({unsortedSegmentSum_:function USe(n,t,e){const i=E(n,"x","unsortedSegmentSum"),r=E(t,"segmentIds","unsortedSegmentSum","int32");return S(Xu(e),()=>"numSegments must be of dtype int"),O.runKernel(ux,{x:i,segmentIds:r},{numSegments:e})}}),HSe={kernelName:Mv,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[i,r]=t,{axis:s}=e,o=yt(s,i.shape)[0];return{x:()=>{const l=i.shape,c=r.size,d=l.slice(0,o),u=d.length,h=l.slice(s,l.length).slice(1),p=h.length,f=iW(0,u),m=iW(u+1,u+1+p),g=rW([d,[c],h]),_=B(n,g),b=B(r,[c]),y=rW([[u],f,m]),v=Mt(_,y);let x=nW(v,b,i.shape[o]);const w=Vl(y);return x=Mt(x,w),x},indices:()=>r}}};function iW(n,t){const e=[];for(let i=n;i<t;++i)e.push(i);return e}function rW(n){const t=[];for(let e=0;e<n.length;++e)for(let i=0;i<n[e].length;++i)t.push(n[e][i]);return t}const jSe={kernelName:_m,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t;return{a:()=>Nt(e),b:()=>Nt(i)}}},WSe={kernelName:bm,gradFunc:n=>({x:()=>be(n,"float32")})},GSe={kernelName:ym,gradFunc:n=>({x:()=>Nt(n)})},qSe={kernelName:vm,gradFunc:n=>({x:()=>Nt(n)})},YSe={kernelName:xm,gradFunc:n=>({x:()=>Nt(n)})},KSe={kernelName:Rv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[i]=t,{alpha:r}=e,s=ms(i,0);return{x:()=>Yr(s,n,N(n,r))}}},XSe={kernelName:Cm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,ue(e,1))}}},ZSe={kernelName:wm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,be(e,"float32"))}}},QSe={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[i]=t,{axis:r}=e;return{logits:()=>{const o=js(i);return Me(n,N(Ne(n,r,!0),o))}}}},eke=P({localResponseNormalizationBackprop_:function JSe(n,t,e,i=5,r=1,s=1,o=.5){return O.runKernel(NI,{x:n,y:t,dy:e},{depthRadius:i,bias:r,alpha:s,beta:o})}}),tke={kernelName:Vv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[i,r]=t,{depthRadius:s,bias:o,alpha:a,beta:l}=e;return{x:()=>eke(i,r,n,s,o,a,l)}}};function sW(n,t,e,i){return t.rank<e.rank&&(t=B(t,Kn(t.shape,i))),n.rank<e.rank&&(n=B(n,Kn(n.shape,i))),{x:()=>N(n,be(ea(e,t),n.dtype))}}const oW={kernelName:Bv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const i=e,{reductionIndices:r}=i,s=t[0],l=sW(n,t[1],s,yt(r,s.shape));return{x:()=>l.x()}}},aW=P({less_:function nke(n,t){let e=E(n,"a","less","string_or_numeric"),i=E(t,"b","less","string_or_numeric");return[e,i]=Vn(e,i),Je(e.shape,i.shape),O.runKernel(Ov,{a:e,b:i})}}),ike={kernelName:Dm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t;return{a:()=>N(n,be(od(e,i),"float32")),b:()=>N(n,be(aW(e,i),"float32"))}}},ske=P({maxPool3dGrad_:function rke(n,t,e,i,r,s,o){const a=E(n,"dy","maxPool3dGrad"),l=E(t,"input","maxPool3dGrad"),c=E(e,"output","maxPool3dGrad");let d=a,u=l,h=c,p=!1;4===l.rank&&(p=!0,d=B(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=B(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=B(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),S(5===d.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),S(5===u.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),S(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),mr("maxPool3dGrad",s,o);const g=O.runKernel(OI,{dy:d,input:u,output:h},{filterSize:i,strides:r,pad:s,dimRoundingMode:o});return p?B(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),oke={kernelName:Uv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[i,r]=t,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=e;return{x:()=>ske(n,i,r,s,o,a,l)}}},lke=P({maxPoolGrad_:function ake(n,t,e,i,r,s,o){const a=E(n,"dy","maxPoolGrad"),l=E(t,"input","maxPoolGrad"),c=E(e,"output","maxPoolGrad");return S(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),S(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),S(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),mr("maxPoolGrad",s,o),O.runKernel(RI,{dy:a,input:l,output:c},{filterSize:i,strides:r,pad:s,dimRoundingMode:o})}}),cke={kernelName:zv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[i,r]=t,{filterSize:s,strides:o,pad:a}=e;return{x:()=>lke(n,i,r,s,o,a)}}},dke={kernelName:Hv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[i]=t,{axis:r}=e,s=yt(r,i.shape),l=K(Ai(i.shape,s)[1]);return{x:()=>{const d=i.shape.slice();s.forEach(p=>{d[p]=1});const u=B(n,d);return $e(N(u,Bl(i.shape,"float32")),l)}}}},uke={kernelName:jv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const i=e,{axis:r}=i,[s,o]=t,l=sW(n,o,s,yt(r,s.shape));return{x:()=>l.x()}}},hke={kernelName:Sm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t;return{a:()=>N(n,be(ph(e,i),"float32")),b:()=>N(n,be(ms(e,i),"float32"))}}},pke={kernelName:Wv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const i=t[0],{paddings:r}=e,s=r.map(o=>o[0]);return{x:()=>tn(n,s,i.shape)}}},fke={kernelName:km,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t,r=Je(e.shape,i.shape);return{a:()=>{const a=hi(e.shape,r);return a.length>0?B(Ne(n,a),e.shape):n},b:()=>{const a=N(n,On(Rx($e(e,i)))),l=hi(i.shape,r);return l.length>0?B(Ne(a,l),i.shape):a}}}},mke={kernelName:Em,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t,r=Je(e.shape,i.shape);return{a:()=>{const a=N(n,be(i,"float32")),l=hi(e.shape,r);return l.length>0?B(Ne(a,l),e.shape):a},b:()=>{const a=N(n,be(e,"float32")),l=hi(i.shape,r);return l.length>0?B(Ne(a,l),i.shape):a}}}},gke={kernelName:Gv,gradFunc:n=>({x:()=>On(n)})},_ke={kernelName:Kv,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>Mi(e.shape,"float32")}}},bke={kernelName:Yv,gradFunc:n=>({x:()=>Nt(n)})},yke={kernelName:Xv,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:i}=e;return ld(n,i).map(s=>()=>s)}},lW={kernelName:Zv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const i=t[0],{paddings:r}=e,s=r.map(o=>o[0]);return{x:()=>tn(n,s,i.shape)}}},vke={kernelName:Im,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,i,r]=t,s=e,o=i,a=Je(s.shape,o.shape);return{a:()=>{const d=be(o,"float32");let u=N(n,N(d,lh(s,Me(d,Ke(1)))));const h=hi(s.shape,a);return h.length>0&&(u=Ne(u,h)),B(u,s.shape)},b:()=>{const d=ms(s,0),u=Yr(d,Ws(s),Nt(s));let h=N(n,N(r,u));const p=hi(o.shape,a);return p.length>0&&(h=Ne(h,p)),B(h,o.shape)}}}},xke={kernelName:Qv,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,i]=t,r=ms(e,0);return{x:()=>Yr(r,n,N(n,i)),alpha:()=>{let s=Yr(r,Nt(n),N(n,e));const o=hi(i.shape,n.shape);return o.length>0&&(s=Ne(s,o)),B(s,i.shape)}}}},BT=P({cumprod_:function wke(n,t=0,e=!1,i=!1){const s={x:E(n,"x","cumprod")};return O.runKernel(bI,s,{axis:t,exclusive:e,reverse:i})}});const Ske={kernelName:Jv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[i]=t,{axis:r}=e;let s=[];return s=null==r?i.shape.map((o,a)=>a):"number"==typeof r?[r]:r,{x:()=>function Dke(n,t,e){const i=n.shape.length,r=i-e.length,s=Rn(e,i);let o=n;null!=s&&(o=Mt(n,s));const a=o.shape.slice(),c=a.splice(i-e.length,e.length).reduce((h,p)=>h*p,1);a.push(c);let u=function Cke(n,t,e){const i=n.shape.slice();i[e]=1;const r=B(t,i),s=BT(n,e,!0,!1),o=BT(n,e,!0,!0),a=N(s,o);return N(r,a)}(o.reshape(a),t,r);if(u=u.reshape(o.shape),null!=s){const h=Vl(s);u=Mt(u,h)}return u}(i,n,s)}}},kke={kernelName:dm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t,r=Je(e.shape,i.shape);return{a:()=>{const a=$e(n,be(i,"float32")),l=hi(e.shape,r);return l.length>0?B(Ne(a,l),e.shape):a},b:()=>{let a=N(n,be(e,"float32"));const l=hi(i.shape,r);l.length>0&&(a=B(Ne(a,l),i.shape));const c=dn(i);return On($e(a,be(c,"float32")))}}}},Eke={kernelName:Tm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,On(dn(e)))}}},Ike={kernelName:Mm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,i=N(ph(e,6),ug(e));return{x:()=>N(n,be(i,"float32"))}}},Tke={kernelName:Am,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(n,be(ug(e),"float32"))}}},Ake={kernelName:ex,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>B(n,e.shape)}}},Mke={kernelName:nx,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[i]=t,r={dy:n,images:i};return{images:()=>O.runKernel(zI,r,e)}}},Nke={kernelName:tx,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[i]=t,r={dy:n,images:i};return{images:()=>O.runKernel(BI,r,e)}}},Rke={kernelName:ix,gradFunc:(n,t,e)=>{const{dims:i}=e,r=yt(i,n.shape);return{x:()=>ad(n,r)}}},Oke={kernelName:Nm,gradFunc:n=>({x:()=>Nt(n)})},Fke={kernelName:Rm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>On($e(n,N(lh(e,1.5),2)))}}},zT=P({logicalNot_:function Pke(n){const e={x:E(n,"x","logicalNot","bool")};return O.runKernel(Lv,e)}}),Lke={kernelName:rx,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>be(Nt(e),"float32"),t:()=>N(n,be(e,n.dtype)),e:()=>N(n,be(zT(e),n.dtype))}}},$ke={kernelName:Om,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const i=ms(e,Ke(0)),r=Ke(Gx),s=Ke(qx),o=N(n,s),a=N(N(n,r),js(be(e,"float32")));return Yr(i,o,a)}}}},Vke={kernelName:$m,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(n,N(e,Me(Ke(1),e)))}}},Bke={kernelName:Lm,gradFunc:n=>({x:()=>Nt(n)})},UT=P({cos_:function zke(n){const e={x:E(n,"x","cos","float32")};return O.runKernel(lm,e)}}),Uke={kernelName:Fm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(UT(be(e,"float32")),n)}}},cW=P({cosh_:function Hke(n){const e={x:E(n,"x","cosh","float32")};return O.runKernel(cm,e)}}),jke={kernelName:Pm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(cW(be(e,"float32")),n)}}},Wke={kernelName:sx,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[i]=t,{begin:r,size:s}=e,o=i.shape,[a,l]=Tx(i,r,s),c=[];for(let d=0;d<n.rank;d++)c.push([a[d],o[d]-a[d]-l[d]]);return{x:()=>Z1(n,c)}}},Gke={kernelName:cx,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[i]=t,{dim:r}=e,o=N(n,i);return{logits:()=>Me(o,N(Ne(o,[r],!0),i))}}},qke={kernelName:Vm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(n,uh(e))}}},HT=P({batchToSpaceND_:function Yke(n,t,e){const i=E(n,"x","batchToSpaceND"),r=t.reduce((a,l)=>a*l);return S(i.rank>=1+t.length,()=>`input rank is ${i.rank} but should be > than blockShape.length ${t.length}`),S(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),S(i.shape[0]%r==0,()=>`input tensor batch is ${i.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`),O.runKernel(yv,{x:i},{blockShape:t,crops:e})}}),dW={kernelName:ax,gradFunc:(n,t,e)=>{const{blockShape:i,paddings:r}=e;return{x:()=>HT(n,i,r)}}},uW={kernelName:lx,gradFunc:(n,t,e)=>{const{axis:i}=e;return{x:()=>Qi(n,i)}}},Kke={kernelName:Bm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,N(fr(be(e,"float32")),2))}}},Xke={kernelName:GI,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(n,N(be(e,"float32"),2))}}},Zke={kernelName:zm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t,r=Ke(2);return{a:()=>N(n,N(r,Me(e,i))),b:()=>N(n,N(r,Me(i,e)))}}},Qke={kernelName:Gm,gradFunc:n=>({x:()=>Nt(n)})},Jke={kernelName:Um,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,i]=t,r=Je(e.shape,i.shape);return{a:()=>{let a=n;const l=hi(e.shape,r);return l.length>0&&(a=Ne(a,l)),B(a,e.shape)},b:()=>{let a=n;const l=hi(i.shape,r);return l.length>0&&(a=Ne(a,l)),B(On(a),i.shape)}}}},eEe={kernelName:ox,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[i]=t,r=i.shape.slice(),{axis:s}=e;yt(s,i.shape).forEach(c=>{r[c]=1});const a=B(n,r),l=N(a,Bl(i.shape,"float32"));return{x:()=>l}}},tEe={kernelName:Hm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,dn(UT(e)))}}},nEe={kernelName:jm,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>N(Me(Ke(1),dn(e)),n)}}},iEe={kernelName:Wm,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[i]=t,{reps:r}=e;return{x:()=>{let o=Nt(i);if(1===i.rank)for(let a=0;a<r[0];++a)o=ue(o,tn(n,[a*i.shape[0]],[i.shape[0]]));else if(2===i.rank)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)o=ue(o,tn(n,[a*i.shape[0],l*i.shape[1]],[i.shape[0],i.shape[1]]));else if(3===i.rank)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)o=ue(o,tn(n,[a*i.shape[0],l*i.shape[1],c*i.shape[2]],[i.shape[0],i.shape[1],i.shape[2]]));else{if(4!==i.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${i.rank} tensors yet.`);for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)for(let d=0;d<r[3];++d)o=ue(o,tn(n,[a*i.shape[0],l*i.shape[1],c*i.shape[2],d*i.shape[3]],[i.shape[0],i.shape[1],i.shape[2],i.shape[3]]))}return o}}}},rEe={kernelName:eh,gradFunc:(n,t,e)=>{const i=e,{perm:r}=i,s=Vl(r);return{x:()=>Mt(n,s)}}},sEe={kernelName:dx,gradFunc:(n,t,e)=>{const i=e,{axis:r}=i;return{value:()=>zl(n,r)}}},oEe={kernelName:ux,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function aEe(n,t){const e=Pl(t,Nt(t)),i=W1(n,e);let r=od(t,Ke(0,"int32"));const s=i.rank-r.rank;for(let a=0;a<s;++a)r=qr(r,a+1);r=ja(r,Bl(i.shape,"bool"));const o=Nt(i);return Yr(r,i,o)}(n,e)}}},lEe={kernelName:hx,gradFunc:n=>({x:()=>Nt(n)})},cEe=[Zj,YDe,KDe,XDe,ZDe,QDe,JDe,eSe,tSe,nSe,iSe,rSe,aSe,dSe,uSe,pSe,fSe,mSe,gSe,_Se,bSe,ySe,xSe,vSe,DSe,kSe,ISe,ASe,MSe,NSe,kke,RSe,OSe,FSe,PSe,LSe,VSe,$Se,zSe,HSe,jSe,WSe,GSe,qSe,YSe,KSe,XSe,ZSe,QSe,tke,oW,oW,ike,oke,cke,dke,uke,hke,pke,fke,mke,gke,_ke,bke,yke,lW,lW,vke,xke,Ske,Eke,Ike,Tke,Ake,Mke,Nke,Rke,Oke,Fke,Lke,$ke,Vke,Bke,Uke,jke,Wke,Gke,qke,dW,dW,uW,uW,Kke,Zke,Xke,Qke,Jke,eEe,tEe,nEe,iEe,rEe,sEe,oEe,lEe];for(const n of cEe)mve(n);X().prototype.abs=function(){return this.throwIfDisposed(),Ii(this)};const uEe=P({acos_:function dEe(n){const e={x:E(n,"x","acos")};return O.runKernel(Qf,e)}});X().prototype.acos=function(){return this.throwIfDisposed(),uEe(this)};const pEe=P({acosh_:function hEe(n){const e={x:E(n,"x","acosh")};return O.runKernel(Jf,e)}});X().prototype.acosh=function(){return this.throwIfDisposed(),pEe(this)},X().prototype.add=function(n){return this.throwIfDisposed(),ue(this,n)},X().prototype.all=function(n,t){return this.throwIfDisposed(),q4(this,n,t)},X().prototype.any=function(n,t){return this.throwIfDisposed(),B1(this,n,t)},X().prototype.argMax=function(n){return this.throwIfDisposed(),tg(this,n)};const mEe=P({argMin_:function fEe(n,t=0){const i={x:E(n,"x","argMin")};return O.runKernel(mv,i,{axis:t})}});X().prototype.argMin=function(n){return this.throwIfDisposed(),mEe(this,n)},X().prototype.asScalar=function(){return this.throwIfDisposed(),S(1===this.size,()=>"The array must have only 1 element."),B(this,[])},X().prototype.asType=function(n){return this.throwIfDisposed(),be(this,n)},X().prototype.as1D=function(){return this.throwIfDisposed(),B(this,[this.size])},X().prototype.as2D=function(n,t){return this.throwIfDisposed(),B(this,[n,t])},X().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),B(this,[n,t,e])},X().prototype.as4D=function(n,t,e,i){return this.throwIfDisposed(),B(this,[n,t,e,i])},X().prototype.as5D=function(n,t,e,i,r){return this.throwIfDisposed(),B(this,[n,t,e,i,r])};const _Ee=P({asin_:function gEe(n){const e={x:E(n,"x","asin")};return O.runKernel(em,e)}});X().prototype.asin=function(){return this.throwIfDisposed(),_Ee(this)};const yEe=P({asinh_:function bEe(n){const e={x:E(n,"x","asinh")};return O.runKernel(tm,e)}});X().prototype.asinh=function(){return this.throwIfDisposed(),yEe(this)};const xEe=P({atan_:function vEe(n){const e={x:E(n,"x","atan")};return O.runKernel(nm,e)}});X().prototype.atan=function(){return this.throwIfDisposed(),xEe(this)};const CEe=P({atan2_:function wEe(n,t){let e=E(n,"a","atan2"),i=E(t,"b","atan2");return[e,i]=Vn(e,i),O.runKernel(rm,{a:e,b:i})}});X().prototype.atan2=function(n){return this.throwIfDisposed(),CEe(this,n)};const SEe=P({atanh_:function DEe(n){const e={x:E(n,"x","atanh")};return O.runKernel(im,e)}});X().prototype.atanh=function(){return this.throwIfDisposed(),SEe(this)},X().prototype.avgPool=function(n,t,e,i){return this.throwIfDisposed(),H1(this,n,t,e,i)},X().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),HT(this,n,t)},X().prototype.batchNorm=function(n,t,e,i,r){return this.throwIfDisposed(),Ax(this,n,t,e,i,r)},X().prototype.broadcastTo=function(n){return this.throwIfDisposed(),sg(this,n)},X().prototype.cast=function(n){return this.throwIfDisposed(),be(this,n)};const EEe=P({ceil_:function kEe(n){const e={x:E(n,"x","ceil","float32")};return O.runKernel(om,e)}});X().prototype.ceil=function(){return this.throwIfDisposed(),EEe(this)},X().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),fs(this,n,t)},X().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof qn&&(n=[n]),Qi([this,...n],t)},X().prototype.conv1d=function(n,t,e,i,r,s){return this.throwIfDisposed(),Y4(this,n,t,e,i,r,s)},X().prototype.conv2dTranspose=function(n,t,e,i,r){return this.throwIfDisposed(),K4(this,n,t,e,i,r)},X().prototype.conv2d=function(n,t,e,i,r,s){return this.throwIfDisposed(),sd(this,n,t,e,i,r,s)},X().prototype.cos=function(){return this.throwIfDisposed(),UT(this)},X().prototype.cosh=function(){return this.throwIfDisposed(),cW(this)},X().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),BT(this,n,t,e)},X().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),eW(this,n,t,e)};const TEe=P({depthToSpace_:function IEe(n,t,e="NHWC"){const i=E(n,"x","depthToSpace","float32"),r="NHWC"===e?i.shape[1]:i.shape[2],s="NHWC"===e?i.shape[2]:i.shape[3],o="NHWC"===e?i.shape[3]:i.shape[1];return S(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),S(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${i.shape}`),S(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${i.shape}`),S(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${i.shape}`),O.runKernel(xI,{x:i},{blockSize:t,dataFormat:e})}});X().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),TEe(this,n,t)},X().prototype.depthwiseConv2d=function(n,t,e,i,r,s){return this.throwIfDisposed(),Mx(this,n,t,e,i,r,s)};const MEe=P({dilation2d_:function AEe(n,t,e,i,r=[1,1],s="NHWC"){const o=E(n,"x","dilation2d"),a=E(t,"filter","dilation2d");S(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),S(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),S("NHWC"===s,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=o,c=!1;3===o.rank&&(l=B(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),S(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const h=O.runKernel(Ev,{x:l,filter:a},{strides:e,pad:i,dilations:r});return c?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});X().prototype.dilation2d=function(n,t,e,i,r){return this.throwIfDisposed(),MEe(this,n,t,e,i,r)};const REe=P({divNoNan_:function NEe(n,t){let e=E(n,"a","div"),i=E(t,"b","div");[e,i]=Vn(e,i);const r=$e(e,i),s=Nt(r),o=ea(i,s);return Yr(o,s,r)}});X().prototype.divNoNan=function(n){return this.throwIfDisposed(),REe(this,n)},X().prototype.div=function(n){return this.throwIfDisposed(),$e(this,n)};const FEe=P({dot_:function OEe(n,t){const e=E(n,"t1","dot"),i=E(t,"t2","dot");S(!(1!==e.rank&&2!==e.rank||1!==i.rank&&2!==i.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${i.rank}.`);const r=1===e.rank?e.size:e.shape[1],s=1===i.rank?i.size:i.shape[0];if(S(r===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`),1===e.rank&&1===i.rank){const o=B(e,[1,-1]),a=B(i,[-1,1]),l=Ht(o,a);return B(l,[])}if(1===e.rank&&2===i.rank){const o=B(e,[1,-1]),a=B(i,[i.shape[0],i.shape[1]]),l=Ht(o,a);return B(l,[l.size])}if(2===e.rank&&1===i.rank){const o=B(i,[-1,1]),a=Ht(e,o);return B(a,[a.size])}{const o=B(i,[i.shape[0],i.shape[1]]);return Ht(e,o)}}});X().prototype.dot=function(n){return this.throwIfDisposed(),FEe(this,n)},X().prototype.elu=function(){return this.throwIfDisposed(),Nx(this)},X().prototype.equal=function(n){return this.throwIfDisposed(),ea(this,n)};const LEe=P({erf_:function PEe(n){let t=E(n,"x","erf");return S("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=be(t,"float32")),O.runKernel(hm,{x:t})}});X().prototype.erf=function(){return this.throwIfDisposed(),LEe(this)};const VEe=P({euclideanNorm_:function $Ee(n,t=null,e=!1){return jx(n,"euclidean",t,e)}});X().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),VEe(this,n,t)},X().prototype.exp=function(){return this.throwIfDisposed(),js(this)},X().prototype.expandDims=function(n){return this.throwIfDisposed(),qr(this,n)};const zEe=P({expm1_:function BEe(n){const e={x:E(n,"x","expm1")};return O.runKernel(fm,e)}});X().prototype.expm1=function(){return this.throwIfDisposed(),zEe(this)},X().prototype.fft=function(){return this.throwIfDisposed(),aT(this)},X().prototype.flatten=function(){return this.throwIfDisposed(),B(this,[this.size])},X().prototype.floor=function(){return this.throwIfDisposed(),Rx(this)},X().prototype.floorDiv=function(n){return this.throwIfDisposed(),w4(this,n)},X().prototype.gather=function(n,t){return this.throwIfDisposed(),W1(this,n,t)},X().prototype.greaterEqual=function(n){return this.throwIfDisposed(),od(this,n)},X().prototype.greater=function(n){return this.throwIfDisposed(),ms(this,n)},X().prototype.ifft=function(){return this.throwIfDisposed(),Vx(this)},X().prototype.irfft=function(){return this.throwIfDisposed(),oj(this)};const HEe=P({isFinite_:function UEe(n){const e={x:E(n,"x","isFinite")};return O.runKernel(ym,e)}});X().prototype.isFinite=function(){return this.throwIfDisposed(),HEe(this)};const WEe=P({isInf_:function jEe(n){const e={x:E(n,"x","isInf")};return O.runKernel(vm,e)}});X().prototype.isInf=function(){return this.throwIfDisposed(),WEe(this)};const qEe=P({isNaN_:function GEe(n){const e={x:E(n,"x","isNaN")};return O.runKernel(xm,e)}});X().prototype.isNaN=function(){return this.throwIfDisposed(),qEe(this)},X().prototype.leakyRelu=function(n){return this.throwIfDisposed(),G1(this,n)},X().prototype.lessEqual=function(n){return this.throwIfDisposed(),ph(this,n)},X().prototype.less=function(n){return this.throwIfDisposed(),aW(this,n)};const KEe=P({localResponseNormalization_:function YEe(n,t=5,e=1,i=1,r=.5){const s=E(n,"x","localResponseNormalization");S(4===s.rank||3===s.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`),S(Xu(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=s,a=!1;3===s.rank&&(a=!0,o=B(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const d=O.runKernel(Vv,{x:o},{depthRadius:t,bias:e,alpha:i,beta:r});return a?B(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});X().prototype.localResponseNormalization=function(n,t,e,i){return this.throwIfDisposed(),KEe(this,n,t,e,i)};const ZEe=P({logSigmoid_:function XEe(n){const t=E(n,"x","logSigmoid");return za(i=>({value:On(lg(On(i))),gradFunc:o=>N(o,uh(On(i)))}))(t)}});X().prototype.logSigmoid=function(){return this.throwIfDisposed(),ZEe(this)},X().prototype.logSoftmax=function(n){return this.throwIfDisposed(),J4(this,n)},X().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),xj(this,n,t)},X().prototype.log=function(){return this.throwIfDisposed(),Ws(this)},X().prototype.log1p=function(){return this.throwIfDisposed(),q1(this)},X().prototype.logicalAnd=function(n){return this.throwIfDisposed(),ja(this,n)},X().prototype.logicalNot=function(){return this.throwIfDisposed(),zT(this)};const hW=P({logicalOr_:function QEe(n,t){const e=E(n,"a","logicalOr","bool"),i=E(t,"b","logicalOr","bool");return Je(e.shape,i.shape),O.runKernel($v,{a:e,b:i})}});X().prototype.logicalOr=function(n){return this.throwIfDisposed(),hW(this,n)};const eIe=P({logicalXor_:function JEe(n,t){const e=E(n,"a","logicalXor","bool"),i=E(t,"b","logicalXor","bool");return Je(e.shape,i.shape),ja(hW(n,t),zT(ja(n,t)))}});X().prototype.logicalXor=function(n){return this.throwIfDisposed(),eIe(this,n)},X().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),Ht(this,n,t,e)},X().prototype.maxPool=function(n,t,e,i){return this.throwIfDisposed(),Y1(this,n,t,e,i)},X().prototype.max=function(n,t){return this.throwIfDisposed(),xo(this,n,t)},X().prototype.maximum=function(n){return this.throwIfDisposed(),Pl(this,n)},X().prototype.mean=function(n,t){return this.throwIfDisposed(),Yn(this,n,t)},X().prototype.min=function(n,t){return this.throwIfDisposed(),Ox(this,n,t)},X().prototype.minimum=function(n){return this.throwIfDisposed(),Fx(this,n)};const nIe=P({mirrorPad_:function tIe(n,t,e){S("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const i=E(n,"x","mirrorPad");if(0===i.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(t.length===i.rank,()=>`Padding doesn't match input. Must be ${i.rank}. Got ${t.length}.`);const r="reflect"===e?1:0;for(let a=0;a<i.rank;a++)S(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),S(t[a][0]>=0&&t[a][0]<=i.shape[a]-r&&t[a][1]>=0&&t[a][1]<=i.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${i.shape[a]-r} or less than 0 for input of shape ${i.shape}`);return O.runKernel(Wv,{x:i},{paddings:t,mode:e})}});X().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),nIe(this,n,t)};const rIe=P({mod_:function iIe(n,t){let e=E(n,"a","mod"),i=E(t,"b","mod");return[e,i]=Vn(e,i),O.runKernel(km,{a:e,b:i})}});X().prototype.mod=function(n){return this.throwIfDisposed(),rIe(this,n)},X().prototype.mul=function(n){return this.throwIfDisposed(),N(this,n)},X().prototype.neg=function(){return this.throwIfDisposed(),On(this)},X().prototype.norm=function(n,t,e){return this.throwIfDisposed(),jx(this,n,t,e)},X().prototype.notEqual=function(n){return this.throwIfDisposed(),og(this,n)},X().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),tj(this,n,t,e)},X().prototype.onesLike=function(){return this.throwIfDisposed(),Gs(this)},X().prototype.pad=function(n,t){return this.throwIfDisposed(),Z1(this,n,t)};const lIe=P({pool_:function sIe(n,t,e,i,r,s,o){null==r&&(r=[1,1]),null==s&&(s=1),0===i&&(i="valid");const a=E(n,"x","maxPool");let l=a,c=!1;3===a.rank&&(c=!0,l=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(Ui(s,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);const d=Hs(l.shape,t,s,r,i),u=[d.dilationHeight,d.dilationWidth];let h;h="same"===i?function aIe(n,t){const i=n.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),r=i.map(o=>Math.floor(o/2)),s=i.map((o,a)=>o-r[a]);return i.map((o,a)=>[r[a],s[a]])}([d.filterHeight,d.filterWidth],u):[[0,0],[0,0]];const p=1===u[0]&&1===u[1],[f,m]=function oIe(n,t,e){const i=e.map(d=>d[0]),r=e.map(d=>d[1]),s=n.concat(i,r),o=t.map((d,u)=>(d-s[u]%d)%d),a=r.map((d,u)=>d+o[u]),l=t.map((d,u)=>[i[u],a[u]]),c=t.map((d,u)=>[0,o[u]]);return[l,c]}([d.inHeight,d.inWidth],u,h),g=p?i:"valid",_=p?l:VT(l,u,f),y=("avg"===e?()=>H1(_,t,s,g,o):()=>Y1(_,t,s,g,o))(),v=p?y:HT(y,u,m);return c?B(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});X().prototype.pool=function(n,t,e,i,r,s){return this.throwIfDisposed(),lIe(this,n,t,e,i,r,s)},X().prototype.pow=function(n){return this.throwIfDisposed(),lh(this,n)},X().prototype.prelu=function(n){return this.throwIfDisposed(),Q1(this,n)};const dIe=P({prod_:function cIe(n,t=null,e=!1){let i=E(n,"x","prod");return"bool"===i.dtype&&(i=be(i,"int32")),O.runKernel(Jv,{x:i},{axis:t,keepDims:e})}});X().prototype.prod=function(n,t){return this.throwIfDisposed(),dIe(this,n,t)};const hIe=P({reciprocal_:function uIe(n){const e={x:E(n,"x","reciprocal")};return O.runKernel(Tm,e)}});X().prototype.reciprocal=function(){return this.throwIfDisposed(),hIe(this)},X().prototype.relu=function(){return this.throwIfDisposed(),Wa(this)},X().prototype.relu6=function(){return this.throwIfDisposed(),aj(this)},X().prototype.reshapeAs=function(n){return this.throwIfDisposed(),B(this,n.shape)},X().prototype.reshape=function(n){return this.throwIfDisposed(),B(this,n)},X().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),mj(this,n,t,e)},X().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),gj(this,n,t,e)},X().prototype.reverse=function(n){return this.throwIfDisposed(),ad(this,n)},X().prototype.rfft=function(){return this.throwIfDisposed(),lT(this)},X().prototype.round=function(){return this.throwIfDisposed(),_j(this)},X().prototype.rsqrt=function(){return this.throwIfDisposed(),tW(this)},X().prototype.selu=function(){return this.throwIfDisposed(),nj(this)},X().prototype.separableConv2d=function(n,t,e,i,r,s){return this.throwIfDisposed(),ij(this,n,t,e,i,r,s)},X().prototype.sigmoid=function(){return this.throwIfDisposed(),uh(this)};const fIe=P({sign_:function pIe(n){const e={x:E(n,"x","sign")};return O.runKernel(Lm,e)}});X().prototype.sign=function(){return this.throwIfDisposed(),fIe(this)},X().prototype.sin=function(){return this.throwIfDisposed(),Qj(this)},X().prototype.sinh=function(){return this.throwIfDisposed(),Jj(this)},X().prototype.slice=function(n,t){return this.throwIfDisposed(),tn(this,n,t)},X().prototype.softmax=function(n){return this.throwIfDisposed(),rT(this,n)},X().prototype.softplus=function(){return this.throwIfDisposed(),lg(this)},X().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),VT(this,n,t)},X().prototype.split=function(n,t){return this.throwIfDisposed(),gs(this,n,t)},X().prototype.sqrt=function(){return this.throwIfDisposed(),fr(this)},X().prototype.square=function(){return this.throwIfDisposed(),dn(this)},X().prototype.squaredDifference=function(n){return this.throwIfDisposed(),vj(this,n)},X().prototype.squeeze=function(n){return this.throwIfDisposed(),cg(this,n)},X().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof qn?[this,n]:[this,...n];return zl(e,t)},X().prototype.step=function(n){return this.throwIfDisposed(),ug(this,n)};const gIe=P({stridedSlice_:function mIe(n,t,e,i,r=0,s=0,o=0,a=0,l=0){const d={x:E(n,"x","stridedSlice","string_or_numeric")};return O.runKernel(qI,d,{begin:t,end:e,strides:i,beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l})}});X().prototype.stridedSlice=function(n,t,e,i,r,s,o,a){return this.throwIfDisposed(),gIe(this,n,t,e,i,r,s,o,a)},X().prototype.sub=function(n){return this.throwIfDisposed(),Me(this,n)},X().prototype.sum=function(n,t){return this.throwIfDisposed(),Ne(this,n,t)};const bIe=P({tan_:function _Ie(n){const e={x:E(n,"x","tan","float32")};return O.runKernel(Hm,e)}});X().prototype.tan=function(){return this.throwIfDisposed(),bIe(this)},X().prototype.tanh=function(){return this.throwIfDisposed(),sT(this)},X().prototype.tile=function(n){return this.throwIfDisposed(),vo(this,n)},X().prototype.toBool=function(){return this.throwIfDisposed(),be(this,"bool")},X().prototype.toFloat=function(){return this.throwIfDisposed(),be(this,"float32")},X().prototype.toInt=function(){return this.throwIfDisposed(),be(this,"int32")};const vIe=P({topk_:function yIe(n,t=1,e=!0){const i=E(n,"x","topk");if(0===i.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=i.shape[i.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const s={x:i},o={k:t,sorted:e},[a,l]=O.runKernel(ZI,s,o);return{values:a,indices:l}}});X().prototype.topk=function(n,t){return this.throwIfDisposed(),vIe(this,n,t)},X().prototype.transpose=function(n){return this.throwIfDisposed(),Mt(this,n)};const wIe=P({unique_:function xIe(n,t=0){const e=E(n,"x","unique","string_or_numeric");S(e.rank>0,()=>"The input tensor must be at least 1D");const i={x:e},r={axis:t},[s,o]=O.runKernel(JI,i,r);return{values:s,indices:o}}});X().prototype.unique=function(n){return this.throwIfDisposed(),wIe(this,n)},X().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),nW(this,n,t)},X().prototype.unstack=function(n){return this.throwIfDisposed(),ld(this,n)},X().prototype.where=function(n,t){return this.throwIfDisposed(),Yr(n,this,t)},X().prototype.zerosLike=function(){return this.throwIfDisposed(),Nt(this)};class na extends Error{constructor(t){super(t),Object.setPrototypeOf(this,na.prototype)}}class Ys extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ys.prototype)}}class R extends Error{constructor(t){super(t),Object.setPrototypeOf(this,R.prototype)}}class et extends Error{constructor(t){super(t),Object.setPrototypeOf(this,et.prototype)}}class jT extends Error{constructor(t){super(t),Object.setPrototypeOf(this,jT.prototype)}}class pW extends Error{constructor(t){super(t),Object.setPrototypeOf(this,pW.prototype)}}class fW{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const i=this.cache.keys().next().value;this.cache.delete(i)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const i=this.cache.keys().next().value;this.cache.delete(i)}this.maxEntries=t}}function ud(n,t){if(Array.isArray(n)){let e=[];for(let i=0;i<t;i++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function _s(n,t){if(!n)throw new jT(t)}function mW(n,t){let e=0;for(const i of n)i===t&&e++;return e}function Pr(n){return 1===n.length?n[0]:n}function un(n){return Array.isArray(n)?n:[n]}function Ya(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function hd(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let Ks={};function WT(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function GT(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>GT(t));else{const t=Object.keys(n);for(const e of t){const i=n[e];null!=i&&"object"==typeof i&&(Array.isArray(i)||"ndarray"!==i.type||"number"!=typeof i.value?GT(i):n[e]=i.value)}}}function gg(n,t={},e={},i="object",r=!1){if("string"==typeof n){let o;if(n in e)o=e[n];else if(n in Ks)o=Ks[n];else if(o=t[n],null==o)throw new R(`Unknown ${i}: ${n}. This may be due to one of the following reasons:\n1. The ${i} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${i} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}{const s=n;if(null==s.className||null==s.config)throw new R(`${i}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const o=s.className;let a,l;if(o in e?[a,l]=e[o]:o in Ks?[a,l]=Ks.className:o in t&&([a,l]=t[o]),null==a)throw new R(`Unknown ${i}: ${o}. This may be due to one of the following reasons:\n1. The ${i} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${i} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const c={};for(const p of Object.keys(Ks))c[p]=Ks[p];for(const p of Object.keys(e))c[p]=e[p];s.config.customObjects=c;const u=Object.assign({},Ks);for(const p of Object.keys(e))Ks[p]=e[p];GT(s.config);const h=l(a,s.config,e,r);return Ks=Object.assign({},u),h}{const c=Object.assign({},Ks);for(const u of Object.keys(e))Ks[u]=e[u];const d=new a(s.config);return Ks=Object.assign({},c),d}}}function Yx(n,t){return-1*function CIe(n,t){return n<t?-1:n>t?1:0}(n,t)}function Ul(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function DIe(n){if(null==n)throw new R(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function pd(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new R(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function qT(n,t,e=0,i=1/0){return _s(e>=0),_s(i>=e),Array.isArray(n)&&n.length>=e&&n.length<=i&&n.every(r=>typeof r===t)}function Ni(n,t){Array.isArray(n)?(S(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,i)=>Ni(e,`element ${i+1} of ${t}`))):S(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${gW(n)}.`)}function gW(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>gW(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function _W(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let kIe=0;function bW(){return kIe++}const Kx={};function Xx(n=""){return n in Kx||(Kx[n]=0),Kx[n]+=1,n+Kx[n].toString()}const EIe=["channelsFirst","channelsLast"],IIe=["nearest","bilinear"],TIe=["valid","same","causal"],AIe=["max","avg"],MIe=["sum","mul","concat","ave"],mh=new Map;function Zn(n){pd(EIe,"DataFormat",n)}function bs(n){pd(TIe,"PaddingMode",n)}function yW(n){pd(AIe,"PoolMode",n)}const _g=[],vW="/";function fd(n,t){_g.push(n);try{const e=t();return _g.pop(),e}catch(e){throw _g.pop(),e}}function xW(n){if(!CW(n))throw new Error("Not a valid tensor name: '"+n+"'");return function RIe(){return 0===_g.length?"":_g.join(vW)+vW}()+n}function wW(n){if(!CW(n))throw new Error("Not a valid tensor name: '"+n+"'");mh.has(n)||mh.set(n,0);const t=mh.get(n);if(mh.set(n,mh.get(n)+1),t>0){const e=`${n}_${t}`;return mh.set(e,1),e}return n}const OIe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function CW(n){return!!n.match(OIe)}function FIe(n){return n===parseInt(n.toString(),10)}function Hl(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let i=1;for(let r=t;r<e;++r)i*=n[r];return i}function gh(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const i=n[e];i<t&&(t=i)}return t}function jl(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const i=n[e];i>t&&(t=i)}return t}function wo(n,t){if(t<n)throw new R(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let i=n;i<t;++i)e.push(i);return e}let Zx;function pi(){return null==Zx&&(Zx=function mxe(){return O.backend}().epsilon()),Zx}function ia(n,t){return be(n,t)}function bg(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),B(n,e)}function md(n,t,e){return G(()=>{switch(n.rank){case 1:return nT(n,t,e);case 2:return rj(n,[t,0],[e,n.shape[1]]);case 3:return iT(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Lx(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return tn(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return tn(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new R(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function YT(n,t,e){return G(()=>{switch(n.rank){case 1:return nT(n,t,e);case 2:return rj(n,[0,t],[n.shape[0],e]);case 3:return iT(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Lx(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new R(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Qx(n,t,e,i){return G(()=>{switch(n.rank){case 1:return nT(n,t,e);case 2:switch(i){case 1:return md(n,t,e);case 2:return YT(n,t,e);default:throw new R(`The axis is not within the rank of the tensor ${i}`)}case 3:switch(i){case 1:return md(n,t,e);case 2:return iT(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return YT(n,t,e);default:throw new R(`The axis is not within the rank of the tensor ${i}`)}case 4:switch(i){case 1:return md(n,t,e);case 2:return Lx(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Lx(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return YT(n,t,e);default:throw new R(`The axis is not within the rank of the tensor ${i}`)}default:throw new R(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function KT(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),Qi(n,t)}function SW(n,t){switch(n.rank){case 1:return C0e([n,t]);case 2:return S0e([n,t],0);case 3:return E0e([n,t],0);case 4:return T0e([n,t],0);default:throw new R(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function XT(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new R(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return vo(n,t)}function Jx(n,t=0,e=1,i,r){return Cwe(n,t,e,i,r)}function ra(n,t,e,i){if(n.rank<2||t.rank<2)throw new et(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new et(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return dj({a:n,b:t,transposeA:!1,transposeB:!1,bias:i?ZT(n.rank,i,"channelsLast"):null,activation:e});{const r=n.shape.slice(),s=r.pop();n=B(n,[-1,s]);const o=t.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],d=Array.from({length:t.rank},(f,m)=>0===m?t.rank-2:m<=t.rank-2?m-1:m);t=B(Mt(t,d),[l,-1]);const u=[...r,...c];return B(dj({a:n,b:t,transposeA:!1,transposeB:!1,bias:i?ZT(n.rank,i,"channelsLast"):null,activation:e}),u)}}function kW(n,t,e){return G(()=>(t=Array.isArray(t)?gr(t,"int32"):be(t,"int32"),W1(n,t,e)))}function yg(n){return N(n,n)}function ZT(n,t,e){const i=t.shape;if(1!==t.rank&&t.rank!==n)throw new R(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return B(t,1===i.length?[1,i[0],1,1,1]:[1,i[3],i[0],i[1],i[2]]);if("channelsLast"===e)return B(t,1===i.length?[1,1,1,1,i[0]]:[1].concat(i))}else if(4===n){if("channelsFirst"===e)return B(t,1===i.length?[1,i[0],1,1]:[1,i[2],i[0],i[1]]);if("channelsLast"===e)return B(t,1===i.length?[1,1,1,i[0]]:[1].concat(i))}else if(3===n){if("channelsFirst"===e)return B(t,1===i.length?[1,i[0],1]:[1,i[1],i[0]]);if("channelsLast"===e)return B(t,1===i.length?[1,1,i[0]]:[1].concat(i))}else if(n<3)return t;throw new R(`Unsupported input rank by biasAdd: ${t.rank}`)}function Do(n,t,e){return G(()=>(null==e&&(e="channelsLast"),Zn(e),ue(n,ZT(n.rank,t,e))))}function EW(n,t,e,i){return G(()=>Xwe(n,t,e,i))}function vg(n,t,e=!1){return e?n():t()}const jIe=["fanIn","fanOut","fanAvg"],WIe=["normal","uniform","truncatedNormal"];class Xs extends ah{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}ce((()=>{class n extends Xs{apply(e,i){return Mi(e,i)}}return n.className="Zeros",n})());let IW=(()=>{class n extends Xs{apply(e,i){return Bl(e,i)}}return n.className="Ones",n})();ce(IW),ce((()=>{class n extends Xs{constructor(e){if(super(),"object"!=typeof e)throw new R(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new R(`config must have value set but got ${e}`);this.value=e.value}apply(e,i){return G(()=>N(Ke(this.value),Bl(e,i)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),ce((()=>{class n extends Xs{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,i){return Px(e,this.minval,this.maxval,i,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),ce((()=>{class n extends Xs{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,i){if("float32"!==(i=i||"float32")&&"int32"!==i)throw new et(`randomNormal does not support dType ${i}.`);return Jx(e,this.mean,this.stddev,i,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),ce((()=>{class n extends Xs{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,i){if("float32"!==(i=i||"float32")&&"int32"!==i)throw new et(`truncatedNormal does not support dType ${i}.`);return sj(e,this.mean,this.stddev,i,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),ce((()=>{class n extends Xs{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,i){return G(()=>{if(2!==e.length||e[0]!==e[1])throw new R("Identity matrix initializer can only be used for 2D square matrices.");return N(this.gain,Q4(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let ys=(()=>{class n extends Xs{constructor(e){if(super(),e.scale<0)throw new R(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function GIe(n){pd(jIe,"FanMode",n)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function qIe(n){pd(WIe,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,i){const r=function YIe(n,t="channelsLast"){let e,i;if(Zn(t),2===n.length)e=n[0],i=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const r=Hl(n,2);e=n[1]*r,i=n[0]*r}else if("channelsLast"===t){const r=Hl(n,0,n.length-2);e=n[n.length-2]*r,i=n[n.length-1]*r}}else{const r=Hl(n);e=Math.sqrt(r),i=Math.sqrt(r)}return[e,i]}(e),s=r[0],o=r[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,s):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(s+o)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(i=i||"float32")&&"int32"!==i)throw new et(`${this.getClassName()} does not support dType ${i}.`);return sj(e,0,l,i,this.seed)}{const l=Math.sqrt(3*a);return Px(e,-l,l,i,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();ce(ys);let TW=(()=>{class n extends ys{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ys.className}}return n.className="GlorotUniform",n})();ce(TW);let AW=(()=>{class n extends ys{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ys.className}}return n.className="GlorotNormal",n})();ce(AW);let MW=(()=>{class n extends ys{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ys.className}}return n.className="HeNormal",n})();ce(MW);let NW=(()=>{class n extends ys{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ys.className}}return n.className="HeUniform",n})();ce(NW);let RW=(()=>{class n extends ys{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ys.className}}return n.className="LeCunNormal",n})();ce(RW);let OW=(()=>{class n extends ys{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ys.className}}return n.className="LeCunUniform",n})();ce(OW),ce((()=>{class n extends Xs{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new et("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,i){return G(()=>{if(e.length<2)throw new et("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const s=Jx(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let o=UDe.gramSchmidt(s);return e[0]>e[1]&&(o=Mt(o)),N(this.gain,o)})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const FW={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function PW(n,t={}){return gg(n,Us.getMap().classNameMap,t,"initializer")}function Fn(n){return WT(n)}function kn(n){if("string"==typeof n){const t=n in FW?FW[n]:n;if("GlorotNormal"===t)return new AW;if("GlorotUniform"===t)return new TW;if("HeNormal"===t)return new MW;if("HeUniform"===t)return new NW;if("LeCunNormal"===t)return new RW;if("LeCunUniform"===t)return new OW;{const e={};return e.className=t,e.config={},PW(e)}}return n instanceof Xs?n:PW(n)}function QT(n){return Array.isArray(n)&&Array.isArray(n[0])}function e0(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function qe(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new R(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Bt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new R(`Expected exactly 1 Shape; got ${n.length}`)}return n}function t0(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((i,r)=>i*r);return t}const LW="Variable";class sa{constructor(t,e="float32",i=LW,r=!0,s=null){this.dtype=e??"float32",this.shape=t.shape,this.id=bW(),this.originalName=xW(i=i??LW),this.name=wW(this.originalName),this.trainable_=r,this.constraint=s,this.val=function Hwe(n,t=!0,e,i){return O.makeVariable(n,t,e,i)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function KIe(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function JT(n){return n.map(t=>t.read())}function eA(n){n.forEach(t=>{t[0].write(t[1])})}class fi{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class oa{constructor(t,e,i,r,s,o,a){this.dtype=t,this.shape=e,this.sourceLayer=i,this.inputs=r,this.callArgs=s,this.outputTensorIndex=a,this.id=bW(),null!=o&&(this.originalName=xW(o),this.name=wW(this.originalName)),this.rank=e.length}}let XIe=0;class n0{constructor(t,e){this.callArgs=e,this.id=XIe++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const i of t.inboundLayers)i?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ZIe=0;class xt extends ah{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ZIe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const i=this.getClassName();e=Ya(i)+"_"+Xx(i)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let i;if(null!=t.batchInputShape)i=t.batchInputShape;else if(null!=t.inputShape){let s=null;null!=t.batchSize&&(s=t.batchSize),i=[s].concat(t.inputShape)}this.batchInputShape=i;let r=t.dtype;null==r&&(r=t.inputDType),null==r&&(r="float32"),this.dtype=r}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new Ys(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new R(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Pr(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Pr(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new na(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new na(`Layer ${this.name} is not connected, no input to return.`);return Pr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new na(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new na(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Pr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=un(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=un(this.inputSpec);if(t.length!==e.length)throw new R(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let i=0;i<t.length;i++){const r=t[i],s=e[i];if(null==s)continue;const o=r.rank;if(null!=s.ndim&&o!==s.ndim)throw new R(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${o}`);if(null!=s.maxNDim&&o>s.maxNDim)throw new R(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${o}`);if(null!=s.minNDim&&o<s.minNDim)throw new R(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${o}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new R(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const a=r.shape;for(const l in s.axes){const c=Number(l),d=s.axes[l];if(null!=d&&-1===[d,null].indexOf(c>=0?a[c]:a[a.length+c]))throw new R(`Input ${i} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${d} but got shape ${a}.`)}}if(null!=s.shape)for(let a=0;a<s.shape.length;++a){const l=s.shape[a],c=r.shape[a];if(null!=l&&null!=c&&l!==c)throw new R(`Input ${i} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const i=un(t);let r=!0;for(const o of i)if(!(o instanceof oa)){r=!1;break}let s=!0;for(const o of i)if(o instanceof oa){s=!1;break}if(r===s)throw new R("Arguments to apply() must be all SymbolicTensors or all Tensors");return fd(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of un(t))o.push(a.shape);this.build(Pr(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let o=this.call(t,e);const a=un(o),l=[];for(let c of a)-1!==i.indexOf(c)&&(c=c.clone()),l.push(c);if(o=Pr(l),null!=this.activityRegularizer)throw new et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const o=function QIe(n){n=un(n);const t=[];for(const e of n)t.push(e.shape);return Pr(t)}(t),a=this.computeOutputShape(o);let l;const c="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((d,u)=>new oa(c,d,this,un(t),e,this.name,u)):new oa(c,a,this,un(t),e,this.name),this.addInboundNode(t,l,null,null,o,a,e),this._refCount++,null!=this.activityRegularizer)throw new et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((i,r)=>{null!=i&&null!=t[r]&&t[r]!==i&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new na(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const i=JSON.stringify(e.outputShapes);-1===t.indexOf(i)&&t.push(i)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new na(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ys(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return t0(this.weights)}build(t){this.built=!0}getWeights(t=!1){return JT(t?this.trainableWeights:this.weights)}setWeights(t){G(()=>{const e=this.weights;if(e.length!==t.length)throw new R(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const i=[],r=JT(e);for(let s=0;s<r.length;++s){const o=r[s],a=e[s],l=t[s];if(!Ut(o.shape,l.shape))throw new R(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);i.push([a,l])}eA(i)})}addWeight(t,e,i,r,s,o,a,l){if(-1!==this._addedWeightNames.indexOf(t))throw new R(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==i&&(i="float32"),this.fastWeightInitDuringBuild&&(r=null!=l?l():kn("zeros"));const c=r.apply(e,i),d=new sa(c,i,t,o,a);return c.dispose(),null!=s&&this.addLoss(()=>s.apply(d.read())),null==o&&(o=!0),o?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=un(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(i=>{if(null!=i)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,i,r,s,o,a=null){const l=un(t);e=un(e),i=un(i),r=un(r),s=e0(s),o=e0(o);const c=[],d=[],u=[];for(const h of l)c.push(h.sourceLayer),d.push(h.nodeIndex),u.push(h.tensorIndex);new n0({outboundLayer:this,inboundLayers:c,nodeIndices:d,tensorIndices:u,inputTensors:l,outputTensors:e,inputMasks:i,outputMasks:r,inputShapes:s,outputShapes:o},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function $W(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const i=t.inboundNodes[e];if(0===i.inboundLayers.length)return i.inputTensors;{const r=[];for(let s=0;s<i.inboundLayers.length;s++){const c=$W(i.inputTensors[s],i.inboundLayers[s],i.nodeIndices[s]);for(const d of c)-1===r.indexOf(d)&&r.push(d)}return r}}}let xg=(()=>{class n extends xt{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Xx("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new R("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let i=e.batchInputShape;if(null==i){if(null==e.inputShape)throw new R("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");i=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new R("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=i,this.dtype=r,this.inputSpec=[{shape:i}];const s=new oa(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new n0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[i],outputShapes:[i]})}apply(e,i){throw new R(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();ce(xg);class Wl{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Wl)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,i){if(null!=this.id2Value[t.id])throw new R(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function e1e(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return be(t,n.dtype)}catch{throw new R(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=i&&(this.id2Mask[t.id]=i),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof oa){if(null==this.id2Value[t.id])throw new R(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new R(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof oa){if(null==this.id2Value[t.id])throw new R(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new R(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&mt(this.id2Mask)}}const r0=new fW,s0=new fW;function wg(n,t,e,i){const r=null!=e&&e.training,s=Array.isArray(n),o=s?n:[n],a=o.map(f=>f.name),l=[],c=t.names();for(const f of a)-1!==c.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=i&&(i.maxNumTensors=-1/0,i.minNumTensors=1/0);const d=a.join(",")+"|"+t.names().sort().join(",");let h,u=r0.get(d);if(null==u){const f=function n1e(n,t){S(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],i={};if(1===n.length){const r=BW(n[0],t);e=r.sorted,i=r.recipientMap}else{const r=new Set;for(const s of n){const{sorted:o,recipientMap:a}=BW(s,t);for(const l of o)r.has(l.name)||(e.push(l),r.add(l.name));for(const l in a)null==i[l]&&(i[l]=new Set),a[l].forEach(c=>i[l].add(c))}}return{sorted:e,recipientCounts:i1e(i)}}(o,t);u=f.sorted,h=f.recipientCounts,r0.put(d,u),s0.put(d,h)}h={},r||Object.assign(h,s0.get(d));const p=new Wl(t);for(let f=0;f<u.length;++f){if(null!=i){const k=k1().numTensors;k>i.maxNumTensors&&(i.maxNumTensors=k),k<i.minNumTensors&&(i.minNumTensors=k)}const m=u[f],g=m.sourceLayer;if(g instanceof xg)continue;const _=[],b=[],y=[];let v=!1;for(const k of m.inputs){const I=p.getValue(k),A=p.getMask(k);_.push(I),b.push(A),null!=A&&(v=!0),r||(h[k.name]--,0===h[k.name]&&!t.hasKey(k)&&-1===a.indexOf(k.name)&&!I.isDisposed&&!0!==k.sourceLayer.stateful&&y.push(I))}v&&((e=e||{}).mask=b[0]);const x=un(g.apply(_,e));let w=null;g.supportsMasking&&(w=g.computeMask(_,b));const C=r1e(m),D=Array.isArray(C)?C:[C];for(let k=0;k<D.length;++k){p.hasKey(D[k])||p.add(D[k],x[k],Array.isArray(w)?w[0]:w);const I=a.indexOf(D[k].name);-1!==I&&(l[I]=x[k])}r||mt(y)}return p.disposeMasks(),s?l:l[0]}function i1e(n){const t={};for(const e in n)t[e]=n[e].size;return t}function BW(n,t){const e=new Set,i=[],r={};for(const a of t.names())e.add(a);const s=[],o=[];for(s.push(n);s.length>0;){const a=s[s.length-1];if(e.has(a.name)){s.pop();continue}const l=o[o.length-1]===s.length-1;if(0===a.inputs.length||l)s.pop(),i.push(a),e.add(a.name),l&&o.pop();else{o.push(s.length-1);for(const c of a.inputs)null==r[c.name]&&(r[c.name]=new Set),r[c.name].add(a.name),!e.has(c.name)&&s.push(c)}}return{sorted:i,recipientMap:r}}function r1e(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let i=0;i<n.sourceLayer.inboundNodes.length;++i)for(const r of n.sourceLayer.inboundNodes[i].outputTensors)if(r.id===n.id){e=i;break}t=n.sourceLayer.getOutputAt(e)}return t}function tA(n,t){return G(()=>fr(Ne(N(n,n),t,!0)))}q().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function t1e(n){r0?.setMaxEntries(n),s0?.setMaxEntries(n)});class Cg extends ah{getConfig(){return{}}}ce((()=>{class n extends Cg{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return G(()=>{const i=tA(e,this.axis),r=fs(i,0,this.maxValue);return N(e,$e(r,ue(pi(),i)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),ce((()=>{class n extends Cg{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return G(()=>$e(e,ue(pi(),tA(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),ce((()=>{class n extends Cg{apply(e){return Wa(e)}}return n.className="NonNeg",n})()),ce((()=>{class n extends Cg{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return G(()=>{const i=tA(e,this.axis),r=ue(N(this.rate,fs(i,this.minValue,this.maxValue)),N(1-this.rate,i));return N(e,$e(r,ue(pi(),i)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const zW={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function mi(n){return WT(n)}function UW(n,t={}){return gg(n,Us.getMap().classNameMap,t,"constraint")}function gi(n){return null==n?null:"string"==typeof n?UW({className:n in zW?zW[n]:n,config:{}}):n instanceof Cg?n:UW(n)}function Gl(n){return nA.apply(this,arguments)}function nA(){return nA=ie(function*(n){if(null==n)return;const t=[],e=[],i=[];for(const r in n){const s=n[r];if("number"!=typeof s){const o=s;t.push(o.data()),e.push(r),i.push(o)}}if(t.length>0){const r=yield Promise.all(t);for(let s=0;s<r.length;++s)n[e[s]]=r[s][0];mt(i)}}),nA.apply(this,arguments)}function HW(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class _h{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return ie(function*(){})()}onEpochEnd(t,e){return ie(function*(){})()}onBatchBegin(t,e){return ie(function*(){})()}onBatchEnd(t,e){return ie(function*(){})()}onTrainBegin(t){return ie(function*(){})()}onTrainEnd(t){return ie(function*(){})()}setModel(t){}}class o1e{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var i=this;return ie(function*(){null==e&&(e={});for(const r of i.callbacks)yield r.onEpochBegin(t,e)})()}onEpochEnd(t,e){var i=this;return ie(function*(){null==e&&(e={});for(const r of i.callbacks)yield r.onEpochEnd(t,e)})()}onBatchBegin(t,e){var i=this;return ie(function*(){null==e&&(e={});for(const r of i.callbacks)yield r.onBatchBegin(t,e)})()}onBatchEnd(t,e){var i=this;return ie(function*(){null==e&&(e={});for(const r of i.callbacks)yield r.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return ie(function*(){null==t&&(t={});for(const i of e.callbacks)yield i.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return ie(function*(){null==t&&(t={});for(const i of e.callbacks)yield i.onTrainEnd(t)})()}}class a1e extends _h{constructor(){super()}onEpochBegin(t){var e=this;return ie(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var i=this;return ie(function*(){null==e&&(e={});const r=null==e.size?0:e.size;i.seen+=r;for(const s in e){const o=e[s];if("number"==typeof o)i.totals.hasOwnProperty(s)||(i.totals[s]=0),i.totals[s]=i.totals[s]+o*r;else{let a;s in i.totals?a=i.totals[s]:i.totals[s]=0;const l=G(()=>ue(i.totals[s],N(o,r)));i.totals[s]=l,a?.dispose()}}})()}onEpochEnd(t,e){var i=this;return ie(function*(){if(null!=e)for(const r of i.params.metrics)null!=i.totals[r]&&("number"==typeof i.totals[r]?e[r]=i.totals[r]/i.seen:G(()=>{const s=N($e(1,i.seen),i.totals[r]);e[r]=s,i.totals[r].dispose(),Jo(e[r])}))})()}}class l1e extends _h{onTrainBegin(t){var e=this;return ie(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var i=this;return ie(function*(){null==e&&(e={}),i.epoch.push(t);for(const r in e)null==i.history[r]&&(i.history[r]=[]),i.history[r].push(e[r])})()}syncData(){var t=this;return ie(function*(){const e=[],i=[],r=[];for(const o in t.history){const a=t.history[o];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),i.push(o),r.push(l))}const s=yield Promise.all(e);for(let o=0;o<s.length;++o)t.history[i[o]][r[o]].dispose(),t.history[i[o]][r[o]]=s[o][0]})()}}class c1e extends _h{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||wj,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");tI(this.yieldEvery)&&(this.maybeWait=function SIe(n,t,e){let r,i=null!=e?e():Fr();return(...o)=>{const a=null!=e?e():Fr();return a-i<t||(i=a,r=n(...o)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,i){var r=this;return ie(function*(){const s=[];null!=r.yield&&(yield Gl(i),s.push(r.yield(t,e,i))),s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onEpochBegin(t,e){var i=this;return ie(function*(){i.currentEpoch=t,null!=i.epochBegin&&(yield Gl(e),yield i.epochBegin(t,e))})()}onEpochEnd(t,e){var i=this;return ie(function*(){const r=[];null!=i.epochEnd&&(yield Gl(e),r.push(i.epochEnd(t,e))),"epoch"===i.yieldEvery&&r.push(i.nextFrameFunc()),yield Promise.all(r)})()}onBatchBegin(t,e){var i=this;return ie(function*(){null!=i.batchBegin&&(yield Gl(e),yield i.batchBegin(t,e))})()}onBatchEnd(t,e){var i=this;return ie(function*(){const r=[];null!=i.batchEnd&&(yield Gl(e),r.push(i.batchEnd(t,e))),"batch"===i.yieldEvery?r.push(i.nextFrameFunc()):tI(i.yieldEvery)&&r.push(i.maybeWait(i.currentEpoch,t,e)),yield Promise.all(r)})()}onTrainBegin(t){var e=this;return ie(function*(){null!=e.trainBegin&&(yield Gl(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return ie(function*(){null!=e.trainEnd&&(yield Gl(t),yield e.trainEnd(t))})()}}function jW(n,t){return null==n&&(n={}),n instanceof _h?[n]:Array.isArray(n)&&n[0]instanceof _h?n:un(n).map(i=>new c1e(i,t))}let d1e=(()=>{class n{constructor(){}static registerCallbackConstructor(e,i){S(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(i),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(i)}static checkForDuplicate(e){for(const i in n.constructors)n.constructors[+i].forEach(s=>{if(s===e)throw new R("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const i=[];for(const r in n.constructors){const s=+r;e>=s&&i.push(...n.constructors[s])}return i.map(r=>new r)}}return n.constructors={},n})();function WW(n,t,e,i,r,s,o,a,l){const c=new l1e,d=[new a1e,...d1e.createCallbacks(t)];null!=n&&d.push(...n),d.push(c);const u=new o1e(d);return u.setParams({epochs:e,initialEpoch:i,samples:r,steps:s,batchSize:o,verbose:t,doValidation:a,metrics:l}),{callbackList:u,history:c}}function aa(n,t={},e=!1){return gg(n,Us.getMap().classNameMap,t,"layer",e)}function o0(n,t){return G(()=>{"float32"!==n.dtype&&(n=be(n,"float32"));const e=Ne(yg(n),t,!0),i=eg(e.shape,pi()),r=fr(Pl(e,i));return $e(n,r)})}function a0(n,t){return G(()=>Yn(yg(Me(t,n)),-1))}function iA(n,t){return G(()=>Yn(Ii(Me(t,n)),-1))}function rA(n,t){return G(()=>{const e=Me(n,t),i=fs(Ii(n),pi(),Number.MAX_VALUE),r=Ii($e(e,i));return N(100,Yn(r,-1))})}function Dg(n,t,e=!1){return G(()=>{if(e)t=rT(t);else{const i=Ne(t,t.shape.length-1,!0);t=$e(t,i)}return t=fs(t,pi(),1-pi()),On(Ne(N(be(n,"float32"),Ws(t)),t.shape.length-1))})}function l0(n,t,e=!1){return G(()=>{const i=be(Rx(function VIe(n){const t=[Hl(n.shape)];return B(n,t)}(n)),"int32"),r=(t=fs(t,pi(),1-pi())).shape;return Dg(B(tj(i,r[r.length-1]),r),t,e)})}function c0(n,t){return G(()=>{let e;return e=fs(t,pi(),1-pi()),e=Ws($e(e,Me(1,e))),Yn(function g1e(n,t){if(!Ut(n.shape,t.shape))throw new R(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return G(()=>{const e=Wa(t),i=On(Ii(t));return ue(Me(e,N(t,n)),q1(js(i)))})}(n,e),-1)})}function GW(n,t){return G(()=>{const e=o0(n,-1),i=o0(t,-1),r=N(e,i);return On(Ne(r,-1))})}const d0={meanSquaredError:a0,meanAbsoluteError:iA,meanAbsolutePercentageError:rA,meanSquaredLogarithmicError:function u1e(n,t){return G(()=>{const e=fs(t,pi(),Number.MAX_VALUE),i=Ws(ue(1,e)),r=fs(n,pi(),Number.MAX_VALUE),s=Ws(ue(1,r));return Yn(yg(Me(i,s)),-1)})},squaredHinge:function h1e(n,t){return G(()=>{const e=Pl(0,Me(1,N(n,t)));return Yn(yg(e),-1)})},hinge:function p1e(n,t){return G(()=>{const e=Pl(0,Me(1,N(n,t)));return Yn(e,-1)})},categoricalHinge:function f1e(n,t){return G(()=>{const e=Ne(N(n,t),-1),i=xo(N(Me(1,n),t),-1);return Pl(0,ue(1,Me(i,e)))})},logcosh:function m1e(n,t){return G(()=>{const e=Math.log(2),i=Me(t,n),r=Me(ue(i,lg(N(-2,i))),e);return Yn(r,-1)})},categoricalCrossentropy:Dg,sparseCategoricalCrossentropy:l0,binaryCrossentropy:c0,kullbackLeiblerDivergence:function _1e(n,t){return G(()=>{const e=fs(n,pi(),1),i=fs(t,pi(),1);return Ne(N(n,Ws($e(e,i))),-1)})},poisson:function b1e(n,t){return G(()=>{const e=Ws(ue(pi(),t));return Yn(Me(t,N(n,e)),-1)})},cosineProximity:GW};function sA(n){if("string"==typeof n){if(n in d0)return d0[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new R(t)}return n}function qW(n,t){return G(()=>{const e=N(.5,Gs(t)),i=ia(ms(t,e),n.dtype);return Yn(ea(n,i),-1)})}function YW(n,t){return G(()=>ia(ea(tg(n,-1),tg(t,-1)),"float32"))}function w1e(n,t){return c0(n,t)}function C1e(n,t){return n.rank===t.rank&&(n=cg(n,[n.rank-1])),(t=tg(t,-1)).dtype!==n.dtype&&(t=be(t,n.dtype)),be(ea(n,t),"float32")}const XW=Dg,ZW=l0,u0={binaryAccuracy:qW,categoricalAccuracy:YW,precision:function x1e(n,t){return G(()=>{const e=function KW(n,t){return G(()=>be(Ne(ja(ea(n,1),ea(t,1))),"float32"))}(n,t),i=function v1e(n,t){return G(()=>be(Ne(ja(ea(n,0),ea(t,1))),"float32"))}(n,t),r=ue(e,i);return be(Yr(ms(r,0),$e(e,r),0),"float32")})},categoricalCrossentropy:XW,sparseCategoricalCrossentropy:ZW,mse:a0,MSE:a0,mae:iA,MAE:iA,mape:rA,MAPE:rA,cosine:GW};function M1e(n){if("string"==typeof n&&n in u0)return u0[n];if("string"!=typeof n&&null!=n)return n;throw new R(`Unknown metric ${n}`)}function h0(n){if(_s(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(d0))if(d0[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(u0))if(u0[e]===n){t=e;break}return void 0!==t?t:n.name}}const QW=1048576;function JW(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!oA(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const i=JSON.stringify(n);i.length>QW&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${i.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${QW}.`)}}function oA(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!oA(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!oA(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function p0(n,t,e=console.log){let i="";for(let r=0;r<n.length;++r)r>0&&(i=i.slice(0,i.length-1)+" "),i+=n[r],i=i.slice(0,t[r]),i+=" ".repeat(t[r]-i.length);e(i)}function P1e(n,t,e){let i,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}p0([`${n.name} (${n.getClassName()})`,r,i,n.countParams().toString()],t,e)}function L1e(n,t,e,i){let r,s;try{s=n.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const u of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(u)))for(let h=0;h<u.inboundLayers.length;++h)o.push(`${u.inboundLayers[h].name}[${u.nodeIndices[h]}][${u.tensorIndices[h]}]`);const a=n.name,l=n.getClassName(),c=0===o.length?"":o[0];p0([`${a} (${l})`,s,r,n.countParams().toString(),c],t,i);for(let u=1;u<o.length;++u)p0(["","","","",o[u]],t,i)}function eG(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function f0(n,t){if(null===n)return null;if("string"==typeof n)return hd(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],i=n.length;for(let r=0;r<i;++r){const s=n[r];eG(t,r,s)?e.push(s):e.push(f0(s,t))}return e}{const e={};for(const i of Object.keys(n)){const r=n[i];if("name"===i&&"string"==typeof r)e[i]=r;else{const s=hd(i);e[s]=f0(r,s)}}return e}}function aA(n,t){if(null==n)return null;if("string"==typeof n)return Ya(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],i=n.length;for(let r=0;r<i;++r){const s=n[r];eG(t,r,s)?e.push(s):e.push(aA(s,t))}return e}{const e={};for(const i of Object.keys(n)){const r=n[i];e[Ya(i)]="name"!==i&&"className"!==i||"string"!=typeof r?aA(r,i):r}return e}}class So extends xt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const b=this.getClassName().toLowerCase();this.name=Xx(b)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],Ul(this.inputs).length!==this.inputs.length)throw new R(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Ul(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const v=b.nodeIndex,x=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(x)}for(const b of this.inputs){const y=b.sourceLayer,v=b.nodeIndex,x=b.tensorIndex;_s(0===v,"input layer has >1 nodes"),_s(0===x,"input layer has >1 tensors"),this.inputLayers.push(y),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(x)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const y=this.inputLayers[b];if(!(y instanceof xg))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${y.getClassName()}.`);this.inputNames.push(y.name),this.feedInputShapes.push(y.batchInputShape),this.feedInputNames.push(y.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},i={},r={},s={},o={},a=[],l=(b,y,v,x,w,C)=>{(null==x||null==w||null==C)&&(x=b.sourceLayer,w=b.nodeIndex,C=b.tensorIndex);const D=x.inboundNodes[w];if(-1!==v.indexOf(D))throw new Ys(`The tensor ${b.name} at layer "${x.name}" is part of a cycle.`);if(-1!==y.indexOf(D))return;this.containerNodes.add(So.nodeKey(x,w)),x.id in o||(o[x.id]=Object.keys(o).length),-1===v.indexOf(D)&&v.push(D);const k=D.inboundLayers.length;for(let I=0;I<k;I++)l(D.inputTensors[I],y,v,D.inboundLayers[I],D.nodeIndices[I],D.tensorIndices[I]);for(y.push(D);v.indexOf(D)>=0;)v.splice(v.indexOf(D),1);a.push(D)},c=[],d=[];for(const b of this.outputs)l(b,c,d);const u=a.slice().reverse();for(const b of u){i[b.id]=b,b.id in e||(e[b.id]=0);let y=e[b.id];y=Math.max(y,null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id]),r[b.outboundLayer.id]=y,s[b.outboundLayer.id]=b.outboundLayer,e[b.id]=y;for(let x=0;x<b.inboundLayers.length;x++){const D=b.inboundLayers[x].inboundNodes[b.nodeIndices[x]];e[D.id]=Math.max(y+1,null==e[D.id]?0:e[D.id]),i[D.id]=D}}const h={};for(const b in e){const y=e[b];y in h||(h[y]=[]),h[y].push(i[b])}const p={};for(const b in r){const y=r[b];y in p||(p[y]=[]),p[y].push(s[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(Yx);this.layers=[];for(const b of f){const y=p[b];y.sort((v,x)=>{const w=o[v.id],C=o[x.id];return w<C?-1:w>C?1:0});for(const v of y)v instanceof So&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=p,f=Object.keys(h).map(b=>parseInt(b,10)).sort(Yx);const m=this.inputs.slice(),g=[];for(const b of f)for(const y of h[b]){const v=y.outboundLayer;if(null!=v){for(const x of y.inputTensors)if(-1===m.indexOf(x))throw new Ys(`Graph disconnected: cannot obtain value for tensor ${x} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(const x of y.outputTensors)m.push(x);g.push(v.name)}}this.nodesByDepth=h;const _=this.layers.map(b=>b.name);for(const b of _){const y=_.filter(v=>v===b).length;if(1!==y)throw new Ys(`The name "${b}" is used ${y} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(_))}this.outboundNodes=[],this.inboundNodes=[],new n0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(i=>i.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new R("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const i of this.layers)e.push(...i.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const i={};let r=0;for(const o of this.layers)for(const a of o.weights){if(null!=i[a.originalName])throw new R(`Duplicate weight name: ${a.originalName}`);i[a.originalName]=a,r++}const s=[];for(const o in t){let a=o;if(null==i[o]){const l=o.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=i[a])s.push([i[a],t[o]]);else if(e)throw new R(`Provided weight data has no target variable: ${o}`);delete i[a]}if(e){const o=[];for(const a in i)o.push(a);if(o.length>0)throw new R(`${o.length} of ${r} weights are not set: ${o}`)}eA(s)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.2.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const i=aA(this.updatedConfig());return e?JSON.stringify(i):i}call(t,e){return G(()=>{t=un(t);const i=new Wl;for(let r=0;r<this.inputs.length;++r)i.add(this.inputs[r],t[r]);return wg(this.outputs,i,e)})}computeMask(t,e){return G(()=>{let i;return t=un(t),i=null==e?ud(null,t.length):un(e),this.runInternalGraph(t,i)[1]})}computeOutputShape(t){const e=e0(t);if(e.length!==this.inputLayers.length)throw new R(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const i={};for(let a=0;a<e.length;a++)i[this.inputLayers[a].name+"_0_0"]=e[a];const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Yx);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const c of l){const d=c.outboundLayer;if(-1!==this.inputLayers.map(m=>m.id).indexOf(d.id))continue;const u=[];for(let m=0;m<c.inboundLayers.length;m++)u.push(i[`${c.inboundLayers[m].name}_${c.nodeIndices[m]}_${c.tensorIndices[m]}`]);const p=e0(d.computeOutputShape(Pr(u))),f=d.inboundNodes.indexOf(c);for(let m=0;m<p.length;m++)i[`${d.name}_${f}_${m}`]=p[m]}}const s=[],o=[];for(let a=0;a<this.outputLayers.length;a++)o.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<o.length;a++){const l=o[a];_s(l in i),s.push(i[l])}return Pr(s)}runInternalGraph(t,e){null==e&&(e=ud(null,t.length));const i={};for(let l=0;l<this.inputs.length;++l)i[this.inputs[l].id]=[t[l],e[l]];const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Yx);for(const l of r){const c=this.nodesByDepth[l];for(const d of c){const u=d.outboundLayer,h=d.inputTensors,p=d.outputTensors,f=new Array;for(const m of h)m.id in i&&f.push(i[m.id]);if(f.length===h.length){let g,_,b,y,m={};if(null!=d.callArgs&&(m=d.callArgs),1===f.length){const[v,x]=f[0];null==m.mask&&(m.mask=x),b=un(u.call(v,m)),y=un(u.computeMask(v,x)),g=[v],_=[x]}else g=f.map(v=>v[0]),_=f.map(v=>v[1]),null==m.mask&&(m.mask=_),b=un(u.call(g,m)),y=un(u.computeMask(g,_));if(u.activityRegularizer)throw new et("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<p.length;++v)i[p[v].id]=[b[v],y[v]]}}}const s=[],o=[],a=[];for(const l of this.outputs){_s(l.id in i,`Could not compute output ${l.name} : ${l.id}`);const[c,d]=i[l.id];a.push(c.shape),s.push(c),o.push(d)}return[s,o,a]}buildNodeConversionMap(t){const e={};let i;for(const r of this.layers){i=r instanceof So?1:0;for(let s=0;s<r.inboundNodes.length;s++){const o=So.nodeKey(r,s);this.containerNodes.has(o)&&(e[o]=i,i+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new R(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new R("Provide either a layer name or layer index");for(const i of this.layers)if(i.name===t)return i;throw new R(`No such layer: ${t}`)}calculateLosses(){return G(()=>{const t=[];for(const e of this.layers)for(let i=0;i<e.inboundNodes.length;++i){const r=So.nodeKey(e,i);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),i=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let u=0;u<o.inboundNodes.length;u++){const h=o.inboundNodes[u],p=So.nodeKey(o,u);let f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const _=h.inboundLayers[g],y=h.tensorIndices[g];let x=e[So.nodeKey(_,h.nodeIndices[g])];null==x&&(x=0),m.push([_.name,x,y,f])}c.push(m)}}}const d={};d.name=o.name,d.className=a,d.config=l,d.inboundNodes=c,i.push(d)}t.layers=i;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],c=So.nodeKey(a,this.inputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let d=e[c];null==d&&(d=0),r.push([a.name,d,this.inputLayersTensorIndices[o]])}t.inputLayers=r;const s=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],c=So.nodeKey(a,this.outputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let d=e[c];null==d&&(d=0),s.push([a.name,d,this.outputLayersTensorIndices[o]])}return t.outputLayers=s,t}static fromConfig(t,e,i={},r=!1){const s={},o={};function a(g,_){g.name in o?o[g.name].push(_):o[g.name]=[_]}function l(g,_){const b=[];let y;for(const v of _){const x=v[0],w=v[1],C=v[2];if(y=null==v[3]?{}:v[3],!(x in s))return void a(g,_);const D=s[x];if(D.inboundNodes.length<=w)return void a(g,_);b.push(D.inboundNodes[w].outputTensors[C])}b.length>0&&g.apply(Pr(b),y)}function c(g){const _=g.name,b=aa(g,null!=e.customObjects?e.customObjects:{});b.setFastWeightInitDuringBuild(r),s[_]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new R(`Corrupted configuration, expected array for nodeData: ${v}`);a(b,v)})}const d=e.name,u=e.layers;for(const g of u)c(g);for(;!DIe(o);)for(const g of u){const _=s[g.name];if(_.name in o){const b=o[_.name];delete o[_.name];for(const y of b)l(_,y)}}const h=[],p=[],f=e.inputLayers;for(const g of f){const _=g[0],b=g[1],y=g[2];_s(_ in s),h.push(s[_].inboundNodes[b].outputTensors[y])}const m=e.outputLayers;for(const g of m){const _=g[0],b=g[1],y=g[2];_s(_ in s),p.push(s[_].inboundNodes[b].outputTensors[y])}return new t({inputs:h,outputs:p,name:d})}get stateful(){if(this._stateful)throw new R("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){G(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function nG(n,t){return function tG(n,t,e){const i=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>null);if(1===i)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==i)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${i} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const r=[];return t.forEach(s=>{r.push(s in n?n[s]:null)}),r}throw new Error(`The model has multiple (${i}) outputs, so ${e} must be either an array with ${i} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function iG(n,t,e,i){return cA.apply(this,arguments)}function cA(){return cA=ie(function*(n,t,e,i){if(null!=t||null!=i)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const r=G(()=>{if(1===n.shape.length)return nd(n);if(2===n.shape.length){if(n.shape[1]>1)return tg(n,1);if(1===n.shape[1])return B(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield r.data());mt(r);const o=[];return s.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),gr(o,"float32")}return null}),cA.apply(this,arguments)}function $1e(n,t){return N(n,t)}const V1e=32;function rG(n,t){let e,i;e=t.xs,i=t.ys,S(null!=e&&null!=i,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const s=sG("input",n.inputNames,e),o=sG("output",n.outputNames,i),a=s[0].shape[0];S(s.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),S(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<s.length;l++)S(s[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${s[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)S(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:s,ys:o}}function sG(n,t,e){if(e instanceof qn)return[e];if(Array.isArray(e))return S(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const i=[];for(const r of t){if(null==e[r])throw new R(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);i.push(e[r])}return i}}function dA(){return dA=ie(function*(n,t,e){const i=null!=e.batchesPerEpoch;if(S(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),S(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),S(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),S(!i||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),S(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=null!=e.validationData;let s,o;if(r)if(oG(e.validationData))S(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const g=function B1e(n){if(3===n.length)throw new et("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}(e.validationData);s=g.xs,o=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;c=r?l.slice().concat(l.map(g=>"val_"+g)):l.slice();const d=jW(e.callbacks,e.yieldEvery),u=null==e.verbose?1:e.verbose,{callbackList:h,history:p}=WW(d,u,e.epochs,null,null,function U1e(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}(t,e),null,r,c);h.setModel(n),n.history=p,yield h.onTrainBegin(),n.stopTraining_=!1;let f=null==e.initialEpoch?0:e.initialEpoch,m=yield t.iterator();for(;f<e.epochs;){const g={};yield h.onEpochBegin(f);let _=0,b=0;for(i||(m=yield t.iterator());!i||_<e.batchesPerEpoch;){const y=yield m.next();if(i&&y.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${_} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=y.value){const{xs:v,ys:x}=rG(n,y.value),w={};w.batch=b,w.size=v[0].shape[0],yield h.onBatchBegin(b,w);const C=[];if(null!=e.classWeight){const I=nG(e.classWeight,n.outputNames);for(let A=0;A<I.length;++A)C.push(yield iG(x[A],null,I[A]))}const D=v.concat(x).concat(C),k=a(D);mt(D);for(let I=0;I<l.length;++I){const $=k[I];w[l[I]]=$,Jo($)}yield h.onBatchEnd(b,w),HW(w),b++,_++}if(i?_>=e.batchesPerEpoch:y.done){if(r){let v;v=oG(e.validationData)?un(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):un(n.evaluate(s,o,{batchSize:null==e.validationBatchSize?V1e:e.validationBatchSize,verbose:0}));for(let x=0;x<n.metricsNames.length;++x)g[`val_${n.metricsNames[x]}`]=v[x]}break}if(n.stopTraining_)break}if(yield h.onEpochEnd(f,g),f++,n.stopTraining_)break}return yield h.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}}),dA.apply(this,arguments)}function oG(n){return"function"==typeof n.iterator}function uA(){return uA=ie(function*(n,t,e){const i=null!=(e=e||{}).batches,r=n.testFunction;let s=[];if(e.verbose>0)throw new et("Verbose mode is not implemented yet.");S(!i||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=function H1e(n){return"function"==typeof n.next}(t)?t:yield t.iterator();let a=0,l=0;for(;!i||l<e.batches;){const c=yield o.next();if(s=G(()=>{if(c.value){const{xs:d,ys:u}=rG(n,c.value),h=d.concat(u),p=G(()=>r(h));if(mt(h),0===l)for(let m=0;m<p.length;++m)s.push(Ke(0));const f=h[0].shape[0];for(let m=0;m<p.length;++m){const g=p[m],_=s[m];s[m]=G(()=>ue(s[m],N(f,g))),l>0&&mt(_)}mt(p),a+=f,++l}return s}),c.done){i&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<s.length;++c){const d=s[c];s[c]=$e(s[c],a),mt(d)}return Pr(s)}),uA.apply(this,arguments)}function hA(n){S(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Sg(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(i=>md(i,t,e-t)):md(n,t,e-t)}function pA(n,t){return G(()=>null==n?null:Array.isArray(n)?n.map(e=>pA(e,t)):kW(n,"int32"===t.dtype?t:be(t,"int32")))}function fA(n,t){const e=[];let i=0,r=null;for(;i<n;)r=i+t,r>=n&&(r=n),e.push([i,r]),i=r;return e}function aG(n){const t=[];n instanceof qn&&(n=[n]);for(let e=0;e<n.length;++e){const i=n[e];if(1===i.rank)t.push(bg(i,1));else{if(0===i.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(i)}}return t}function ko(n,t){if(null==n)return;const e=[];if(t instanceof qn)e.push(t.id);else if(Array.isArray(t))t.forEach(r=>e.push(r.id));else if(null!=t)for(const r in t)e.push(t[r].id);const i=[];if(n instanceof qn)-1===e.indexOf(n.id)&&i.push(n);else if(Array.isArray(n))n.forEach(r=>{-1===e.indexOf(r.id)&&i.push(r)});else if(null!=n)for(const r in n){const s=n[r];-1===e.indexOf(s.id)&&i.push(s)}i.forEach(r=>{r.isDisposed||r.dispose()})}function mA(n){return Array.isArray(n)}function lG(n){return!function W1e(n){return n instanceof qn}(n)&&!mA(n)}function cG(n,t,e,i=!0,r=""){if(null==t||0===t.length){if(null!=n){let o=!1;if(mA(n)&&n.length>0)o=!0;else if(lG(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new R(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(o=>null);let s;if(lG(n)){s=[];for(const o of t){if(null==n[o])throw new R(`No data provided for "${o}". Need data for each key in: ${t}`);s.push(n[o])}}else if(mA(n)){if(n.length!==t.length)throw new R(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);s=n}else{if(t.length>1)throw new R(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);s=[n]}if(s=aG(s),null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=s[o];if(a.shape.length!==e[o].length)throw new R(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[o].length;++l){if(0===l&&!i)continue;const d=e[o][l];if(null!=d&&d>=0&&a.shape[l]!==d)throw new R(`${r} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function dG(n,t,e,i=!0,r=""){let s;if(Array.isArray(n)){if(n.length!==t.length)throw new R(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);s=n}else{if(t.length>1)throw new R(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);s=[n]}if(null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=s[o];if(a.shape.length!==e[o].length)throw new R(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[o].length;++l){if(0===l&&!i)continue;const d=e[o][l];if(null!=d&&d!==a.shape[l])throw new R(`Error when checking ${r}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let bh=(()=>{class n extends So{constructor(e){super(e),this.isTraining=!1}summary(e,i,r=console.log){if(!this.built)throw new R("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function R1e(n,t,e,i=console.log){const r=function F1e(n){let t=!0;const e=[],i=[];for(const r in n.nodesByDepth)e.push(n.nodesByDepth[r]);for(const r of e){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}i.push(...r)}if(t)for(const r of n.layers){let s=!1;for(const o of r.inboundNodes)if(-1!==i.indexOf(o)){if(s){t=!1;break}s=!0}if(!t)break}return t}(n),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(r?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(d=>Math.floor(t*d))),!r){s.push("Receives inputs"),o=[];for(const d in n.nodesByDepth)o.push(...n.nodesByDepth[d])}i("_".repeat(t)),p0(s,e,i),i("=".repeat(t));const a=n.layers;for(let d=0;d<a.length;++d)r?P1e(a[d],e,i):L1e(a[d],e,o,i),i((d===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=function O1e(n){let t;return t=t0(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),c=t0(n.nonTrainableWeights);i(`Total params: ${l+c}`),i(`Trainable params: ${l}`),i(`Non-trainable params: ${c}`),i("_".repeat(t))}(this,e,i,r)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function N1e(n){const t={Adagrad:()=>fh.adagrad(.01),Adadelta:()=>fh.adadelta(1,.95,pi()),Adam:()=>fh.adam(.001,.9,.999,pi()),Adamax:()=>fh.adamax(.002,.9,.999,pi(),0),RMSProp:()=>fh.rmsprop(.001,.9,0,pi()),SGD:()=>fh.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new R(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Fl))throw new R("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let i=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new R(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);i=e.loss.map(l=>sA(l))}else{const a=sA(e.loss);this.outputs.forEach(l=>{i.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new R(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),i.push(sA(e.loss[a]))}this.lossFunctions=i,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],fd("loss",()=>{for(let a=0;a<this.outputs.length;++a)-1===r.indexOf(a)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[a],a]),this.metricsNames.push(this.outputNames[a]+"_loss"))});const s=function Y1e(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(i=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(i=>e);{const i=[];for(const r of t){let s=e.hasOwnProperty(r)?e[r]:[];Array.isArray(s)||(s=[s]),i.push(s)}return i}}(e.metrics,this.outputNames),o=(a,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,a])};fd("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===r.indexOf(a)&&(d=>{let h,p,f;for(const m of d){if("string"==typeof m&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(m)){const _=this.internalOutputShapes[a];let b;1===_[_.length-1]||this.lossFunctions[a]===c0?-1!==["accuracy","acc"].indexOf(m)?p=qW:-1!==["crossentropy","ce"].indexOf(m)&&(p=w1e):this.lossFunctions[a]===l0?-1!==["accuracy","acc"].indexOf(m)?p=C1e:-1!==["crossentropy","ce"].indexOf(m)&&(p=ZW):-1!==["accuracy","acc"].indexOf(m)?p=YW:-1!==["crossentropy","ce"].indexOf(m)&&(p=XW),-1!==["accuracy","acc"].indexOf(m)?b="acc":-1!==["crossentropy","ce"].indexOf(m)&&(b="ce"),f=p,h=""+b}else f=M1e(m),h=""+h0(m);let g;fd(h,()=>{g=f}),o(a,h,g)}})(s[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,i,r={}){const s=null==r.batchSize?32:r.batchSize;hA(s);const a=this.standardizeUserDataXY(e,i,!0,s);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),Pr(this.testLoop(this.testFunction,l,s,r.verbose,r.steps))}finally{ko(a[0],e),ko(a[1],i)}}evaluateDataset(e,i){var r=this;return ie(function*(){return r.makeTestFunction(),function j1e(n,t,e){return uA.apply(this,arguments)}(r,e,i)})()}checkNumSamples(e,i,r,s="steps"){let o;if(null!=r){if(o=null,null!=i)throw new R(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${i}`)}else{if(null==e)throw new R(`Either the input data should have a defined shape, or ${s} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,i){if(Array.isArray(i)&&0===i.length)throw new R("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(i),o=this.retrieveSymbolicTensors(r?i:[i]),a=new Wl;if(e instanceof qn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new R(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(const c of this.inputs){const d=e[c.name];if(null==d)throw new R(`No value is provided for the model's input ${c.name}`);a.add(c,d)}const l=wg(o,a);return r?l:l[0]}retrieveSymbolicTensors(e){const i=ud(null,e.length);let r=e.length;for(const s of this.layers){const o=Array.isArray(s.output)?s.output:[s.output],a=o.map(l=>l.name);for(let l=0;l<e.length;++l){const c=a.indexOf(e[l]);if(-1!==c&&(i[l]=o[c],r--),0===r)break}if(0===r)break}if(r>0){const s=[];throw i.forEach((o,a)=>{null==o&&s.push(e[a])}),new R(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return i}predictLoop(e,i=32,r=!1){return G(()=>{const s=this.checkNumSamples(e);if(r)throw new et("Verbose predictLoop() is not implemented yet.");const o=fA(s,i),a=this.outputs.map(l=>[]);for(let l=0;l<o.length;++l)G(()=>{const h=Sg(e,o[l][0],o[l][1]),p=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)p.push({key:this.inputs[m],value:h[m]});else p.push({key:this.inputs[0],value:h});const f=new Wl(p);return wg(this.outputs,f)}).forEach((d,u)=>a[u].push(d));return Pr(a.map(l=>Qi(l,0)))})}predict(e,i={}){const r=aG(e);dG(r,this.inputNames,this.feedInputShapes,!1);try{const s=null==i.batchSize?32:i.batchSize;return hA(s),this.predictLoop(r,s)}finally{ko(r,e)}}predictOnBatch(e){dG(e,this.inputNames,this.feedInputShapes,!0);const i=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,i)}standardizeUserDataXY(e,i,r=!0,s){if(null==this.optimizer_)throw new Ys("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];o.push(this.feedLossFns[a]===l0?l.slice(0,l.length-1).concat([1]):l)}if(function G1e(n,t,e){const i=Ul(n.map(s=>s.shape[0]));i.sort();const r=Ul(t.map(s=>s.shape[0]));if(r.sort(),i.length>1)throw new R(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(r.length>1)throw new R(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(i.length>0&&r.length>0&&!Ut(i,r))throw new R(`Input Tensors should have the same number of samples as target Tensors. Found ${i[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=cG(e,this.feedInputNames,this.feedInputShapes,!1,"input"),i=cG(i,this.feedOutputNames,o,!1,"target")),function q1e(n,t,e){const i=[a0,c0,Dg];for(let r=0;r<n.length;++r){const s=n[r],o=t[r],a=e[r];if(null!=o){if(o===Dg&&1===s.shape[s.shape.length-1])throw new R(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==i.indexOf(o)){const l=s.shape.slice(1),c=a.slice(1);for(let d=0;d<l.length;++d){const h=c[d];if(null!=h&&l[d]!==h)throw new R(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(i,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=s&&s>0&&e[0].shape[0]%s!=0)throw new R(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,i]}standardizeUserData(e,i,r,s,o=!0,a){var l=this;return ie(function*(){const[c,d]=l.standardizeUserDataXY(e,i,o,a);if(null!=r)throw new Error("sample weight is not supported yet.");let u=null;if(null!=s){const h=nG(s,l.outputNames);u=[];for(let p=0;p<h.length;++p)u.push(yield iG(d[p],null,h[p]))}return[c,d,u]})()}testLoop(e,i,r,s=0,o){return G(()=>{const a=this.checkNumSamples(i,r,o,"steps"),l=[];if(s>0)throw new et("Verbose mode is not implemented yet.");if(null!=o)throw new et("steps mode in testLoop() is not implemented yet");{const c=fA(a,r),d=gr(wo(0,a));for(let u=0;u<c.length;++u){const h=c[u][0],p=c[u][1],f=md(d,h,p-h),m=pA(i,f),g=e(m);if(0===u)for(let _=0;_<g.length;++_)l.push(Ke(0));for(let _=0;_<g.length;++_)l[_]=ue(l[_],N(p-h,g[_]))}for(let u=0;u<l.length;++u)l[u]=$e(l[u],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,i=[];for(let r=0;r<e.length;++r){const s=e[r];let o=s;mW(e,s)>1&&(o+=`_${mW(e.slice(0,r),s)}`),i.push(o)}return i}makeTrainFunction(){return e=>{const i=[],r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],c=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:r[g]});const p=new Wl(h),f=wg(this.outputs,p,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){let b=(0,this.lossFunctions[g])(s[g],f[g]);null!=o[g]&&(b=$1e(b,o[g]));const y=Yn(b);i.push(y),m=0===g?b:ue(m,b)}for(let g=0;g<this.metricsTensors.length;++g){let _;if(this.outputs.length>1&&g<this.outputs.length)_=i[g];else{const y=this.metricsTensors[g][1];_=Yn((0,this.metricsTensors[g][0])(s[y],f[y]))}Jo(_),a.push(_)}return m=Yn(m),this.calculateLosses().forEach(g=>{m=ue(m,g)}),m},!0,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>G(()=>{const i=[];let r;const s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let d=0;d<this.inputs.length;++d)a.push({key:this.inputs[d],value:s[d]});const l=new Wl(a),c=wg(this.outputs,l);for(let d=0;d<this.lossFunctions.length;++d){const h=Yn((0,this.lossFunctions[d])(o[d],c[d]));r=0===d?h:ue(r,h),i.push(r)}for(let d=0;d<this.metricsTensors.length;++d){const h=this.metricsTensors[d][1],p=Yn((0,this.metricsTensors[d][0])(o[h],c[h]));i.push(p)}return i})}fit(e,i,r={}){var s=this;return ie(function*(){if(s.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let o,a,l,c,d,u,h,p,f;s.isTraining=!0;try{const m=null==r.batchSize?32:r.batchSize;hA(m);const g=!1,_=yield s.standardizeUserData(e,i,r.sampleWeight,r.classWeight,g,m);o=_[0],a=_[1],f=_[2];let y,b=!1;if(null!=r.validationData&&r.validationData.length>0){if(b=!0,2!==r.validationData.length)throw 3===r.validationData.length?new et("validationData including sample weights is not supported yet."):new R(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);d=r.validationData[0],u=r.validationData[1];const A=!0,$=yield s.standardizeUserData(d,u,null,null,A,m);h=$[0],p=$[1],y=h.concat(p)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){b=!0;const A=Math.floor(o[0].shape[0]*(1-r.validationSplit)),$=o[0].shape[0];h=Sg(o,A,$),l=o,o=Sg(o,0,A),p=Sg(a,A,$),c=a,a=Sg(a,0,A),y=h.concat(p)}else null!=r.validationSteps&&(b=!0);const v=o.concat(a).concat(f);s.checkTrainableWeightsConsistency();const x=s.makeTrainFunction(),w=s.getDedupedMetricsNames();let C,D;b?(s.makeTestFunction(),C=s.testFunction,D=w.slice().concat(w.map(A=>"val_"+A))):(C=null,y=[],D=w.slice());const k=jW(r.callbacks,r.yieldEvery);return yield s.fitLoop(x,v,w,m,r.epochs,r.verbose,k,C,y,r.shuffle,D,r.initialEpoch,null,null)}finally{s.isTraining=!1,ko(o,e),ko(a,i),ko(l,e),ko(c,i),ko(h,d),ko(p,u),null!=f&&mt(f)}})()}fitLoop(e,i,r,s,o,a,l,c,d,u,h,p,f,m){var g=this;return ie(function*(){null==s&&(s=32),null==o&&(o=1),null==u&&(u=!0),null==p&&(p=0);let _=!1;if(null!=c&&null!=d&&(_=!0),null!=m&&(_=!0,null==f))throw new R("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=g.checkNumSamples(i,s,f,"steps_per_epoch");let y;null!=b&&(y=wo(0,b)),null==a&&(a=1);const{callbackList:v,history:x}=WW(l,a,o,p,b,f,s,_,h);v.setModel(g),g.history=x,yield v.onTrainBegin(),g.stopTraining_=!1;for(let w=p;w<o;++w){yield v.onEpochBegin(w);const C={};if(null!=f)throw new et("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new et("batch shuffling is not implemneted yet");u&&wH(y);const D=gr(y),k=fA(b,s);for(let I=0;I<k.length;++I){const A={};if(yield v.onBatchBegin(I,A),G(()=>{const $=k[I][0],H=k[I][1],W=md(D,$,H-$);A.batch=I,A.size=H-$;const z=pA(i,W),M=e(z);for(let F=0;F<r.length;++F){const j=M[F];A[r[F]]=j,Jo(j)}if(I===k.length-1&&_){const F=g.testLoop(c,d,s);for(let L=0;L<r.length;++L){const j=r[L],Z=F[L];Jo(Z),C["val_"+j]=Z}}}),yield v.onBatchEnd(I,A),HW(A),g.stopTraining_)break}D.dispose()}if(yield v.onEpochEnd(w,C),g.stopTraining_)break}return yield v.onTrainEnd(),yield g.history.syncData(),g.history})()}fitDataset(e,i){var r=this;return ie(function*(){return function z1e(n,t,e){return dA.apply(this,arguments)}(r,e,i)})()}trainOnBatch(e,i){var r=this;return ie(function*(){const s=yield r.standardizeUserData(e,i),o=s[0],a=s[1],c=r.makeTrainFunction()(o.concat(a)),d=[];for(const u of c){const h=yield u.data();d.push(h[0])}return mt(c),ko(s[0],e),ko(s[1],i),Pr(d)})()}getNamedWeights(e){const i=[],r=null!=e&&e.trainableOnly,s=r?this.trainableWeights:this.weights,o=this.getWeights(r);for(let a=0;a<s.length;++a)r&&!s[a].trainable||i.push({name:s[a].originalName,tensor:o[a]});return i}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const i=k1().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=i-k1().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Ya(this.loss);else if(Array.isArray(this.loss)){for(const i of this.loss)if("string"!=typeof i)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(i=>Ya(i))}else{const i=Object.keys(this.loss);e={};const r=this.loss;for(const s of i){if("string"!=typeof r[s])throw new Error("Serialization of non-string loss is not supported.");e[s]=Ya(r[s])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Ya(h0(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ya(h0(e)));{const e={};for(const i in this.metrics)e[i]=Ya(h0(this.metrics[i]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const r=aa(f0(e.optimizer_config));let s,o;if("string"==typeof e.loss)s=hd(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(a=>hd(a));else if(null!=e.loss){s={};for(const a in e.loss)s[a]=hd(e.loss[a])}if(Array.isArray(e.metrics))o=e.metrics.map(a=>hd(a));else if(null!=e.metrics){o={};for(const a in e.metrics)o[a]=hd(e.metrics[a])}this.compile({loss:s,metrics:o,optimizer:r})}save(e,i){var r=this;return ie(function*(){if("string"==typeof e){const u=(n=>Nn.getSaveHandlers(n))(e);if(0===u.length)throw new R(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new R(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(null==e.save)throw new R("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=yield l4(r.getNamedWeights(i)),c={modelTopology:r.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.2.0",convertedBy:null};if(null!=i&&i.includeOptimizer&&null!=r.optimizer){c.trainingConfig=r.getTrainingConfig();const u="optimizer",{data:h,specs:p}=yield l4(yield r.optimizer.getWeights(),u);s.specs.push(...p),s.data=m1([s.data,h])}return null!=r.userDefinedMetadata&&(JW(r.userDefinedMetadata,r.name,!0),c.userDefinedMetadata=r.userDefinedMetadata),c.weightData=s.data,c.weightSpecs=s.specs,e.save(c)})()}setUserDefinedMetadata(e){JW(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();function _A(){return _A=ie(function*(n,t){if(null==t&&(t={}),"string"==typeof n){const e=Zve(n,t);if(0===e.length)e.push(function Bxe(n,t){return F4(n,t)}(n,t));else if(e.length>1)throw new R(`Found more than one (${e.length}) load handlers for URL '${n}'`);n=e[0]}return function Z1e(n,t,e){return bA.apply(this,arguments)}(n,void 0,t)}),_A.apply(this,arguments)}function bA(){return bA=ie(function*(n,t,e){if(null==e&&(e={}),null==n.load)throw new R("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const i=yield n.load();let r=i.modelTopology;null!=r.model_config&&(r=r.model_config);const s=null==e.strict||e.strict,o=null!=i.weightData&&null!=i.weightSpecs&&s,a=aa(f0(r),t,o),l=i.trainingConfig;if(null!=l&&a.loadTrainingConfig(l),null!=i.userDefinedMetadata&&a.setUserDefinedMetadata(i.userDefinedMetadata),null!=i.weightData){if(null==i.weightSpecs)throw new R("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:c,optimizerWeights:d}=function Q1e(n,t){const e=function c4(n,t){const e={};let i,r=0;for(const s of t){const o=s.name,a=s.dtype,l=s.shape,c=K(l);let d;if("quantization"in s){const u=s.quantization;if("uint8"===u.dtype||"uint16"===u.dtype){if(!("min"in u)||!("scale"in u))throw new Error(`Weight ${s.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==u.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${s.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${a}.`)}const h=h1[u.dtype],p=n.slice(r,r+c*h),f="uint8"===u.dtype?new Uint8Array(p):new Uint16Array(p);if("float32"===a)if("uint8"===u.dtype||"uint16"===u.dtype){d=new Float32Array(f.length);for(let m=0;m<f.length;m++)d[m]=f[m]*u.scale+u.min}else{if("float16"!==u.dtype)throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);void 0===i&&(i=Kve()),d=i(f)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);if("uint8"!==u.dtype&&"uint16"!==u.dtype)throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);d=new Int32Array(f.length);for(let m=0;m<f.length;m++)d[m]=Math.round(f[m]*u.scale+u.min)}r+=c*h}else if("string"===a){const u=K(s.shape);d=[];for(let h=0;h<u;h++){const p=new Uint32Array(n.slice(r,r+Dx))[0];r+=Dx;const f=new Uint8Array(n.slice(r,r+p));d.push(f),r+=p}}else{const u=h1[a],h=n.slice(r,r+c*u);if("float32"===a)d=new Float32Array(h);else if("int32"===a)d=new Int32Array(h);else if("bool"===a)d=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);{d=new Float32Array(h);const p=new Float32Array(d.length/2),f=new Float32Array(d.length/2);for(let _=0;_<p.length;_++)p[_]=d[2*_],f[_]=d[2*_+1];const m=Jm(p,l,"float32"),g=Jm(f,l,"float32");e[o]=Jc(m,g),m.dispose(),g.dispose()}}r+=c*u}"complex64"!==a&&(e[o]=Jm(d,l,a))}return e}(n,t),i={},r=[];return t.forEach(s=>{"optimizer"===s.group?r.push({name:s.name,tensor:e[s.name]}):i[s.name]=e[s.name]}),{modelWeights:i,optimizerWeights:r}}(i.weightData,i.weightSpecs);a.loadWeights(c,s),null!=a.optimizer&&d.length>0&&(yield a.optimizer.setWeights(d)),mt(c),mt(d.map(u=>u.tensor))}return a}),bA.apply(this,arguments)}ce(bh),ce((()=>{class n extends bh{}return n.className="Functional",n})());let uG=(()=>{class n extends bh{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Xx("sequential_"),null!=e.layers)for(const i of e.layers)this.add(i)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new R(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const i=e instanceof n||e instanceof bh;let r;if(i){if(r=e,1!==r.outputs.length)throw new R("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==r.inputs.length)throw new R("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new R("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=function VW(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new R("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new xg({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(i)this.outputs=r.outputs,this.inputs=r.inputs;else{if(1!==e.inboundNodes.length)throw new R(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new R("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=$W(this.outputs[0])}this.inboundNodes=[],new n0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ud(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,i){return null==this.model&&this.build(),this.model.call(e,i)}build(e){if(Bt(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new bh({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,i,r=console.log){this.built||this.build(),super.summary(e,i,r)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,i,r={}){if(!this.built)throw new Ys("The model needs to be compiled before being used.");return this.model.evaluate(e,i,r)}evaluateDataset(e,i){var r=this;return ie(function*(){if(!r.built)throw new Ys("The model needs to be compiled before being used.");return r.model.evaluateDataset(e,i)})()}predict(e,i={}){return null==this.model&&this.build(),this.model.predict(e,i)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,i,r={}){var s=this;return ie(function*(){if(!s.built)throw new Ys("The model needs to be compiled before being used.");return s.model.fit(e,i,r)})()}fitDataset(e,i){var r=this;return ie(function*(){if(!r.built)throw new Ys("The model needs to be compiled before being used.");return r.model.fitDataset(e,i)})()}trainOnBatch(e,i){var r=this;return ie(function*(){return r.model.trainOnBatch(e,i)})()}static fromConfig(e,i,r={},s=!1){let o,a={};if(i instanceof Array){if(null==i[0].className||"Merge"===i[0].className)throw new R("Legacy serialization format not supported yet.");o=i}else S(null!=i.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=i.layers,delete i.layers,a=i;const l=new e(a);if(!(l instanceof n))throw new et(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const c of o){const u=aa(c,void 0,s);s&&u.setFastWeightInitDuringBuild(!0),l.add(u)}return l}set stopTraining(e){if(null==this.model)throw new R("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new R("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const i of this.layers){const r={};r.className=i.getClassName(),r.config=i.getConfig(),e.push(r)}return{name:this.name,layers:e}}}return n.className="Sequential",n})();ce(uG);class Lr extends ah{getConfig(){return{}}}ce((()=>{class n extends Lr{apply(e,i=1){return function zIe(n,t=1){if(1!==t)throw new et(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Nx(n)}(e,i)}}return n.className="elu",n})()),ce((()=>{class n extends Lr{apply(e){return nj(e)}}return n.className="selu",n})()),ce((()=>{class n extends Lr{apply(e){return Wa(e)}}return n.className="relu",n})()),ce((()=>{class n extends Lr{apply(e){return G(()=>Fx(6,Wa(e)))}}return n.className="relu6",n})()),ce((()=>{class n extends Lr{apply(e){return e}}return n.className="linear",n})()),ce((()=>{class n extends Lr{apply(e){return uh(e)}}return n.className="sigmoid",n})()),ce((()=>{class n extends Lr{apply(e){return function HIe(n){return G(()=>{const t=ue(.5,N(.2,n));return fs(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),ce((()=>{class n extends Lr{apply(e){return lg(e)}}return n.className="softplus",n})()),ce((()=>{class n extends Lr{apply(e){return function UIe(n){return G(()=>$e(n,ue(Ii(n),1)))}(e)}}return n.className="softsign",n})()),ce((()=>{class n extends Lr{apply(e){return sT(e)}}return n.className="tanh",n})());let hG=(()=>{class n extends Lr{apply(e,i=-1){return rT(e,i)}}return n.className="softmax",n})();function ql(n){return n.getClassName()}function yA(n,t={}){return gg(n,Us.getMap().classNameMap,t,"activation")}function Yl(n){if(null==n){return yA({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},yA(t)}return n instanceof Lr?n:yA(n)}ce(hG),ce((()=>{class n extends Lr{apply(e,i=-1){return J4(e,i)}}return n.className="logSoftmax",n})()),ce((()=>{class n extends Lr{apply(e,i=1){return G(()=>N(uh(N(e,i)),e))}}return n.className="swish",n})()),ce((()=>{class n extends Lr{apply(e){return G(()=>N(e,sT(lg(e))))}}return n.className="mish",n})());class pG extends ah{}let xA=(()=>{class n extends pG{constructor(e){super(),function vA(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return G(()=>{let i=Mi([1]);return this.hasL1&&(i=ue(i,Ne(N(this.l1,Ii(e))))),this.hasL2&&(i=ue(i,Ne(N(this.l2,yg(e))))),B(i,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,i){return new e({l1:i.l1,l2:i.l2})}}return n.className="L1L2",n})();ce(xA);const fG={l1l2:"L1L2"};function an(n){return WT(n)}function mG(n,t={}){return gg(n,Us.getMap().classNameMap,t,"regularizer")}function En(n){return null==n?null:"string"==typeof n?mG({className:n in fG?fG[n]:n,config:{}}):n instanceof pG?n:mG(n)}let gG=(()=>{class n extends xt{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,i){e=qe(e);let r=Wa(e);return null!=this.maxValue&&(r=fs(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},i=super.getConfig();return Object.assign(e,i),e}}return n.className="ReLU",n})();ce(gG);let _G=(()=>{class n extends xt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,i){const r=qe(e);return G1(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},i=super.getConfig();return Object.assign(e,i),e}}return n.className="LeakyReLU",n})();ce(_G);let bG=(()=>{class n extends xt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=kn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=En(e.alphaRegularizer),this.alphaConstraint=gi(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new R(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const i=(e=Bt(e)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)i[s-1]=1;this.alpha=this.addWeight("alpha",i,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(null!=this.sharedAxes)for(let s=1;s<e.length;++s)r[s]=e[s];this.inputSpec=[new fi({ndim:e.length,axes:r})],this.built=!0}call(e,i){return e=qe(e),Q1(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Fn(this.alphaInitializer),alphaRegularizer:an(this.alphaRegularizer),alphaConstraint:mi(this.alphaConstraint),sharedAxes:this.sharedAxes},i=super.getConfig();return Object.assign(e,i),e}}return n.className="PReLU",n})();ce(bG);let yG=(()=>{class n extends xt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new et(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,i){const r=qe(e);return Nx(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},i=super.getConfig();return Object.assign(e,i),e}}return n.className="ELU",n})();ce(yG);let vG=(()=>{class n extends xt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,i){const r=qe(e);return N(r,be(ms(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},i=super.getConfig();return Object.assign(e,i),e}}return n.className="ThresholdedReLU",n})();ce(vG);let xG=(()=>{class n extends xt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new hG).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,i){const r=qe(e);return this.softmax(r,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},i=super.getConfig();return Object.assign(e,i),e}}return n.className="Softmax",n})();function yh(n,t,e){if("number"==typeof n)return ud(n,t);if(n.length!==t)throw new R(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let i=0;i<t;++i){const r=n[i];if(!FIe(r))throw new R(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function Eo(n,t,e,i,r=1){if(null==n)return n;let o;return o="same"===e?n:n-(t+(t-1)*(r-1))+1,Math.floor((o+i-1)/i)}function la(n,t,e,i){if(null==n)return null;if("valid"===i)n=n*t+jl([e-t,0]);else{if("same"!==i)throw new R(`Unsupport padding mode: ${i}.`);n*=t}return n}function wA(n,t){return G(()=>(Zn(t),"channelsFirst"===t?Mt(n,[0,2,3,1]):n))}function wG(n,t){return G(()=>(Zn(t),"channelsFirst"===t?Mt(n,[0,2,3,4,1]):n))}function CA(n,t,e,i=[1,1],r="valid",s,o,a=null){return G(()=>{if(null==s&&(s="channelsLast"),Zn(s),3!==n.rank&&4!==n.rank)throw new R(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new R(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=wA(n,s);if("causal"===r)throw new et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=sCe({x:l,filter:t,strides:i,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===s&&(l=Mt(l,[0,3,1,2])),l})}ce(xG);class m0 extends xt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",m0.verifyArgs(e),this.rank=t,Ni(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new et(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=yh(e.kernelSize,t,"kernelSize"),this.strides=yh(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,bs(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Zn(this.dataFormat),this.activation=Yl(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=kn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=gi(e.biasConstraint),this.biasRegularizer=En(e.biasRegularizer),this.activityRegularizer=En(e.activityRegularizer),this.dilationRate=yh(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new R(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new R(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new R(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(_s("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!qT(t.kernelSize,"number",1,3))throw new R(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ql(this.activation),useBias:this.useBias,biasInitializer:Fn(this.biasInitializer),biasRegularizer:an(this.biasRegularizer),activityRegularizer:an(this.activityRegularizer),biasConstraint:mi(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class vh extends m0{constructor(t,e){super(t,e),this.kernel=null,vh.verifyArgs(e),this.filters=e.filters,Ni(this.filters,"filters"),this.kernelInitializer=kn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=gi(e.kernelConstraint),this.kernelRegularizer=En(e.kernelRegularizer)}build(t){t=Bt(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new R(`The channel dimension of the input should be defined. Found ${t[e]}`);const i=t[e],r=this.kernelSize.concat([i,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:i}}],this.built=!0}call(t,e){return G(()=>{let i;t=qe(t);const r=null==this.bias?null:this.bias.read(),s=_W(this.activation.getClassName());if(null!=s&&2===this.rank)i=CA(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)i=function CG(n,t,e,i=1,r="valid",s,o=1){return G(()=>{if(null==s&&(s="channelsLast"),Zn(s),3!==n.shape.length)throw new R(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new R(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new R(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(n=Mt(n,[0,2,1])),"causal"===r)throw new et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Y4(n,t,i,"same"===r?"same":"valid","NWC",o);return null!=e&&(a=Do(a,e)),a})}(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)i=CA(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new et("convolutions greater than 3D are not implemented yet.");i=function DG(n,t,e,i=[1,1,1],r="valid",s,o){return G(()=>{if(null==s&&(s="channelsLast"),Zn(s),4!==n.rank&&5!==n.rank)throw new R(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new R(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=wG(n,s);if("causal"===r)throw new et("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=F0e(a,t,i,"same"===r?"same":"valid","NDHWC",o),null!=e&&(a=Do(a,e)),"channelsFirst"===s&&(a=Mt(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(i=this.activation.apply(i))}return i})}computeOutputShape(t){t=Bt(t);const e=[],i="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<i.length;++s){const o=Eo(i[s],this.kernelSize[s],this.padding,this.strides[s],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);e.push(o)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:Fn(this.kernelInitializer),kernelRegularizer:an(this.kernelRegularizer),kernelConstraint:mi(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new R(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let DA=(()=>{class n extends vh{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!qT(e.kernelSize,"number",1,2))throw new R(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();ce(DA);let SA=(()=>{class n extends vh{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new R(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();ce(SA);let SG=(()=>{class n extends DA{constructor(e){if(super(e),this.inputSpec=[new fi({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new R(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Bt(e)).length)throw new R("Input should have rank 4; Received input shape: "+JSON.stringify(e));const i="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[i])throw new R("The channel dimension of the inputs should be defined. Found `None`.");const r=e[i],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new fi({ndim:4,axes:{[i]:r}})],this.built=!0}call(e,i){return G(()=>{let r=qe(e);if(4!==r.shape.length)throw new R(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const d=s[l],h=this.kernelSize[1],f=this.strides[1],_=[s[0],la(s[a],this.strides[0],this.kernelSize[0],this.padding),la(d,f,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=Mt(r,[0,2,3,1]));let b=K4(r,this.kernel.read(),_,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=Mt(b,[0,3,1,2])),null!=this.bias&&(b=Do(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const i=(e=Bt(e)).slice();let r,s,o;"channelsFirst"===this.dataFormat?(r=1,s=2,o=3):(r=3,s=1,o=2);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],d=this.strides[1];return i[r]=this.filters,i[s]=la(i[s],c,a,this.padding),i[o]=la(i[o],d,l,this.padding),i}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})();ce(SG);let kG=(()=>{class n extends SA{constructor(e){if(super(e),this.inputSpec=[new fi({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new R(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Bt(e)).length)throw new R("Input should have rank 5; Received input shape: "+JSON.stringify(e));const i="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[i])throw new R("The channel dimension of the inputs should be defined. Found `None`.");const r=e[i],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new fi({ndim:5,axes:{[i]:r}})],this.built=!0}call(e,i){return G(()=>{let r=qe(e);if(5!==r.shape.length)throw new R(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape;let a,l,c;"channelsFirst"===this.dataFormat?(c=2,a=3,l=4):(c=1,a=2,l=3);const u=s[a],h=s[l],f=this.kernelSize[1],m=this.kernelSize[2],_=this.strides[1],b=this.strides[2],w=[s[0],la(s[c],this.strides[0],this.kernelSize[0],this.padding),la(u,_,f,this.padding),la(h,b,m,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=Mt(r,[0,2,3,4,1]));let C=$0e(r,this.kernel.read(),w,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(C=Mt(C,[0,4,1,2,3])),null!==this.bias&&(C=Do(C,this.bias.read(),this.dataFormat)),null!==this.activation&&(C=this.activation.apply(C)),C})}computeOutputShape(e){const i=(e=Bt(e)).slice();let r,s,o,a;"channelsFirst"===this.dataFormat?(r=1,s=2,o=3,a=4):(r=4,s=1,o=2,a=3);const l=this.kernelSize[0],c=this.kernelSize[1],d=this.kernelSize[2],u=this.strides[0],h=this.strides[1],p=this.strides[2];return i[r]=this.filters,i[s]=la(i[s],u,l,this.padding),i[o]=la(i[o],h,c,this.padding),i[a]=la(i[a],p,d,this.padding),i}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})();ce(kG);let eTe=(()=>{class n extends vh{constructor(e,i){if(super(e,i),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==i.filters)throw new R("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=i.kernelInitializer||null!=i.kernelRegularizer||null!=i.kernelConstraint)throw new R("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=i.padding&&"same"!==i.padding&&"valid"!==i.padding)throw new R(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(i.padding)}`);this.depthMultiplier=null==i.depthMultiplier?1:i.depthMultiplier,this.depthwiseInitializer=kn(i.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=En(i.depthwiseRegularizer),this.depthwiseConstraint=gi(i.depthwiseConstraint),this.pointwiseInitializer=kn(i.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=En(i.pointwiseRegularizer),this.pointwiseConstraint=gi(i.pointwiseConstraint)}build(e){if((e=Bt(e)).length<this.rank+2)throw new R(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const i="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[i]||e[i]<0)throw new R(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[i])}`);const r=e[i],s=this.kernelSize.concat([r,this.depthMultiplier]),o=[];for(let l=0;l<this.rank;++l)o.push(1);o.push(r*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new fi({ndim:this.rank+2,axes:{[i]:r}})],this.built=!0}call(e,i){return G(()=>{let r;if(e=qe(e),1===this.rank)throw new et("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Mt(e,[0,2,3,1])),r=ij(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Do(r,this.bias.read(),this.dataFormat)),null!=this.activation&&(r=this.activation.apply(r)),"channelsFirst"===this.dataFormat&&(r=Mt(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Fn(this.depthwiseInitializer),e.pointwiseInitializer=Fn(this.pointwiseInitializer),e.depthwiseRegularizer=an(this.depthwiseRegularizer),e.pointwiseRegularizer=an(this.pointwiseRegularizer),e.depthwiseConstraint=mi(this.depthwiseConstraint),e.pointwiseConstraint=mi(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})(),EG=(()=>{class n extends eTe{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})();ce(EG);let IG=(()=>{class n extends vh{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!qT(e.kernelSize,"number",1,1))throw new R(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})();ce(IG);let TG=(()=>{class n extends xt{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,i){return G(()=>{if(e=qe(e),"channelsLast"===this.dataFormat){const r=Qx(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Qx(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const r=Qx(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Qx(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(e,i),e}}return n.className="Cropping2D",n})();ce(TG);let AG=(()=>{class n extends xt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Zn(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function NIe(n){pd(IIe,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,i){return G(()=>{let r=qe(e);const s=r.shape;if("channelsFirst"===this.dataFormat){r=Mt(r,[0,2,3,1]);const o=this.size[0]*s[2],a=this.size[1]*s[3],l="nearest"===this.interpolation?cd.resizeNearestNeighbor(r,[o,a]):cd.resizeBilinear(r,[o,a]);return Mt(l,[0,3,1,2])}{const o=this.size[0]*s[1],a=this.size[1]*s[2];return"nearest"===this.interpolation?cd.resizeNearestNeighbor(r,[o,a]):cd.resizeBilinear(r,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},i=super.getConfig();return Object.assign(e,i),e}}return n.className="UpSampling2D",n})();ce(AG);let MG=(()=>{class n extends m0{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=kn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=gi(e.depthwiseConstraint),this.depthwiseRegularizer=En(e.depthwiseRegularizer)}build(e){if((e=Bt(e)).length<4)throw new R(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const i="channelsFirst"===this.dataFormat?1:3;if(null==e[i]||e[i]<0)throw new R(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[i]}).`);const r=e[i];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,i){return G(()=>{let r=function tTe(n,t,e=[1,1],i="valid",r,s){return G(()=>{null==r&&(r="channelsLast"),Zn(r);let o=wA(n,r);if(4!==n.rank)throw new R(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new R(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=Mx(o,t,e,"same"===i?"same":"valid","NHWC",s),"channelsFirst"===r&&(o=Mt(o,[0,3,1,2])),o})}(e=qe(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Do(r,this.bias.read(),this.dataFormat)),null!=this.activation&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=Bt(e);const r="channelsFirst"===this.dataFormat?e[3]:e[2],s="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=Eo("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=Eo(r,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],s,o,a]:[e[0],o,a,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Fn(this.depthwiseInitializer),e.depthwiseRegularizer=an(this.depthwiseRegularizer),e.depthwiseConstraint=mi(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})();function NG(n,t,e,i){if(Array.isArray(n)){if(null!=t||null!=e)throw new R("When inputs is an array, neither initialState or constants should be provided");null!=i&&(e=n.slice(n.length-i,n.length),n=n.slice(0,n.length-i)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function r(s){return null==s||Array.isArray(s)?s:[s]}return{inputs:n,initialState:t=r(t),constants:e=r(e)}}function RG(n,t,e,i=!1,r,s,o=!1,a=!1){return G(()=>{const l=t.shape.length;if(l<3)throw new R(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(wo(2,l));if(t=Mt(t,c),null!=s)throw new et("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=be(be(r,"bool"),"float32")).rank===l-1&&(r=qr(r,-1)),r=Mt(r,c)),i&&(t=ad(t,0),null!=r&&(r=ad(r,0)));const d=[];let u,h=e;const p=t.shape[0],f=ld(t);let m,g;null!=r&&(m=ld(r));for(let _=0;_<p;++_){const b=f[_],y=G(()=>n(b,h));if(null==r)u=y[0],h=y[1];else{const v=G(()=>{const x=m[_],w=Me(Gs(x),x);return{output:ue(N(y[0],x),N(h[0],w)),newStates:h.map((k,I)=>ue(N(y[1][I],x),N(k,w)))}});u=v.output,h=v.newStates}a&&d.push(u)}return a&&(g=zl(d,1)),[u,g,h]})}ce(MG);let xh=(()=>{class n extends xt{constructor(e){let i;if(super(e),null==e.cell)throw new R("cell property is missing for the constructor of RNN.");if(i=Array.isArray(e.cell)?new IA({cells:e.cell}):e.cell,null==i.stateSize)throw new R("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=i,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new fi({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?wo(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(i=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){QT(e)&&(e=e[0]);let i=this.cell.stateSize;Array.isArray(i)||(i=[i]);const r=i[0];let s;if(s=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){const o=[];for(const a of i)o.push([e[0],a]);return[s].concat(o)}return s}computeMask(e,i){return G(()=>{Array.isArray(i)&&(i=i[0]);const r=this.returnSequences?i:null;if(this.returnState){const s=this.states.map(o=>null);return[r].concat(s)}return r})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,i=[];for(let r=0;r<e;++r)i.push(null);return i}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new et("Constants support is not implemented in RNN yet.");QT(e)&&(e=e[0]);const r=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new fi({shape:[r,null,...s]});const o=[e[0]].concat(e.slice(2));let a;if(this.cell.build(o),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Ut(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new R(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new fi({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,i=!1){G(()=>{if(!this.stateful)throw new na("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(null==r)throw new R("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>Mi([r,s])):[Mi([r,this.cell.stateSize])];else if(null==e)mt(this.states_),null!=this.keptStates&&(mt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Mi([r,s])):this.states_[0]=Mi([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new R(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===i?this.keptStates.push(this.states_.slice()):mt(this.states_);for(let s=0;s<this.states_.length;++s){const o=e[s],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,l=[r,a];if(!Ut(o.shape,l))throw new R(`State ${s} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${o.shape}`);this.states_[s]=o}}this.states_=this.states_.map(s=>Jo(s.clone()))})}apply(e,i){let r=null==i?null:i.initialState,s=null==i?null:i.constants;null==i&&(i={});const o=NG(e,r,s,this.numConstants);e=o.inputs,r=o.initialState,s=o.constants;let a=[],l=[];if(null!=r){i.initialState=r,a=a.concat(r),this.stateSpec=[];for(const d of r)this.stateSpec.push(new fi({shape:d.shape}));l=l.concat(this.stateSpec)}if(null!=s&&(i.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof oa){const d=[e].concat(a),u=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=u;const p=super.apply(d,i);return this.inputSpec=h,p}return super.apply(e,i)}call(e,i){return G(()=>{const r=null==i?null:i.mask,s=null==i?null:i.training;let o=null==i?null:i.initialState;e=qe(e),null==o&&(o=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new R(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:s},d=RG((m,g)=>{const _=this.cell.call([m].concat(g),l);return[_[0],_.slice(1)]},e,o,this.goBackwards,r,null,this.unroll,this.returnSequences),u=d[0],h=d[1],p=d[2];this.stateful&&this.resetStates(p,s);const f=this.returnSequences?h:u;return this.returnState?[f].concat(p):f})}getInitialState(e){return G(()=>{let i=Mi(e.shape);return i=Ne(i,[1,2]),i=bg(i),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?XT(i,[1,r]):i):this.cell.stateSize>1?[XT(i,[1,this.cell.stateSize])]:[i]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),i={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(i.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===n.className&&(i.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),i)}static fromConfig(e,i,r={}){const o=aa(i.cell,r);return new e(Object.assign(i,{cell:o}))}}return n.className="RNN",n})();ce(xh);class g0 extends xt{}let kA=(()=>{class n extends g0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ni(this.units,"units"),this.activation=Yl(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=kn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=En(e.kernelRegularizer),this.recurrentRegularizer=En(e.recurrentRegularizer),this.biasRegularizer=En(e.biasRegularizer),this.kernelConstraint=gi(e.kernelConstraint),this.recurrentConstraint=gi(e.recurrentConstraint),this.biasConstraint=gi(e.biasConstraint),this.dropout=gh([1,jl([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gh([1,jl([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Bt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,i){return G(()=>{if(2!==e.length)throw new R(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const s=null!=i.training&&i.training;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Kl({ones:()=>Gs(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Kl({ones:()=>Gs(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;o=ra(null!=a?N(e,a):e,this.kernel.read()),null!=this.bias&&(o=Do(o,this.bias.read())),null!=l&&(r=N(r,l));let c=ue(o,ra(r,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),i={units:this.units,activation:ql(this.activation),useBias:this.useBias,kernelInitializer:Fn(this.kernelInitializer),recurrentInitializer:Fn(this.recurrentInitializer),biasInitializer:Fn(this.biasInitializer),kernelRegularizer:an(this.kernelRegularizer),recurrentRegularizer:an(this.recurrentRegularizer),biasRegularizer:an(this.biasRegularizer),activityRegularizer:an(this.activityRegularizer),kernelConstraint:mi(this.kernelConstraint),recurrentConstraint:mi(this.recurrentConstraint),biasConstraint:mi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),i)}}return n.className="SimpleRNNCell",n})();ce(kA);let OG=(()=>{class n extends xh{constructor(e){e.cell=new kA(e),super(e)}call(e,i){return G(()=>(null!=this.cell.dropoutMask&&(mt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==i?null:i.mask,training:null==i?null:i.training,initialState:null==i?null:i.initialState})))}static fromConfig(e,i){return new e(i)}}return n.className="SimpleRNN",n})();ce(OG);let EA=(()=>{class n extends g0{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new R("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ni(this.units,"units"),this.activation=Yl(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Yl(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=kn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=En(e.kernelRegularizer),this.recurrentRegularizer=En(e.recurrentRegularizer),this.biasRegularizer=En(e.biasRegularizer),this.kernelConstraint=gi(e.kernelConstraint),this.recurrentConstraint=gi(e.recurrentConstraint),this.biasConstraint=gi(e.biasConstraint),this.dropout=gh([1,jl([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gh([1,jl([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Bt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,i){return G(()=>{if(2!==e.length)throw new R(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=null!=i.training&&i.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Kl({ones:()=>Gs(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Kl({ones:()=>Gs(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,c,d;0<this.dropout&&this.dropout<1&&(e=N(e,this.dropoutMask[0]));let u=ra(e,this.kernel.read());this.useBias&&(u=Do(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=N(s,a[0]));const h=this.recurrentKernel.read(),[p,f]=gs(h,[2*this.units,this.units],h.rank-1),m=ra(s,p),[g,_,b]=gs(u,3,u.rank-1),[y,v]=gs(m,2,m.rank-1);l=this.recurrentActivation.apply(ue(g,y)),c=this.recurrentActivation.apply(ue(_,v));const x=ra(N(c,s),f);d=this.activation.apply(ue(b,x));const w=ue(N(l,s),N(ue(1,On(l)),d));return[w,w]})}getConfig(){const e=super.getConfig(),i={units:this.units,activation:ql(this.activation),recurrentActivation:ql(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Fn(this.kernelInitializer),recurrentInitializer:Fn(this.recurrentInitializer),biasInitializer:Fn(this.biasInitializer),kernelRegularizer:an(this.kernelRegularizer),recurrentRegularizer:an(this.recurrentRegularizer),biasRegularizer:an(this.biasRegularizer),activityRegularizer:an(this.activityRegularizer),kernelConstraint:mi(this.kernelConstraint),recurrentConstraint:mi(this.recurrentConstraint),biasConstraint:mi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),i)}}return n.className="GRUCell",n})();ce(EA);let FG=(()=>{class n extends xh{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new EA(e),super(e)}call(e,i){return G(()=>(null!=this.cell.dropoutMask&&(mt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==i?null:i.mask,training:null==i?null:i.training,initialState:null==i?null:i.initialState})))}static fromConfig(e,i){return 0===i.implmentation&&(i.implementation=1),new e(i)}}return n.className="GRU",n})();ce(FG);let _0=(()=>{class n extends g0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ni(this.units,"units"),this.activation=Yl(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Yl(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=kn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=En(e.kernelRegularizer),this.recurrentRegularizer=En(e.recurrentRegularizer),this.biasRegularizer=En(e.biasRegularizer),this.kernelConstraint=gi(e.kernelConstraint),this.recurrentConstraint=gi(e.recurrentConstraint),this.biasConstraint=gi(e.biasConstraint),this.dropout=gh([1,jl([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gh([1,jl([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var i;let s;if(e=Bt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;s=new((i=class extends Xs{apply(c,d){const u=o.apply([a]),h=(new IW).apply([a]),p=o.apply([2*a]);return SW(SW(u,h),p)}}).className="CustomInit",i)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,i){return G(()=>{const r=null!=i.training&&i.training;if(3!==e.length)throw new R(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Kl({ones:()=>Gs(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Kl({ones:()=>Gs(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let c,d,u,h;0<this.dropout&&this.dropout<1&&(e=N(e,this.dropoutMask[0]));let p=ra(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=N(s,l[0])),p=ue(p,ra(s,this.recurrentKernel.read())),this.useBias&&(p=Do(p,this.bias.read()));const[f,m,g,_]=gs(p,4,p.rank-1);c=this.recurrentActivation.apply(f),d=this.recurrentActivation.apply(m),u=ue(N(d,o),N(c,this.activation.apply(g))),h=this.recurrentActivation.apply(_);const b=N(h,this.activation.apply(u));return[b,b,u]})}getConfig(){const e=super.getConfig(),i={units:this.units,activation:ql(this.activation),recurrentActivation:ql(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Fn(this.kernelInitializer),recurrentInitializer:Fn(this.recurrentInitializer),biasInitializer:Fn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:an(this.kernelRegularizer),recurrentRegularizer:an(this.recurrentRegularizer),biasRegularizer:an(this.biasRegularizer),activityRegularizer:an(this.activityRegularizer),kernelConstraint:mi(this.kernelConstraint),recurrentConstraint:mi(this.recurrentConstraint),biasConstraint:mi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),i)}}return n.className="LSTMCell",n})();ce(_0);let PG=(()=>{class n extends xh{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new _0(e),super(e)}call(e,i){return G(()=>(null!=this.cell.dropoutMask&&(mt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==i?null:i.mask,training:null==i?null:i.training,initialState:null==i?null:i.initialState})))}static fromConfig(e,i){return 0===i.implmentation&&(i.implementation=1),new e(i)}}return n.className="LSTM",n})();ce(PG);let IA=(()=>{class n extends g0{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const i of this.cells.slice().reverse())Array.isArray(i.stateSize)?e.push(...i.stateSize):e.push(i.stateSize);return e}call(e,i){return G(()=>{let r=e.slice(1);const s=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?s.push(r.splice(0,l.stateSize.length)):s.push(r.splice(0,1));s.reverse();const o=[];let a;for(let l=0;l<this.cells.length;++l){const c=this.cells[l];r=s[l],a=0===l?[e[0]].concat(r):[a[0]].concat(r),a=c.call(a,i),o.push(a.slice(1))}r=[];for(const l of o.slice().reverse())r.push(...l);return[a[0]].concat(r)})}build(e){let i;QT(e)&&(e=e[0]),this.cells.forEach((r,s)=>{fd(`RNNCell_${s}`,()=>{r.build(e),i=Array.isArray(r.stateSize)?r.stateSize[0]:r.stateSize,e=[e[0],i]})}),this.built=!0}getConfig(){const e=super.getConfig(),s={cells:this.cells.map(o=>({className:o.getClassName(),config:o.getConfig()}))};return Object.assign(Object.assign({},e),s)}static fromConfig(e,i,r={}){const s=[];for(const o of i.cells)s.push(aa(o,r));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const i of this.cells)e.push(...i.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const i of this.cells)e.push(...i.nonTrainableWeights);if(!this.trainable){const i=[];for(const r of this.cells)i.push(...r.trainableWeights);return i.concat(e)}return e}getWeights(){const e=[];for(const i of this.cells)e.push(...i.weights);return JT(e)}setWeights(e){const i=[];for(const r of this.cells){const o=e.splice(r.weights.length);for(let a=0;a<r.weights.length;++a)i.push([r.weights[a],o[a]])}eA(i)}}return n.className="StackedRNNCells",n})();function Kl(n){const{ones:t,rate:e,training:i=!1,count:r=1,dropoutFunc:s}=n,o=()=>null!=s?s(t(),e):EW(t(),e),a=()=>vg(o,t,i);return!r||r<=1?Jo(a().clone()):Array(r).fill(void 0).map(a).map(c=>Jo(c.clone()))}ce(IA);let iTe=(()=>{class n extends xh{constructor(e){if(e.unroll)throw new et("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new et("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new fi({ndim:5})]}call(e,i){return G(()=>{if(null!=this.cell.dropoutMask&&(mt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),i&&i.constants)throw new R("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==i?null:i.mask,training:null==i?null:i.training,initialState:null==i?null:i.initialState})})}computeOutputShape(e){let i=this.computeSingleOutputShape(e);return this.returnSequences||(i=[i[0],...i.slice(2)]),this.returnState&&(i=[i,...Array(2).fill([e[0],...i.slice(-3)])]),i}getInitialState(e){return G(()=>{const{stateSize:i}=this.cell,s=this.computeSingleOutputShape(e.shape),a=Mi([s[0],...s.slice(2)]);return Array.isArray(i)?Array(i.length).fill(a):[a]})}resetStates(e,i=!1){G(()=>{if(!this.stateful)throw new na("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),o=[s[0],...s.slice(2)];if(null==r[0])throw new R("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>Mi(o)):[Mi(o)];else if(null==e)mt(this.states_),null!=this.keptStates&&(mt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Mi(o)):this.states_[0]=Mi(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new R(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);i?this.keptStates.push(this.states_.slice()):mt(this.states_);for(let l=0;l<this.states_.length;++l){const c=e[l],d=o;if(!Ut(c.shape,d))throw new R(`State ${l} is incompatible with layer ${this.name}: expected shape=${d}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>Jo(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:i,filters:r,kernelSize:s,padding:o,strides:a,dilationRate:l}=this.cell,c="channelsFirst"===i,u=e[c?4:3],h=Eo(e[c?3:2],s[0],o,a[0],l[0]),p=Eo(u,s[1],o,a[1],l[1]);return[...e.slice(0,2),...c?[r,h,p]:[h,p,r]]}}return n.className="ConvRNN2D",n})(),TA=(()=>{class n extends _0{constructor(e){const{filters:i,kernelSize:r,strides:s,padding:o,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:i})),this.filters=i,Ni(this.filters,"filters"),this.kernelSize=yh(r,2,"kernelSize"),this.kernelSize.forEach(c=>Ni(c,"kernelSize")),this.strides=yh(s||1,2,"strides"),this.strides.forEach(c=>Ni(c,"strides")),this.padding=o||"valid",bs(this.padding),this.dataFormat=a||"channelsLast",Zn(this.dataFormat),this.dilationRate=yh(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>Ni(c,"dilationRate"))}build(e){var i;e=Bt(e);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new R(`The channel dimension of the input should be defined. Found ${e[r]}`);const a=this.kernelSize.concat([e[r],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const d=this.biasInitializer,u=this.filters;c=new((i=class extends Xs{apply(p,f){return KT([d.apply([u]),Bl([u]),d.apply([2*u])])}}).className="CustomInit",i)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,i){return G(()=>{if(3!==e.length)throw new R(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=i.training||!1,s=e[0],o=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Kl({ones:()=>Gs(s),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,d=(ee,se,re)=>se&&se[re]?N(se[re],ee):ee;let u=d(s,c,0),h=d(s,c,1),p=d(s,c,2),f=d(s,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Kl({ones:()=>Gs(o),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=d(o,m,0),_=d(o,m,1),b=d(o,m,2),y=d(o,m,3);const[x,w,C,D]=gs(this.kernel.read(),4,3),[k,I,A,$]=this.useBias?gs(this.bias.read(),4):[null,null,null,null];u=this.inputConv(u,x,k,this.padding),h=this.inputConv(h,w,I,this.padding),p=this.inputConv(p,C,A,this.padding),f=this.inputConv(f,D,$,this.padding);const[H,W,z,M]=gs(this.recurrentKernel.read(),4,3);g=this.recurrentConv(g,H),_=this.recurrentConv(_,W),b=this.recurrentConv(b,z),y=this.recurrentConv(y,M);const F=this.recurrentActivation.apply(ue(u,g)),L=this.recurrentActivation.apply(ue(h,_)),j=ue(N(L,a),N(F,this.activation.apply(ue(p,b)))),Z=N(this.recurrentActivation.apply(ue(f,y)),this.activation.apply(j));return[Z,Z,j]})}getConfig(){const r=function(n,t){var e={};for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&t.indexOf(i)<0&&(e[i]=n[i]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(i=Object.getOwnPropertySymbols(n);r<i.length;r++)t.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(n,i[r])&&(e[i[r]]=n[i[r]])}return e}(super.getConfig(),["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),s)}inputConv(e,i,r,s){const o=sd(e,i,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return r?Do(o,r,this.dataFormat):o}recurrentConv(e,i){return sd(e,i,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();ce(TA);let LG=(()=>{class n extends iTe{constructor(e){const i=new TA(e);super(Object.assign(Object.assign({},e),{cell:i}))}static fromConfig(e,i){return new e(i)}}return n.className="ConvLSTM2D",n})();ce(LG);let AA=(()=>{class n extends xt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const i=e.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(null==this.noiseShape[s]?i[s]:this.noiseShape[s]);return r}call(e,i){return G(()=>{this.invokeCallHook(e,i);const r=qe(e);if(0<this.rate&&this.rate<1){const s=null!=i.training&&i.training,o=this.getNoiseShape(r);return vg(()=>EW(r,this.rate,o,this.seed),()=>r,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},i=super.getConfig();return Object.assign(e,i),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();ce(AA);let $G=(()=>{class n extends AA{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const i=e.shape;return[i[0],1,i[2]]}}return n.className="SpatialDropout1D",n})();ce($G);let VG=(()=>{class n extends xt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let i=null;null!=e.batchSize&&(i=e.batchSize),this.batchInputShape=[i,e.inputDim]}this.units=e.units,Ni(this.units,"units"),this.activation=Yl(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=kn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=kn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=gi(e.kernelConstraint),this.biasConstraint=gi(e.biasConstraint),this.kernelRegularizer=En(e.kernelRegularizer),this.biasRegularizer=En(e.biasRegularizer),this.activityRegularizer=En(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const i=(e=Bt(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[i,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:i}}],this.built=!0}computeOutputShape(e){const i=(e=Bt(e)).slice();return i[i.length-1]=this.units,i}call(e,i){return G(()=>{this.invokeCallHook(e,i);const r=qe(e),s=_W(this.activation.getClassName());let o;return null!=s?o=ra(r,this.kernel.read(),s,this.bias?this.bias.read():null):(o=ra(r,this.kernel.read()),null!=this.bias&&(o=Do(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:ql(this.activation),useBias:this.useBias,kernelInitializer:Fn(this.kernelInitializer),biasInitializer:Fn(this.biasInitializer),kernelRegularizer:an(this.kernelRegularizer),biasRegularizer:an(this.biasRegularizer),activityRegularizer:an(this.activityRegularizer),kernelConstraint:mi(this.kernelConstraint),biasConstraint:mi(this.biasConstraint)},i=super.getConfig();return Object.assign(e,i),e}}return n.className="Dense",n})();ce(VG);let BG=(()=>{class n extends xt{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Bt(e);for(const i of e.slice(1))if(null==i)throw new R(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Hl(e,1)]}call(e,i){return G(()=>{this.invokeCallHook(e,i);let r=qe(e);if("channelsFirst"===this.dataFormat&&r.rank>1){const s=[0];for(let o=2;o<r.rank;++o)s.push(o);s.push(1),r=Mt(r,s)}return function BIe(n){if(n.rank<=1)throw new R(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],Hl(n.shape,1)];return B(n,t)}(r)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const i=super.getConfig();return Object.assign(e,i),e}}return n.className="Flatten",n})();ce(BG);let zG=(()=>{class n extends xt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Yl(e.activation)}call(e,i){return G(()=>{this.invokeCallHook(e,i);const r=qe(e);return this.activation.apply(r)})}getConfig(){const e={activation:ql(this.activation)},i=super.getConfig();return Object.assign(e,i),e}}return n.className="Activation",n})();ce(zG);let UG=(()=>{class n extends xt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,i){return G(()=>function $Ie(n,t){return G(()=>{if(2!==n.shape.length)throw new R(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return XT(bg(n,1),[1,t,1])})}(e=qe(e),this.n))}getConfig(){const e={n:this.n},i=super.getConfig();return Object.assign(e,i),e}}return n.className="RepeatVector",n})();ce(UG);let HG=(()=>{class n extends xt{constructor(e){super(e),this.targetShape=e.targetShape;for(let i=0;i<this.targetShape.length;++i)this.isUnknown(this.targetShape[i])&&(this.targetShape[i]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,i){const r="Total size of new array must be unchanged.",s=i.slice();let o=1,a=null;for(let c=0;c<s.length;++c){const d=s[c];if(this.isUnknown(d)){if(null!==a)throw new R("Can only specifiy one unknown dimension.");a=c}else o*=d}const l=Hl(e);if(null!==a){if(0===o||l%o!=0)throw new R(r);s[a]=l/o}else if(l!==o)throw new R(r);return s}computeOutputShape(e){let i=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){i=!0;break}return i?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,i){return G(()=>{this.invokeCallHook(e,i);const r=qe(e),s=r.shape,o=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return B(r,o)})}getConfig(){const e={targetShape:this.targetShape},i=super.getConfig();return Object.assign(e,i),e}}return n.className="Reshape",n})();ce(HG);let jG=(()=>{class n extends xt{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const i=wo(1,e.dims.length+1);if(!Ut(e.dims.slice().sort(),i))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new fi({ndim:this.dims.length+1})]}computeOutputShape(e){const i=(e=Bt(e)).slice();return this.dims.forEach((r,s)=>{i[s+1]=e[r]}),i}call(e,i){return Mt(qe(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},i=super.getConfig();return Object.assign(e,i),e}}return n.className="Permute",n})();ce(jG);let WG=(()=>{class n extends xt{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),i={maskValue:this.maskValue};return Object.assign(i,e),i}computeMask(e,i){const r=qe(e);return B1(og(r,this.maskValue),-1)}call(e,i){return G(()=>{this.invokeCallHook(e,i);const r=qe(e),a=B1(og(r,this.maskValue),-1,!0);return N(r,be(a,r.dtype))})}}return n.className="Masking",n})();ce(WG);let GG=(()=>{class n extends xt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let i=null;null!=e.batchSize&&(i=e.batchSize),this.batchInputShape=null==e.inputLength?[i,null]:[i].concat(un(e.inputLength))}this.inputDim=e.inputDim,Ni(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ni(this.outputDim,"outputDim"),this.embeddingsInitializer=kn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=En(e.embeddingsRegularizer),this.activityRegularizer=En(e.activityRegularizer),this.embeddingsConstraint=gi(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,i){return G(()=>this.maskZero?(e=qe(e),og(e,Nt(e))):null)}computeOutputShape(e){if(e=Bt(e),null==this.inputLength)return[...e,this.outputDim];const i=un(this.inputLength);if(i.length!==e.length-1)throw new R(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let s=0;s<i.length;++s){const o=i[s],a=e[s+1];if(null!=o&&null!=a&&o!==a)throw new R(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==o&&(i[r]=a),r++}}return[e[0],...i,this.outputDim]}call(e,i){return G(()=>{this.invokeCallHook(e,i);let r=qe(e);"int32"!==r.dtype&&(r=ia(r,"int32"));const s=kW(this.embeddings.read(),B(r,[r.size]));return B(s,Bt(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Fn(this.embeddingsInitializer),embeddingsRegularizer:an(this.embeddingsRegularizer),activityRegularizer:an(this.activityRegularizer),embeddingsConstraint:mi(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},i=super.getConfig();return Object.assign(e,i),e}}return n.className="Embedding",n})();ce(GG);class gd extends xt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new et}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const i=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const s=t[t.length-e.length+r],o=e[r];if(null==s||null==o||s<0||o<0)i.push(null);else if(1===s)i.push(o);else if(1===o)i.push(s);else{if(s!==o)throw new R("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));i.push(s)}}return i}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Bt(t)]),t.length<2)throw new R(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const s of t)null!=s&&null!==s[0]&&e.push(s[0]);if(e=Ul(e),e.length>1)throw new R(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let i=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const o=null==t[s]?null:t[s].slice(1);i=this.computeElementwiseOpOutputShape(i,o)}const r=t.map(s=>s.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==Ul(r).length}call(t,e){return G(()=>{if(this.reshapeRequired){const i=[],r=t.map(s=>s.rank);if(-1===r.indexOf(null)){const s=jl(r);for(let o of t){const a=o.rank;for(let l=0;l<s-a;++l)o=bg(o,1);i.push(o)}return this.mergeFunction(i)}{let s=!1;for(const l of t){const c=l.rank;if(null==c){const d=l.shape,u=d[0],h=d.slice(1).concat([u]);let p=B(l,[u].concat(Hl(d.slice(1))));p=Mt(p,[1,0]),p=B(p,h),i.push(p),s=!0}else if(c>1){const d=wo(1,c).concat([0]);i.push(Mt(l,d)),s=!0}else i.push(l)}let o=this.mergeFunction(i);const a=o.rank;if(s)if(null==a){const l=o.shape,d=l[l.length-1],u=[d].concat(l.slice(0,l.length-1));o=B(Mt(B(o,[-1,d]),[1,0]),u)}else if(a>1){const l=[a-1].concat(wo(0,a-1));o=Mt(o,l)}return o}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const s=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let i=[];for(const r of t)null!=r&&null!==r[0]&&i.push(r[0]);return i=Ul(i),e=1===i.length?i.concat(e):[null].concat(e),e}computeMask(t,e){return G(()=>{if(null==e)return null;if(!Array.isArray(e))throw new R("`mask` should be an Array");if(!Array.isArray(t))throw new R("`inputs` should be an Array");if(e.length!==t.length)throw new R(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>null==r))return null;let i=(e=e.map(r=>null==r?r:qr(r,0)))[0];for(let r=1;r<e.length-1;++r)i=ja(i,e[r]);return i})}}let b0=(()=>{class n extends gd{constructor(e){super(e)}mergeFunction(e){return G(()=>{let i=e[0].clone();for(let r=1;r<e.length;++r)i=ue(i,e[r]);return i})}}return n.className="Add",n})();ce(b0);let y0=(()=>{class n extends gd{constructor(e){super(e)}mergeFunction(e){return G(()=>{let i=e[0].clone();for(let r=1;r<e.length;++r)i=N(i,e[r]);return i})}}return n.className="Multiply",n})();ce(y0);let v0=(()=>{class n extends gd{constructor(e){super(e)}mergeFunction(e){return G(()=>{let i=e[0].clone();for(let r=1;r<e.length;++r)i=ue(i,e[r]);return N(1/e.length,i)})}}return n.className="Average",n})();ce(v0);let x0=(()=>{class n extends gd{constructor(e){super(e)}mergeFunction(e){return G(()=>{let i=e[0];for(let r=1;r<e.length;++r)i=Pl(i,e[r]);return i})}}return n.className="Maximum",n})();ce(x0);let w0=(()=>{class n extends gd{constructor(e){super(e)}mergeFunction(e){return G(()=>{let i=e[0];for(let r=1;r<e.length;++r)i=Fx(i,e[r]);return i})}}return n.className="Minimum",n})();ce(w0);let C0=(()=>{class n extends gd{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new R("A `Concatenate` layer should be called on a list of at least 2 inputs");let i=!0;for(const s of e)if(null!=s){i=!1;break}if(i)return;const r=[];for(let s=0;s<e.length;++s){const o=e[s].slice();o.splice(this.axis,1);let a=!1;for(const l of r)if(Ut(l,o)){a=!0;break}a||r.push(o)}if(r.length>1)throw new R("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return G(()=>KT(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new R("A `Concatenate` layer should be called on a list of inputs.");const i=e,r=i[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const o of i.slice(1)){if(null==r[s]||null==o[s]){r[s]=null;break}r[s]+=o[s]}return r}computeMask(e,i){if(null==i)return null;if(!Array.isArray(i))throw new R("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new R("`inputs` should be an array for Concatenate");if(i.length!==e.length)throw new R(`Mismatch in the length of mask (${i.length}) and the legnth of inputs (${e.length})`);return G(()=>{let r=!0;if(i.forEach(a=>{null==a||(r=!1)}),r)return null;const s=[];for(let a=0;a<e.length;++a)s.push(null==i[a]?be(Gs(e[a]),"bool"):i[a].rank<e[a].rank?qr(i[a],-1):i[a]);const o=Qi(s,this.axis);return q4(o,-1,!1)})}getConfig(){const e={axis:this.axis},i=super.getConfig();return Object.assign(e,i),e}}return n.className="Concatenate",n})();function kg(n,t){for(;n<0;)n+=t;return n}ce(C0);let qG=(()=>{class n extends gd{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const i=e[0],r=e[1];if(i.length>3||r.length>3)throw new et("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(i,r);if(i[s[0]]!==r[s[1]])throw new R(`Dimension incompatibility: ${i[s[0]]} !== ${r[s[1]]}`)}mergeFunction(e){if(2!==e.length)throw new R(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let s,i=e[0],r=e[1];return s=Array.isArray(this.axes)?this.axes.map((o,a)=>kg(o,e[a].shape.length)):[kg(this.axes,i.shape.length),kg(this.axes,r.shape.length)],this.normalize&&(i=o0(i,s[0]),r=o0(r,s[1])),function rTe(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new et("batchDot is not implemented for tensors of 4D or higher rank yet");if(S(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),S(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new et("batchDot is not implemented for complex64-type Tensors yet.");const i=n.shape.length,r=t.shape.length;null==e&&(e=[i-1,r-2]);const s=e;return G(()=>{let o,a;if(i>r){o=i-r;const l=[];for(let c=0;c<o;++c)l.push(1);t=B(t,t.shape.concat(l))}else if(r>i){o=r-i;const l=[];for(let c=0;c<o;++c)l.push(1);n=B(n,n.shape.concat(l))}else o=0;if(a=2===n.shape.length&&2===t.shape.length?s[0]===s[1]?Ne(N(n,t),s[0]):Ne(N(Mt(n,[1,0]),t),s[1]):Ht(n,t,s[0]!==n.shape.length-1,s[1]===t.shape.length-1),o>0){let l;l=i>r?i+r-3:i-1;const c=[];for(let d=l;d<l+o;++d)c.push(d);a=cg(a,c)}return 1===a.shape.length&&(a=qr(a,1)),a})}(i,r,s)}interpretAxes(e,i){let r;return r=Array.isArray(this.axes)?this.axes:[kg(this.axes,e.length),kg(this.axes,i.length)],r}computeOutputShape(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const i=e[0].slice(),r=e[1].slice();if(i.length>3||r.length>3)throw new et("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(i,r);i.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const o=i.concat(r);return 1===o.length&&o.push(1),o}computeMask(e,i){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},i=super.getConfig();return Object.assign(e,i),e}}return n.className="Dot",n})();ce(qG);let YG=(()=>{class n extends xt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),i={stddev:this.stddev};return Object.assign(i,e),i}call(e,i){return G(()=>{this.invokeCallHook(e,i);const r=qe(e);return vg(()=>ue(Jx(r.shape,0,this.stddev),r),()=>r,i.training||!1)})}}return n.className="GaussianNoise",n})();ce(YG);let KG=(()=>{class n extends xt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),i={rate:this.rate};return Object.assign(i,e),i}call(e,i){return G(()=>{this.invokeCallHook(e,i);const r=qe(e);return this.rate>0&&this.rate<1?vg(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return N(r,Jx(r.shape,1,o))},()=>r,i.training||!1):r})}}return n.className="GaussianDropout",n})();ce(KG);let XG=(()=>{class n extends xt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||qe(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),i={rate:this.rate};return Object.assign(i,e),i}call(e,i){return G(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return vg(()=>{const o=qe(e),c=-1.7580993408473766;let d=od(Px(r),this.rate);d=ia(d,"float32");const u=((1-this.rate)*(1+this.rate*c**2))**-.5,h=-u*c*this.rate,p=ue(N(o,d),N(ue(d,-1),c));return ue(N(p,u),h)},()=>qe(e),i.training||!1)}return e})}}return n.className="AlphaDropout",n})();function Eg(n,t,e,i,r,s=.001){let o;if(2===n.rank)o=f0e(n,t,e,i,r,s);else if(3===n.rank)o=g0e(n,t,e,i,r,s);else{if(4!==n.rank)throw new et(`batchNormalization is not implemented for array of rank ${n.rank} yet`);o=b0e(n,t,e,i,r,s)}return o}ce(XG);let ZG=(()=>{class n extends xt{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=kn(e.betaInitializer||"zeros"),this.gammaInitializer=kn(e.gammaInitializer||"ones"),this.movingMeanInitializer=kn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=kn(e.movingVarianceInitializer||"ones"),this.betaConstraint=gi(e.betaConstraint),this.gammaConstraint=gi(e.gammaConstraint),this.betaRegularizer=En(e.betaRegularizer),this.gammaRegularizer=En(e.gammaRegularizer)}build(e){e=Bt(e);const i=this.axis>=0?this.axis:this.axis+e.length,r=e[i];if(null==r)throw new R(`Axis ${i} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new fi({ndim:e.length,axes:{[i]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,i){return G(()=>{const r=null!=i.training&&i.training,s=qe(e),o=s.shape,a=o.length,l=wo(0,a),c=this.axis>=0?this.axis:this.axis+a;l.splice(c,1);const d=ud(1,a);d[c]=o[c];const u=l.slice();u.sort();const h=!Ut(u,wo(0,a).slice(0,a-1));if(!r)return(()=>{if(h){const y=B(this.movingMean.read(),d),v=B(this.movingVariance.read(),d),x=this.center?B(this.beta.read(),d):null,w=this.scale?B(this.gamma.read(),d):null;return Eg(s,y,v,x,w,this.epsilon)}return Eg(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[f,m,g]=function aTe(n,t,e,i,r=.001){return Ut(i.slice().sort(),wo(0,n.rank-1))?function sTe(n,t,e,i,r=.001){return G(()=>{const s=X1(n,i),o=s.mean,a=s.variance;return[Eg(n,o,a,e,t,r),o,a]})}(n,t,e,i,r):function oTe(n,t,e,i,r=.001){return G(()=>{const s=X1(n,i),o=s.mean,a=s.variance,l=[];for(const f of wo(0,n.rank))-1!==i.indexOf(f)?l.push(1):l.push(n.shape[f]);const c=B(o,l),d=B(a,l),u=null==t?null:B(t,l),h=null==e?null:B(e,l);return[Eg(n,c,d,h,u,r),o,a]})}(n,t,e,i,r)}(s,this.gamma.read(),this.beta.read(),l,this.epsilon),_=(y,v,x)=>{G(()=>{const w=1-x,C=y.read(),D=N(Me(C,v),w);y.write(Me(C,D))})};return(()=>{_(this.movingMean,m,this.momentum),_(this.movingVariance,g,this.momentum)})(),f})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Fn(this.betaInitializer),gammaInitializer:Fn(this.gammaInitializer),movingMeanInitializer:Fn(this.movingMeanInitializer),movingVarianceInitializer:Fn(this.movingVarianceInitializer),betaRegularizer:an(this.betaRegularizer),gammaRegularizer:an(this.gammaRegularizer),betaConstraint:mi(this.betaConstraint),gammaConstraint:mi(this.gammaConstraint)},i=super.getConfig();return Object.assign(e,i),e}}return n.className="BatchNormalization",n})();ce(ZG);let QG=(()=>{class n extends xt{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const i of this.axis)if(!Number.isInteger(i))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=kn(e.betaInitializer||"zeros"),this.gammaInitializer=kn(e.gammaInitializer||"ones"),this.betaRegularizer=En(e.betaRegularizer),this.gammaRegularizer=En(e.gammaRegularizer),this.supportsMasking=!0}build(e){const i=(e=Bt(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=i);for(const o of this.axis)if(o<0||o>=i)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==Ul(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(o=>e[o]);this.gamma=this.scale?this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,i){const r=qe(e),s=r.shape,o=s.length;return G(()=>{let{mean:l,variance:c}=X1(r,this.axis,!0);const d=ud(1,o);for(const g of this.axis)d[g]=s[g];const u=g=>null!=g&&g.shape.length!==o?B(g,d):g;let h=this.scale?u(this.gamma.read()):null,p=this.center?u(this.beta.read()):null;const f=[],m=[];for(let g=0;g<o;++g)-1!==this.axis.indexOf(g)?(f.push(s[g]),m.push(1)):(f.push(1),m.push(s[g]));return l=vo(l,f),c=vo(c,f),null!=h&&(h=vo(h,m)),null!=p&&(p=vo(p,m)),Eg(r,l,c,p,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Fn(this.betaInitializer),gammaInitializer:Fn(this.gammaInitializer),betaRegularizer:an(this.betaRegularizer),gammaRegularizer:an(this.gammaRegularizer)},i=super.getConfig();return Object.assign(e,i),e}}return n.className="LayerNormalization",n})();ce(QG);let JG=(()=>{class n extends xt{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new R(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let i,r;if("number"==typeof e.padding[0])i=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new R(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(i=e.padding[0],2!==e.padding[1].length)throw new R(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[i,r]}this.inputSpec=[new fi({ndim:4})]}computeOutputShape(e){let i,r;return e=Bt(e),"channelsFirst"===this.dataFormat?(i=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,r=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],i,r]):(i=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,r=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],i,r,e[3]])}call(e,i){return G(()=>function lTe(n,t,e){return G(()=>{if(4!==n.rank)throw new R(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new R("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new R(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let i;return i="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Z1(n,i)})}(qe(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(e,i),e}}return n.className="ZeroPadding2D",n})();function D0(n,t,e,i,r,s){return G(()=>{let o;Zn(r),yW(s),bs(i),null==e&&(e=[1,1]),null==i&&(i="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),n=wA(n,r);const a="same"===i?"same":"valid";return o="max"===s?Y1(n,t,e,a):H1(n,t,e,a),"channelsFirst"===r&&(o=Mt(o,[0,3,1,2])),o})}function e5(n,t,e,i,r,s){return G(()=>{let o;Zn(r),yW(s),bs(i),null==e&&(e=[1,1,1]),null==i&&(i="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),n=wG(n,r);const a="same"===i?"same":"valid";return o="max"===s?awe(n,t,e,a):d0e(n,t,e,a),"channelsFirst"===r&&(o=Mt(o,[0,4,1,2,3])),o})}ce(JG);class t5 extends xt{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new R(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(Ni(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new R(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}Ni(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,bs(this.padding),this.inputSpec=[new fi({ndim:3})]}computeOutputShape(t){const e=Eo((t=Bt(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return G(()=>{this.invokeCallHook(t,e),t=bg(qe(t),2);const i=this.poolingFunction(qe(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return cg(i,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}let n5=(()=>{class n extends t5{constructor(e){super(e)}poolingFunction(e,i,r,s,o){return Zn(o),bs(s),D0(e,i,r,s,o,"max")}}return n.className="MaxPooling1D",n})();ce(n5);let r5=(()=>{class n extends t5{constructor(e){super(e)}poolingFunction(e,i,r,s,o){return Zn(o),bs(s),D0(e,i,r,s,o,"avg")}}return n.className="AveragePooling1D",n})();ce(r5);class s5 extends xt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new R(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Ni(this.poolSize,"poolSize"),Ni(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Zn(this.dataFormat),bs(this.padding),this.inputSpec=[new fi({ndim:4})]}computeOutputShape(t){t=Bt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],i="channelsFirst"===this.dataFormat?t[3]:t[2];return e=Eo(e,this.poolSize[0],this.padding,this.strides[0]),i=Eo(i,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,i]:[t[0],e,i,t[3]]}call(t,e){return G(()=>(this.invokeCallHook(t,e),this.poolingFunction(qe(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}let o5=(()=>{class n extends s5{constructor(e){super(e)}poolingFunction(e,i,r,s,o){return Zn(o),bs(s),D0(e,i,r,s,o,"max")}}return n.className="MaxPooling2D",n})();ce(o5);let a5=(()=>{class n extends s5{constructor(e){super(e)}poolingFunction(e,i,r,s,o){return Zn(o),bs(s),D0(e,i,r,s,o,"avg")}}return n.className="AveragePooling2D",n})();ce(a5);class l5 extends xt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new R(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Ni(this.poolSize,"poolSize"),Ni(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Zn(this.dataFormat),bs(this.padding),this.inputSpec=[new fi({ndim:5})]}computeOutputShape(t){t=Bt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],i="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=Eo(e,this.poolSize[0],this.padding,this.strides[0]),i=Eo(i,this.poolSize[1],this.padding,this.strides[1]),r=Eo(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,i,r]:[t[0],e,i,r,t[4]]}call(t,e){return G(()=>(this.invokeCallHook(t,e),this.poolingFunction(qe(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}let c5=(()=>{class n extends l5{constructor(e){super(e)}poolingFunction(e,i,r,s,o){return Zn(o),bs(s),e5(e,i,r,s,o,"max")}}return n.className="MaxPooling3D",n})();ce(c5);let d5=(()=>{class n extends l5{constructor(e){super(e)}poolingFunction(e,i,r,s,o){return Zn(o),bs(s),e5(e,i,r,s,o,"avg")}}return n.className="AveragePooling3D",n})();ce(d5);class u5 extends xt{constructor(t){super(t),this.inputSpec=[new fi({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new et}}let h5=(()=>{class n extends u5{constructor(e){super(e||{})}call(e,i){return G(()=>{const r=qe(e);return Yn(r,1)})}}return n.className="GlobalAveragePooling1D",n})();ce(h5);let p5=(()=>{class n extends u5{constructor(e){super(e||{})}call(e,i){return G(()=>{const r=qe(e);return xo(r,1)})}}return n.className="GlobalMaxPooling1D",n})();ce(p5);class f5 extends xt{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Zn(this.dataFormat),this.inputSpec=[new fi({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new et}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}let m5=(()=>{class n extends f5{call(e,i){return G(()=>{const r=qe(e);return Yn(r,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})();ce(m5);let g5=(()=>{class n extends f5{call(e,i){return G(()=>{const r=qe(e);return xo(r,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})();ce(g5);class _5 extends xt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,i={}){const s=aa(e.layer,i);delete e.layer;const o={layer:s};return Object.assign(o,e),new t(o)}}let b5=(()=>{class n extends _5{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Bt(e)).length<3)throw new R(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const i=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(i),this.layer.built=!0),super.build(e)}computeOutputShape(e){const i=[(e=Bt(e))[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(i);return[r[0],e[1]].concat(r.slice(1))}call(e,i){return G(()=>RG((a,l)=>[qe(this.layer.call(a,i)),[]],e=qe(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})();ce(b5);let y5=(()=>{class n extends _5{constructor(e){super(e);const i=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=i,this.forwardLayer=aa(r),i.goBackwards=!0!==i.goBackwards;const s={};if(s.className=e.layer.getClassName(),s.config=i,this.backwardLayer=aa(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function cTe(n){pd(MIe,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new et("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const r=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let r,s,o,i=this.forwardLayer.computeOutputShape(e);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),this.returnState&&(o=i.slice(1)),r=i[0],"concat"===this.mergeMode?(r[r.length-1]*=2,s=[r]):s=null==this.mergeMode?[r,r.slice()]:[r],this.returnState?null==this.mergeMode?s.concat(o).concat(o.slice()):[r].concat(o).concat(o.slice()):Pr(s)}apply(e,i){let r=null==i?null:i.initialState,s=null==i?null:i.constants;null==i&&(i={});const o=NG(e,r,s,this.numConstants);if(e=o.inputs,r=o.initialState,s=o.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(null==r||0===r.length)&&null==s)return super.apply(e,i);const a=[],l=[];if(null!=r){const d=r.length;if(d%2>0)throw new R("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");i.initialState=r,a.push(...r);const u=r.map(h=>new fi({shape:h.shape}));this.forwardLayer.stateSpec=u.slice(0,d/2),this.backwardLayer.stateSpec=u.slice(d/2),l.push(...u)}if(null!=s)throw new et("Support for constants in Bidirectional layers is not implemented yet.");const c=a[0]instanceof oa;for(const d of a)if(d instanceof oa!==c)throw new R("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const d=[e].concat(a),u=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=u;const p=super.apply(d,i);return this.inputSpec=h,p}return super.apply(e,i)}call(e,i){return G(()=>{const r=i.initialState;let s,o,a,l;if(null==r)s=this.forwardLayer.call(e,i),o=this.backwardLayer.call(e,i);else{const c=r.slice(0,r.length/2),d=r.slice(r.length/2);s=this.forwardLayer.call(e,Object.assign(i,{initialState:c})),o=this.backwardLayer.call(e,Object.assign(i,{initialState:d}))}return this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(o.slice(1))),s=s[0],o=o[0]),this.returnSequences&&(o=ad(o,1)),"concat"===this.mergeMode?l=KT([s,o]):"sum"===this.mergeMode?l=ue(s,o):"ave"===this.mergeMode?l=N(.5,ue(s,o)):"mul"===this.mergeMode?l=N(s,o):null==this.mergeMode&&(l=[s,o]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){fd(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),fd(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,i){let r;if(Array.isArray(i)&&(i=i[0]),r=this.returnSequences?null==this.mergeMode?[i,i]:i:null==this.mergeMode?[null,null]:null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(r)?r.concat(o).concat(o):[r].concat(o).concat(o)}return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},i=super.getConfig();return Object.assign(e,i),e}static fromConfig(e,i){const r=aa(i.layer);if(delete i.layer,null!=i.numConstants)throw new et("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=i;return s.layer=r,new e(s)}}return n.className="Bidirectional",n})();ce(y5);let v5=(()=>{class n extends xt{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},i=super.getConfig();return Object.assign(e,i),e}call(e,i){return G(()=>("float32"!==(e=qe(e)).dtype&&(e=ia(e,"float32")),ue(N(e,this.scale),this.offset)))}}return n.className="Rescaling",n})();ce(v5);const{resizeBilinear:uTe,cropAndResize:hTe}=cd;let x5=(()=>{class n extends xt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,i,r,s,o,a,l,c){return G(()=>{let d,u=!1;const g=[i/a,r/l,(s+i)/a,(o+r)/l],_=[];3===e.rank?(u=!0,d=zl([e])):d=e;for(let w=0;w<d.shape[0];w++)_.push(g);const b=Jm(_,[_.length,4]),y=ag(0,_.length,1,"int32"),x=hTe(d,b,y,[s,o],"nearest");return ia(u?qe(ld(x)):x,c)})}upsize(e,i,r,s){return G(()=>ia(uTe(e,[i,r]),s))}call(e,i){return G(()=>{const r=qe(e),s=r.dtype,o=r.shape,a=o[o.length-3],l=o[o.length-2];let c=0;a!==this.height&&(c=Math.floor((a-this.height)/2));let d=0;return l!==this.width&&(d=Math.floor((l-this.width)/2),0===d&&(d=1)),c>=0&&d>=0?this.centerCrop(r,c,d,this.height,this.width,a,l,s):this.upsize(e,this.height,this.width,s)})}getConfig(){const e={height:this.height,width:this.width},i=super.getConfig();return Object.assign(e,i),e}computeOutputShape(e){const r=(e=Bt(e)).length-2;return e[e.length-3]=this.height,e[r]=this.width,e}}return n.className="CenterCrop",n})();ce(x5);let w5=(()=>{class n extends xt{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},i=super.getConfig();return Object.assign(e,i),e}computeOutputShape(e){return null==(e=Bt(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,i){return G(()=>{let r;if("int32"!==(e=qe(e)).dtype&&(e=ia(e,"int32")),typeof i.countWeights<"u"){if("count"!==this.outputMode)throw new R(`countWeights is not used when outputMode !== count.\n              Received countWeights=${i.countWeights}`);r=qe(i.countWeights)}const s=xo(e),o=Ox(e),a=ms(this.numTokens,s).bufferSync().get(0),l=od(o,0).bufferSync().get(0);if(!a||!l)throw new R(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function pTe(n,t,e,i){let r=qe(n);if("int32"!==r.dtype&&(r=ia(r,"int32")),"int"===t)return r;const s=r.shape;if(0===r.rank&&(r=qr(r,-1)),"oneHot"===t&&1!==r.shape[r.shape.length-1]&&(r=qr(r,-1)),r.rank>2)throw new R(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(t);let l;if(l=Z4(r,typeof i<"u"&&"count"===t?i:[],e,o),"tfIdf"!==t)return l;if(i)return N(l,i);throw new R("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,r)})}}return n.className="CategoryEncoding",n})();ce(w5);const C5=new Set(["bilinear","nearest"]);let D5=(()=>{class n extends xt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!C5.has(e.interpolation))throw new R(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){return e=Bt(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},i=super.getConfig();return Object.assign(e,i),e}call(e,i){return G(()=>{const r=[this.height,this.width];if("bilinear"===this.interpolation)return cd.resizeBilinear(e,r,!this.cropToAspectRatio);if("nearest"===this.interpolation)return cd.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...C5]} are supported`)})}}return n.className="Resizing",n})();var T5;function Te(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}ce(D5),q().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(T5||(T5={})),Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const oAe=Xj;let aAe=(()=>{class n extends ZE{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new xH(this,Qo())}nextDataId(){return n.nextDataId++}write(e,i,r){this.firstUse&&(this.firstUse=!1,q().get("IS_NODE")&&hs("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:r,refCount:1}),s}makeTensorInfo(e,i,r){let s;if("string"===i&&null!=r&&r.length>0&&Xf(r[0])){const o=r.map(a=>Nl(a));s=this.write(o,e,i)}else s=this.write(r,e,i);return{dataId:s,shape:e,dtype:i}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,i,r,s,o){this.data.set(e,{values:i,dtype:s,refCount:o})}numDataIds(){return this.data.numDataIds()}read(e){var i=this;return ie(function*(){return i.readSync(e)})()}readSync(e){const{dtype:i,complexTensorInfos:r}=this.data.get(e);return"complex64"===i?qa(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):function sve(n,t){if(Array.isArray(n))return n;if("float32"===t)return n instanceof Float32Array?n:new Float32Array(n);if("int32"===t)return n instanceof Int32Array?n:new Int32Array(n);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,i)}bufferSync(e){const i=this.readSync(e.dataId);if("string"===e.dtype)try{const r=i.map(s=>Rl(s));return vt(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return vt(e.shape,e.dtype,i)}makeOutput(e,i,r){return Qo().makeTensorFromTensorInfo(this.makeTensorInfo(i,r,e),this)}disposeData(e,i=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!i&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);null!=r&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return ie(function*(){const i=Fr();return e(),{kernelMs:Fr()-i}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Te([e],"where");const i=this.readSync(e.dataId);return oAe(e.shape,i)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function Zt(n,t,e){return({inputs:i,attrs:r,backend:s})=>{const{x:o}=i;if(Te(o,n),"string"===o.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=s,l=a.data.get(o.dataId).values,c=K(o.shape),d=e||o.dtype,u=ii(d,c);for(let h=0;h<c;++h)u[h]=t(l[h],r);return a.makeTensorInfo(o.shape,d,u)}}function wh(n,t,e){return({inputs:i,attrs:r,backend:s})=>{const{x:o}=i;if(Te(o,n),"string"===o.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=s,l=a.data.get(o.dataId).values,c=e||o.dtype,d=t(l,c,r);return a.makeTensorInfo(o.shape,c,d)}}x4("cpu",()=>new aAe,1);const o8=Zt(um,n=>n>=0?n:Math.exp(n)-1),cAe={kernelName:um,backendName:"cpu",kernelFunc:o8};function ca(n){const{inputs:t,backend:e}=n,{x:i}=t;return e.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const dAe={kernelName:bm,backendName:"cpu",kernelFunc:ca};function a8(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{alpha:s}=i;Te([r],"leakyRelu");const o=K(r.shape),a=e.data.get(r.dataId).values,l=zi("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?s*a[c]:a[c];return e.makeTensorInfo(r.shape,"float32",l)}const uAe={kernelName:Rv,backendName:"cpu",kernelFunc:a8};function ri(n){return(t,e,i,r,s)=>{const o=Je(t,e),a=o.length,l=Le(o),d=zi(s,K(o)),u=t.length,h=e.length,p=Le(t),f=Le(e),m=ch(t,o),g=ch(e,o);if(m.length+g.length===0)for(let _=0;_<d.length;++_)d[_]=n(i[_%i.length],r[_%r.length]);else for(let _=0;_<d.length;++_){const b=Qu(_,a,l),y=b.slice(-u);m.forEach(C=>y[C]=0);const v=Xo(y,u,p),x=b.slice(-h);g.forEach(C=>x[C]=0);const w=Xo(x,h,f);d[_]=n(i[v],r[w])}return[d,o]}}const hAe=ri((n,t)=>n<0?t*n:n);function l8(n){const{inputs:t,backend:e}=n,{x:i,alpha:r}=t;Te([i,r],"prelu");const s=e.data.get(i.dataId).values,o=e.data.get(r.dataId).values,[a,l]=hAe(i.shape,r.shape,s,o,"float32");return e.makeTensorInfo(l,"float32",a)}const pAe={kernelName:Qv,backendName:"cpu",kernelFunc:l8},c8=Zt(Am,n=>Math.max(0,n)),fAe={kernelName:Am,backendName:"cpu",kernelFunc:c8},d8=Zt(Mm,n=>Math.min(Math.max(0,n),6)),mAe={kernelName:Mm,backendName:"cpu",kernelFunc:d8};function Xl(n){return(t,e,i)=>{const r=zi(e,t.length);for(let s=0;s<t.length;++s)r[s]=n(t[s],i);return r}}const gAe=Xl(n=>1/(1+Math.exp(-n))),u8=Zt($m,n=>1/(1+Math.exp(-n))),_Ae={kernelName:$m,backendName:"cpu",kernelFunc:u8};function A0(n,t,e,i,r){if("linear"===e)return ca({inputs:{x:t},backend:n});if("relu"===e)return c8({inputs:{x:t},backend:n});if("elu"===e)return o8({inputs:{x:t},backend:n});if("relu6"===e)return d8({inputs:{x:t},backend:n});if("prelu"===e)return l8({inputs:{x:t,alpha:i},backend:n});if("leakyrelu"===e)return a8({inputs:{x:t},backend:n,attrs:{alpha:r}});if("sigmoid"===e)return u8({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Kr(n){const{inputs:t,backend:e}=n,{real:i,imag:r}=t,s=e.data.get(i.dataId).values,o=e.data.get(r.dataId).values,a=e.makeTensorInfo(i.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(i.shape,"float32",s),imag:e.makeTensorInfo(r.shape,"float32",o)},a}const bAe={kernelName:fI,backendName:"cpu",kernelFunc:Kr};function M0(n,t,e="float32"){if("complex64"===e)return Kr({inputs:{real:M0(n,t,"float32"),imag:M0(n,t,"float32")},backend:n});const i=Xi(K(t),e);return n.makeTensorInfo(t,e,i)}function bd(n){const{inputs:t,backend:e}=n,{input:i}=t,r=e.data.get(i.dataId).complexTensorInfos.real,s=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,s)}const yAe={kernelName:VI,backendName:"cpu",kernelFunc:bd};function h8(n,t,e,i){if("int32"===i)return[t,"int32",Int32Array.from(n)];if("bool"===i){const r=Zc([0],e),[s,o]=ri((a,l)=>a!==l?1:0)(t,[],n,r,"bool");return[o,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${i}`)}function Zl(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{dtype:s}=i;if("complex64"===s){if("complex64"===r.dtype)return ca({inputs:{x:r},backend:e});const d=M0(e,r.shape,r.dtype),u=Zl({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),h=Kr({inputs:{real:u,imag:d},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(u),h}if("complex64"===r.dtype){const d=bd({inputs:{input:r},backend:e}),u=Zl({inputs:{x:d},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(d),u}if(!SH(r.dtype,s)){const d=ca({inputs:{x:r},backend:e});return{dataId:d.dataId,shape:d.shape,dtype:s}}const o=e.data.get(r.dataId).values,[a,l,c]=h8(o,r.shape,r.dtype,s);return e.makeTensorInfo(a,l,c)}const vAe={kernelName:sm,backendName:"cpu",kernelFunc:Zl};function Ri(n,t,e,i){return null==e?({inputs:r,backend:s})=>{const{a:o,b:a}=r,l=s;Te([o,a],n);const c=l.data.get(o.dataId).values,d=l.data.get(a.dataId).values,u="string"===o.dtype?dd(c):c,h="string"===o.dtype?dd(d):d,p=i||o.dtype,[f,m]=t(o.shape,a.shape,u,h,p);return l.makeTensorInfo(m,p,f)}:({inputs:r,backend:s})=>{const{a:o,b:a}=r,l=s;if("complex64"===o.dtype||"complex64"===a.dtype){const c=Zl({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(c.dataId),h=d.complexTensorInfos.imag,p=l.data.get(d.complexTensorInfos.real.dataId).values,f=l.data.get(h.dataId).values,m=Zl({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),b=g.complexTensorInfos.imag,y=l.data.get(g.complexTensorInfos.real.dataId).values,v=l.data.get(b.dataId).values,[x,w,C]=e(o.shape,a.shape,p,f,y,v),D=l.makeTensorInfo(C,"float32",x),k=l.makeTensorInfo(C,"float32",w),I=Kr({inputs:{real:D,imag:k},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(k),I}{const c=l.data.get(o.dataId).values,d=l.data.get(a.dataId).values,u=i||o.dtype,[h,p]=t(o.shape,a.shape,c,d,u);return l.makeTensorInfo(p,u,h)}}}function zA(n){return(t,e,i,r,s,o)=>{const a=Je(t,e),l=K(a),c=a.length,d=Le(a),u=zi("float32",l),h=zi("float32",l),p=ch(t,a),f=ch(e,a),m=qa(i,r),g=qa(s,o),_=t.length,b=Le(t),y=e.length,v=Le(e);if(p.length+f.length===0)for(let x=0;x<u.length;x++){const w=x%m.length,C=x%g.length,D=n(m[2*w],m[2*w+1],g[2*C],g[2*C+1]);u[x]=D.real,h[x]=D.imag}else for(let x=0;x<u.length;x++){const w=Qu(x,c,d),C=w.slice(-_);p.forEach($=>C[$]=0);const D=Xo(C,_,b),k=w.slice(-y);f.forEach($=>k[$]=0);const I=Xo(k,y,v),A=n(m[2*D],m[2*D+1],g[2*I],g[2*I+1]);u[x]=A.real,h[x]=A.imag}return[u,h,a]}}const p8=ri((n,t)=>n+t),xAe=zA((n,t,e,i)=>({real:n+e,imag:t+i})),Ch=Ri(Ju,p8,xAe),wAe={kernelName:Ju,backendName:"cpu",kernelFunc:Ch};function hn(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{shape:s}=i,o=K(r.shape),a=DH(s,o),l=K(a);S(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(r.dataId);const c=e.data.get(r.dataId);if(null!=c.complexTensorInfos){const u=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=a,u.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const CAe={kernelName:ex,backendName:"cpu",kernelFunc:hn};function f8(n){const{inputs:t,backend:e,attrs:i}=n,{a:r,b:s}=t,{transposeA:o,transposeB:a}=i;Te([r,s],"matMul");const l=r.shape.length,c=s.shape.length,d=o?r.shape[l-2]:r.shape[l-1],u=a?s.shape[c-1]:s.shape[c-2],h=o?r.shape[l-1]:r.shape[l-2],p=a?s.shape[c-2]:s.shape[c-1],f=r.shape.slice(0,-2),m=s.shape.slice(0,-2),g=K(f),_=K(m),y=Je(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);S(d===u,()=>`Error in matMul: inner shapes (${d}) and (${u}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${o} and transposeB=${a} must match.`);const x=a?[_,p,u]:[_,u,p],w=hn({inputs:{x:r},backend:e,attrs:{shape:o?[g,d,h]:[g,h,d]}}),C=hn({inputs:{x:s},backend:e,attrs:{shape:x}}),D=o?w.shape[1]:w.shape[2],k=o?w.shape[2]:w.shape[1],I=a?C.shape[1]:C.shape[2],A=Math.max(g,_),$=e.data.get(w.dataId).values,H=e.data.get(C.dataId).values,W=Le(w.shape),z=Le(C.shape),[M,F,L]=o?[W[0],1,W[1]]:[W[0],W[1],1],[j,Z,ee]=a?[1,z[1],z[0]]:[z[1],1,z[0]],se=k*I,re=vt([A,k,I],w.dtype),ae=re.values,pe=e.blockSize;for(let xe=0;xe<A;xe++){const Ce=xe%g,Pe=xe%_;for(let Ae=0;Ae<k;Ae+=pe){const Xe=Math.min(Ae+pe,k);for(let tt=0;tt<I;tt+=pe){const Qt=Math.min(tt+pe,I);for(let fn=0;fn<D;fn+=pe){const Bn=Math.min(fn+pe,D);for(let mn=Ae;mn<Xe;mn++)for(let nn=tt;nn<Qt;nn++){let Pn=0;for(let In=fn;In<Bn;In++)Pn+=$[Ce*M+mn*F+In*L]*H[In*j+nn*Z+Pe*ee];ae[xe*se+(mn*I+nn)]+=Pn}}}}}return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(C),e.makeTensorInfo(y,re.dtype,re.values)}const DAe={kernelName:bv,backendName:"cpu",kernelFunc:f8},kAe={kernelName:px,backendName:"cpu",kernelFunc:function SAe(n){const{inputs:t,backend:e,attrs:i}=n,{a:r,b:s,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:u}=i;let h,p,f;const m=[];h=f8({inputs:{a:r,b:s},attrs:{transposeA:l,transposeB:c},backend:e}),o&&(p=Ch({inputs:{a:h,b:o},backend:e}),m.push(h),h=p),d&&(f=A0(e,h,d,a,u),m.push(h),h=f);for(const _ of m)e.disposeIntermediateTensorInfo(_);return h}};function m8(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const EAe={kernelName:pv,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;Te(t,"abs");let i=new Float32Array(K(t.shape));return i=m8(e.data.get(t.dataId).values),e.makeOutput(i,t.shape,t.dtype)}},IAe=Zt(Qf,n=>Math.acos(n)),TAe={kernelName:Qf,backendName:"cpu",kernelFunc:IAe},AAe=Zt(Jf,n=>Math.acosh(n)),MAe={kernelName:Jf,backendName:"cpu",kernelFunc:AAe},RAe={kernelName:lI,backendName:"cpu",kernelFunc:function NAe(n){const{inputs:t,backend:e}=n,i=t;Te(t,"addN");const r=i.map(a=>e.data.get(a.dataId).values),s=vt(i[0].shape,i[0].dtype),o=s.values;for(let a=0;a<i.length;a++){const l=r[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}};function UA(n,t,e,i,r){const s=t.length,o=K(t),a=Le(t),l=Le(r),c=zi(e,K(r));for(let d=0;d<o;++d){const u=Qu(d,s,a),h=new Array(u.length);for(let f=0;f<h.length;f++)h[f]=u[i[f]];c[Xo(h,s,l)]=n[d]}return c}function $r(n){const{inputs:t,attrs:e,backend:i}=n,{x:r}=t,{perm:s}=e;Te(r,"transpose");const a=new Array(r.shape.length);for(let u=0;u<a.length;u++)a[u]=r.shape[s[u]];const c=UA(i.data.get(r.dataId).values,r.shape,r.dtype,s,a);return{dataId:i.write(c,a,r.dtype),shape:a,dtype:r.dtype}}const OAe={kernelName:eh,backendName:"cpu",kernelFunc:$r},PAe={kernelName:"All",backendName:"cpu",kernelFunc:function FAe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i;Te(r,"all");const a=yt(s,r.shape);let l=a;const c=Rn(l,r.shape.length);let d=r;null!=c&&(d=$r({inputs:{x:r},backend:e,attrs:{perm:c}}),l=Xn(l.length,r.shape.length)),Hi("all",l,d.shape.length);const[u,h]=Ai(d.shape,l),p=K(h),f=Xi(K(u),d.dtype),m=e.data.get(d.dataId).values;for(let _=0;_<f.length;++_){const b=_*p;let y=m[b];for(let v=0;v<p;++v)y=y&&m[b+v];f[_]=y}null!=c&&e.disposeIntermediateTensorInfo(d);const g=e.makeTensorInfo(u,d.dtype,f);if(o){const b=hn({inputs:{x:g},backend:e,attrs:{shape:Kn(u,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},$Ae={kernelName:"Any",backendName:"cpu",kernelFunc:function LAe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i;Te(r,"any");const a=yt(s,r.shape);let l=a;const c=Rn(l,r.shape.length);let d=r;null!=c&&(d=$r({inputs:{x:r},backend:e,attrs:{perm:c}}),l=Xn(l.length,r.shape.length)),Hi("any",l,d.shape.length);const[u,h]=Ai(d.shape,l),p=K(h),f=Xi(K(u),d.dtype),m=e.data.get(d.dataId).values;for(let _=0;_<f.length;++_){const b=_*p;let y=m[b];for(let v=0;v<p;++v)y=y||m[b+v];f[_]=y}null!=c&&e.disposeIntermediateTensorInfo(d);const g=e.makeTensorInfo(u,d.dtype,f);if(o){const b=hn({inputs:{x:g},backend:e,attrs:{shape:Kn(u,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},BAe={kernelName:fv,backendName:"cpu",kernelFunc:function VAe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s}=i;Te(r,"argMax");let o=yt(s,r.shape);const a=Rn(o,r.shape.length);let l=r;const c=[];null!=a&&(l=$r({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=Xn(o.length,l.shape.length)),o=[o[0]],Hi("argMax",o,l.shape.length);const[d,u]=Ai(l.shape,o),p=Xi(K(d),"int32"),f=K(u),m=e.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const _=g*f;let b=m[_],y=0;for(let v=0;v<f;++v){const x=m[_+v];x>b&&(b=x,y=v)}p[g]=y}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(d,"int32",p)}},UAe={kernelName:mv,backendName:"cpu",kernelFunc:function zAe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s}=i;Te(r,"argMin");let o=yt(s,r.shape);const a=Rn(o,r.shape.length);let l=r;const c=[];null!=a&&(l=$r({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=Xn(o.length,l.shape.length)),o=[o[0]],Hi("argMin",o,l.shape.length);const[d,u]=Ai(l.shape,o),p=Xi(K(d),"int32"),f=K(u),m=e.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const _=g*f;let b=m[_],y=0;for(let v=0;v<f;++v){const x=m[_+v];x<b&&(b=x,y=v)}p[g]=y}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(d,"int32",p)}},HAe=Zt(em,n=>Math.asin(n)),jAe={kernelName:em,backendName:"cpu",kernelFunc:HAe},WAe=Zt(tm,n=>Math.asinh(n)),GAe={kernelName:tm,backendName:"cpu",kernelFunc:WAe},qAe=Zt(nm,n=>Math.atan(n)),YAe={kernelName:nm,backendName:"cpu",kernelFunc:qAe},KAe=ri((n,t)=>Math.atan2(n,t)),XAe=Ri(rm,KAe),ZAe={kernelName:rm,backendName:"cpu",kernelFunc:XAe},QAe=Zt(im,n=>Math.atanh(n)),JAe={kernelName:im,backendName:"cpu",kernelFunc:QAe};function HA(n,t,e,i,r,s){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,u=r.effectiveFilterWidth,h=r.padInfo.top,p=r.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=vt(r.outShape,e),g=m.values,_=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],y=r.outShape[3];for(let v=0;v<r.batchSize;++v){const x=v*_,w=v*i[0];for(let C=0;C<r.inChannels;++C)for(let D=0;D<r.outHeight;++D){const k=D*o-h,I=Math.max(0,k),A=Math.min(r.inHeight,d+k),$=x+D*b;for(let H=0;H<r.outWidth;++H){const W=H*a-p,z=Math.max(0,W),M=Math.min(r.inWidth,u+W);let F=f,L=0,j=0;for(let ee=I;ee<A;ee+=l){const se=w+ee*i[1];for(let re=z;re<M;re+=c){const pe=n[se+re*i[2]+C];"max"===s&&pe>F?F=pe:"avg"===s&&(L+=pe,j++)}if(isNaN(F))break}g[$+H*y+C]="avg"===s?L/j:F}}}return m}function g8(n,t,e,i,r=!1,s=!1){const o=vt(i.outShape,"int32"),a=i.strideHeight,l=i.strideWidth,c=i.dilationHeight,d=i.dilationWidth,u=i.effectiveFilterHeight,h=i.effectiveFilterWidth,p=i.padInfo.top,f=i.padInfo.left,m=vt(t,e,n);for(let g=0;g<i.batchSize;++g)for(let _=0;_<i.inChannels;++_)for(let b=0;b<i.outHeight;++b){const y=b*a-p;let v=y;for(;v<0;)v+=c;const x=Math.min(i.inHeight,u+y);for(let w=0;w<i.outWidth;++w){const C=w*l-f;let D=C;for(;D<0;)D+=d;const k=Math.min(i.inWidth,h+C);let I=Number.NEGATIVE_INFINITY,A=-1;for(let $=v;$<x;$+=c){const H=$-y;for(let W=D;W<k;W+=d){const z=W-C,M=m.get(g,$,W,_);M>I&&(I=M,A=r?s?((g*i.inHeight+$)*i.inWidth+W)*i.inChannels+_:($*i.inWidth+W)*i.inChannels+_:H*h+z)}}o.set(A,g,b,w,_)}}return o}function _8(n,t,e,i,r,s){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,d=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,_=r.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=vt(r.outShape,e),v=y.values,x=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],w=r.outShape[2]*r.outShape[3]*r.outShape[4],C=r.outShape[3]*r.outShape[4],D=r.outShape[4];for(let k=0;k<r.batchSize;++k){const I=k*x,A=k*i[0];for(let $=0;$<r.inChannels;++$)for(let H=0;H<r.outDepth;++H){const W=H*o-m;let z=W;for(;z<0;)z+=c;const M=Math.min(r.inDepth,h+W),F=I+H*w;for(let L=0;L<r.outHeight;++L){const j=L*a-g;let Z=j;for(;Z<0;)Z+=d;const ee=Math.min(r.inHeight,p+j),se=F+L*C;for(let re=0;re<r.outWidth;++re){const ae=re*l-_;let pe=ae;for(;pe<0;)pe+=u;const xe=Math.min(r.inWidth,f+ae),Ce=se+re*D;let Pe=b,Ae=0,Xe=0;for(let Qt=z;Qt<M;Qt+=c){const fn=A+Qt*i[1];for(let Bn=Z;Bn<ee;Bn+=d){const mn=fn+Bn*i[2];for(let nn=pe;nn<xe;nn+=u){const In=n[mn+nn*i[3]+$];if("max"===s&&In>Pe?Pe=In:"avg"===s&&(Ae+=In,Xe++),isNaN(Pe))break}if(isNaN(Pe))break}if(isNaN(Pe))break}v[Ce+$]="avg"===s?Ae/Math.max(Xe,1):Pe}}}}return y}const nMe={kernelName:gv,backendName:"cpu",kernelFunc:function tMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t;Te(r,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i;S(Ui(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=Hs(r.shape,s,o,1,a,l);let u;if(1===d.filterWidth&&1===d.filterHeight&&Ut(d.inShape,d.outShape))u=ca({inputs:{x:r},backend:e});else{const h=e.data.get(r.dataId).values,p=Le(r.shape),f=HA(h,0,r.dtype,p,d,"avg");u=e.makeTensorInfo(d.outShape,r.dtype,f.values)}return u}},rMe={kernelName:_v,backendName:"cpu",kernelFunc:function iMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=i;Te(r,"avgPool3d");const d=Ua(r.shape,s,o,1,a,l,c),h=_8(e.data.get(r.dataId).values,0,r.dtype,Le(r.shape),d,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},oMe={kernelName:hI,backendName:"cpu",kernelFunc:function sMe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,input:s}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=i;Te([r,s],"avgPool3DGrad");const d=Ua(s.shape,o,a,1,l,c),u=d.strideDepth,h=d.strideHeight,p=d.strideWidth,f=d.filterDepth,m=d.filterHeight,g=d.filterWidth,_=d.dilationDepth,b=d.dilationHeight,y=d.dilationWidth,v=d.effectiveFilterDepth,x=d.effectiveFilterHeight,w=d.effectiveFilterWidth,C=v-1-d.padInfo.front,D=w-1-d.padInfo.left,k=x-1-d.padInfo.top,I=vt(s.shape,"float32"),A=1/(f*m*g),$=e.bufferSync(r);for(let H=0;H<d.batchSize;++H)for(let W=0;W<d.inChannels;++W)for(let z=0;z<d.inDepth;++z)for(let M=0;M<d.inHeight;++M)for(let F=0;F<d.inWidth;++F){const L=z-C,j=M-k,Z=F-D;let ee=0;for(let se=0;se<v;se+=_){const re=(L+se)/u;if(!(re<0||re>=d.outDepth||Math.floor(re)!==re))for(let ae=0;ae<x;ae+=b){const pe=(j+ae)/h;if(!(pe<0||pe>=d.outHeight||Math.floor(pe)!==pe))for(let xe=0;xe<w;xe+=y){const Ce=(Z+xe)/p;Ce<0||Ce>=d.outWidth||Math.floor(Ce)!==Ce||(ee+=$.get(H,re,pe,Ce,W))}}}I.set(ee*A,H,z,M,F,W)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}},lMe={kernelName:uI,backendName:"cpu",kernelFunc:function aMe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,input:s}=t,o=s;Te([r,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=i,d=Hs(o.shape,a,l,1,c),u=d.strideHeight,h=d.strideWidth,p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,_=d.effectiveFilterHeight,b=d.effectiveFilterWidth,y=b-1-d.padInfo.left,v=_-1-d.padInfo.top,x=vt(o.shape,"float32"),w=1/(p*f),C=e.data.get(r.dataId).values,D=vt(r.shape,"float32",C);for(let k=0;k<d.batchSize;++k)for(let I=0;I<d.inChannels;++I)for(let A=0;A<d.inHeight;++A)for(let $=0;$<d.inWidth;++$){const H=A-v,W=$-y;let z=0;for(let M=0;M<_;M+=m){const F=(H+M)/u;if(!(F<0||F>=d.outHeight||Math.floor(F)!==F))for(let L=0;L<b;L+=g){const j=(W+L)/h;j<0||j>=d.outWidth||Math.floor(j)!==j||(z+=D.get(k,F,j,I))}}x.set(z*w,k,A,$,I)}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},dMe={kernelName:Av,backendName:"cpu",kernelFunc:function cMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,scale:s,offset:o,mean:a,variance:l}=t;S(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==s||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Te([r,a,l,s,o],"batchNorm");let{varianceEpsilon:c}=i;null==c&&(c=.001);const d=e.data.get(r.dataId).values,u=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,p=s?e.data.get(s.dataId).values:new Float32Array([1]),f=o?e.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(d.length),g=f.length,_=p.length,b=h.length,y=u.length;let v=0,x=0,w=0,C=0;for(let D=0;D<d.length;++D)m[D]=f[v++]+(d[D]-u[x++])*p[w++]/Math.sqrt(h[C++]+c),v>=g&&(v=0),x>=y&&(x=0),w>=_&&(w=0),C>=b&&(C=0);return e.makeTensorInfo(r.shape,r.dtype,m)}};function b8(n,t,e,i,r){const s=L1(i,t,e),o=K(e),a=Le(i);if(s){const u=$1(t,a);return"string"===r?n.slice(u,u+o):n.subarray(u,u+o)}const c=vt(i,r,"string"===r?dd(n):n),d=vt(e,r);for(let u=0;u<d.size;++u){const h=d.indexToLoc(u),p=h.map((f,m)=>f+t[m]);d.set(c.get(...p),...h)}return"string"===r?Kj(d.values):d.values}function yd(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{begin:s,size:o}=i;Te(r,"slice");const[a,l]=Tx(r,s,o);F1(r,a,l);const d=b8(e.data.get(r.dataId).values,a,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,d)}const uMe={kernelName:sx,backendName:"cpu",kernelFunc:yd},pMe={kernelName:yv,backendName:"cpu",kernelFunc:function hMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{blockShape:s,crops:o}=i;Te([r],"batchToSpaceND");const a=s.reduce((_,b)=>_*b),l=hg(r.shape,s,a),c=pg(l.length,s.length),d=fg(r.shape,s,a),u=vT(o,s.length),h=xT(d,o,s.length),p=hn({inputs:{x:r},backend:e,attrs:{shape:l}}),f=$r({inputs:{x:p},backend:e,attrs:{perm:c}}),m=hn({inputs:{x:f},backend:e,attrs:{shape:d}}),g=yd({inputs:{x:m},backend:e,attrs:{begin:u,size:h}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}};function jA(n,t,e,i,r){const s=K(i),o=Xi(r,e);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(o[l]+=s>0?t[a]:1)}return o}function y8(n,t,e,i=!1){const r=n.shape[0],s=n.shape[1],o=vt([r,e],t.dtype);for(let a=0;a<r;a++)for(let l=0;l<s;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||o.set(i?1:t.size>0?o.get(a,c)+t.get(a,l):o.get(a,c)+1,a,c)}return o}const mMe={kernelName:pI,backendName:"cpu",kernelFunc:function fMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,weights:s}=t,{size:o}=i,c=jA(e.data.get(r.dataId).values,e.data.get(s.dataId).values,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,c)}},_Me={kernelName:MH,backendName:"cpu",kernelFunc:function gMe(n){const{inputs:t,backend:e}=n,{s0:i,s1:r}=t,s=e.data.get(i.dataId).values,o=e.data.get(r.dataId).values,a=Je(Array.from(s),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},v8=Xl(n=>Math.ceil(n)),bMe=wh(om,v8),yMe={kernelName:om,backendName:"cpu",kernelFunc:bMe},vMe=Zt(am,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),xMe={kernelName:am,backendName:"cpu",kernelFunc:vMe},wMe={kernelName:vv,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,i=new Float32Array(K(t.shape)),r=e.data.get(t.dataId),o=r.complexTensorInfos.imag,a=e.data.get(r.complexTensorInfos.real.dataId).values,l=e.data.get(o.dataId).values;for(let c=0;c<a.length;c++)i[c]=Math.hypot(a[c],l[c]);return e.makeOutput(i,t.shape,"float32")}};function x8(n,t,e,i){const r=ii(e,K(t));if(i&&"string"!==e){let s=0;n.forEach(o=>{const a=K(o.shape);r.set(o.vals,s),s+=a})}else{let s=0;n.forEach(o=>{const a="string"===e?dd(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const d=c*t[1]+s;for(let u=0;u<o.shape[1];++u)r[d+u]=a[l++]}s+=o.shape[1]})}return r}function Dh(n){const{inputs:t,backend:e}=n,{input:i}=t,r=e.data.get(i.dataId).complexTensorInfos.imag,s=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,s)}const CMe={kernelName:MI,backendName:"cpu",kernelFunc:Dh};function Sh(n){const{inputs:t,backend:e,attrs:i}=n,{axis:r}=i,s=yt(r,t[0].shape)[0];_T(t.map(m=>m.shape),s);let a=ta(t.map(m=>m.shape),s);if(0===K(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(m=>K(m.shape)>0);if(1===l.length)return ca({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const m=l.map(v=>bd({inputs:{input:v},backend:e})),g=l.map(v=>Dh({inputs:{input:v},backend:e})),_=Sh({inputs:m,backend:e,attrs:{axis:s}}),b=Sh({inputs:g,backend:e,attrs:{axis:s}}),y=Kr({inputs:{real:_,imag:b},backend:e});return m.forEach(v=>e.disposeIntermediateTensorInfo(v)),g.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(b),y}const c=l.map(m=>{const _=[-1,K(m.shape.slice(s))];return hn({inputs:{x:m},backend:e,attrs:{shape:_}})}),d=c.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));a=ta(c.map(m=>m.shape),1);const h=x8(d,a,t[0].dtype,1===c[0].shape[0]),p=ta(l.map(m=>m.shape),s),f=e.makeTensorInfo(p,t[0].dtype,h);return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}const DMe={kernelName:xv,backendName:"cpu",kernelFunc:Sh};function w8(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=i;Te([r,s],"conv2d");const u=Ha(l),h=Ti(r.shape,s.shape,o,c,a,d,!1,u),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,_=h.padInfo.left,b=h.padInfo.top,y="channelsLast"===h.dataFormat,v=new Zi(h.outShape,r.dtype),x=Le(r.shape),w=Le(s.shape),C=x[0],D=y?x[1]:x[2],k=y?x[2]:1,I=y?1:x[1],A=v.strides[0],$=y?v.strides[1]:v.strides[2],H=y?v.strides[2]:1,W=y?1:v.strides[1],z=e.data.get(r.dataId).values,M=e.data.get(s.dataId).values,F=v.values;for(let L=0;L<h.batchSize;++L){const j=L*C,Z=L*A;for(let ee=0;ee<h.outHeight;++ee){const se=Z+ee*$,re=ee*h.strideHeight-b;for(let ae=0;ae<p;++ae){const pe=re+ae*m;if(pe<0||pe>=h.inHeight)continue;const xe=ae*w[0],Ce=j+pe*D;for(let Pe=0;Pe<h.outWidth;++Pe){const Ae=se+Pe*H,Xe=Pe*h.strideWidth-_;for(let tt=0;tt<f;++tt){const Qt=Xe+tt*g;if(Qt<0||Qt>=h.inWidth)continue;const Bn=Ce+Qt*k;let mn=xe+tt*w[1];for(let nn=0;nn<h.inChannels;++nn){const Pn=z[Bn+nn*I];for(let In=0;In<h.outChannels;++In)F[Ae+In*W]+=Pn*M[mn+In];mn+=h.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,F)}const SMe={kernelName:wv,backendName:"cpu",kernelFunc:w8},EMe={kernelName:mI,backendName:"cpu",kernelFunc:function kMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,dy:s}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:d}=i;Te([r,s],"conv2dBackpropFilter");const u=Ha(l),h=Ti(r.shape,d,o,1,a,c,!1,u),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,_="channelsLast"===h.dataFormat,b=new Zi(h.filterShape,"float32"),y=h.padInfo.left,v=h.padInfo.top,x=e.data.get(r.dataId).values,w=e.data.get(s.dataId).values,C=new Zi(r.shape,r.dtype,x),D=new Zi(s.shape,s.dtype,w);for(let k=0;k<m;++k){const I=Math.max(0,Math.ceil((v-k)/p)),A=Math.min(h.outHeight,(h.inHeight+v-k)/p);for(let $=0;$<g;++$){const H=Math.max(0,Math.ceil((y-$)/f)),W=Math.min(h.outWidth,(h.inWidth+y-$)/f);for(let z=0;z<h.inChannels;++z)for(let M=0;M<h.outChannels;++M){let F=0;for(let L=0;L<h.batchSize;++L)for(let j=I;j<A;++j){const Z=k+j*p-v;for(let ee=H;ee<W;++ee){const se=$+ee*f-y;F+=_?C.get(L,Z,se,z)*D.get(L,j,ee,M):C.get(L,z,Z,se)*D.get(L,M,j,ee)}}b.set(F,k,$,z,M)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},TMe={kernelName:Cv,backendName:"cpu",kernelFunc:function IMe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,filter:s}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:d}=i;Te([r,s],"conv2dBackpropInput");const u=Le(s.shape),h=Le(r.shape);let p=Ha(c);const f=Ti(o,s.shape,a,1,l,d,!1,p),m=new Zi(f.inShape,"float32"),g=m.values,_=e.data.get(r.dataId).values,b=e.data.get(s.dataId).values,[y,v,x]=u,{batchSize:w,filterHeight:C,filterWidth:D,inChannels:k,inHeight:I,inWidth:A,outChannels:$,outHeight:H,outWidth:W,strideHeight:z,strideWidth:M}=f;p=f.dataFormat;const F=C-1-f.padInfo.top,L=D-1-f.padInfo.left,j="channelsLast"===p,Z=m.strides[0],ee=j?m.strides[1]:m.strides[2],se=j?m.strides[2]:1,re=j?1:m.strides[1],ae=h[0],pe=j?h[1]:h[2],xe=j?h[2]:1,Ce=j?1:h[1];for(let Pe=0;Pe<w;++Pe)for(let Ae=0;Ae<k;++Ae)for(let Xe=0;Xe<I;++Xe){const tt=Xe-F,Qt=Math.max(0,Math.ceil(tt/z)),fn=Math.min(H,(C+tt)/z);for(let Bn=0;Bn<A;++Bn){const mn=Bn-L,nn=Math.max(0,Math.ceil(mn/M)),Pn=Math.min(W,(D+mn)/M);let In=0;for(let Wi=Qt;Wi<fn;++Wi){const oc=Wi*z-tt;for(let Cs=nn;Cs<Pn;++Cs){const To=ae*Pe+pe*Wi+xe*Cs,Qa=y*(C-1-oc)+v*(D-1-(Cs*M-mn))+x*Ae;for(let ac=0;ac<$;++ac)In+=_[To+Ce*ac]*b[Qa+ac]}}g[Z*Pe+ee*Xe+se*Bn+re*Ae]=In}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},MMe={kernelName:Dv,backendName:"cpu",kernelFunc:function AMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s}=t,{strides:o,pad:a,dilations:l}=i;Te([r,s],"conv3d");const c=Ll(r.shape,s.shape,o,l,a),{filterDepth:d,filterHeight:u,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=c,_=g.front,b=g.left,y=g.top,v=new Zi(c.outShape,r.dtype),x=e.data.get(r.dataId).values,w=e.data.get(s.dataId).values,C=v.values,D=Le(r.shape),k=Le(s.shape);for(let I=0;I<c.batchSize;++I){const A=I*D[0],$=I*v.strides[0];for(let H=0;H<c.outDepth;++H){const W=$+H*v.strides[1],z=H*c.strideDepth-_;for(let M=0;M<d;++M){const F=z+M*p;if(F<0||F>=c.inDepth)continue;const L=M*k[0],j=A+F*D[1];for(let Z=0;Z<c.outHeight;++Z){const ee=W+Z*v.strides[2],se=Z*c.strideHeight-y;for(let re=0;re<u;++re){const ae=se+re*f;if(ae<0||ae>=c.inHeight)continue;const pe=L+re*k[1],xe=j+ae*D[2];for(let Ce=0;Ce<c.outWidth;++Ce){const Pe=ee+Ce*c.outChannels,Ae=Ce*c.strideWidth-b;for(let Xe=0;Xe<h;++Xe){const tt=Ae+Xe*m;if(tt<0||tt>=c.inWidth)continue;const fn=xe+tt*c.inChannels;let Bn=pe+Xe*k[2];for(let mn=0;mn<c.inChannels;++mn){const nn=x[fn+mn];for(let Pn=0;Pn<c.outChannels;++Pn)C[Pe+Pn]+=nn*w[Bn+Pn];Bn+=c.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},RMe={kernelName:gI,backendName:"cpu",kernelFunc:function NMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,dy:s}=t,{strides:o,pad:a,filterShape:l}=i;Te([r,s],"conv3dBackpropFilterV2");const c=Le(r.shape),d=Le(s.shape),u=Ll(r.shape,l,o,1,a),h=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.filterDepth,g=u.filterHeight,_=u.filterWidth,b=new Zi(u.filterShape,"float32"),y=b.values,[v,x,w,C]=b.strides,D=e.data.get(s.dataId).values,[k,I,A,$]=d,H=e.data.get(r.dataId).values,[W,z,M,F]=c,L=u.padInfo.front,j=u.padInfo.left,Z=u.padInfo.top;for(let ee=0;ee<m;++ee){const se=Math.max(0,Math.ceil((L-ee)/h)),re=Math.min(u.outDepth,(u.inDepth+L-ee)/h),ae=ee*v;for(let pe=0;pe<g;++pe){const xe=Math.max(0,Math.ceil((Z-pe)/p)),Ce=Math.min(u.outHeight,(u.inHeight+Z-pe)/p),Pe=pe*x+ae;for(let Ae=0;Ae<_;++Ae){const Xe=Math.max(0,Math.ceil((j-Ae)/f)),tt=Math.min(u.outWidth,(u.inWidth+j-Ae)/f),Qt=Ae*w+Pe;for(let fn=0;fn<u.inChannels;++fn){const Bn=fn*C+Qt;for(let mn=0;mn<u.outChannels;++mn){let nn=0;for(let Pn=0;Pn<u.batchSize;++Pn){const In=Pn*W,Za=Pn*k;for(let Wi=se;Wi<re;++Wi){const Cs=(ee+Wi*h-L)*z+In,Id=Wi*I+Za;for(let To=xe;To<Ce;++To){const ac=(pe+To*p-Z)*M+Cs,lc=To*A+Id;for(let cc=Xe;cc<tt;++cc)nn+=H[(Ae+cc*f-j)*F+ac+fn]*D[cc*$+lc+mn]}}}y[Bn+mn]=nn}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},FMe={kernelName:_I,backendName:"cpu",kernelFunc:function OMe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,filter:s}=t,{pad:o,strides:a,inputShape:l}=i;Te([r],"conv3dBackpropInputV2");const c=Le(r.shape),d=Le(s.shape),u=Ll(l,s.shape,a,1,o),h=new Zi(u.inShape,"float32"),p=h.values,[f,m,g,_]=h.strides,b=e.data.get(r.dataId).values,[y,v,x,w]=c,C=e.data.get(s.dataId).values,[D,k,I,A]=d,{batchSize:$,filterDepth:H,filterHeight:W,filterWidth:z,inChannels:M,inDepth:F,inHeight:L,inWidth:j,outChannels:Z,outDepth:ee,outHeight:se,outWidth:re,strideDepth:ae,strideHeight:pe,strideWidth:xe}=u,Ce=H-1-u.padInfo.front,Pe=W-1-u.padInfo.top,Ae=z-1-u.padInfo.left;for(let Xe=0;Xe<$;++Xe)for(let tt=0;tt<M;++tt)for(let Qt=0;Qt<F;++Qt){const fn=Qt-Ce,Bn=Math.max(0,Math.ceil(fn/ae)),mn=Math.min(ee,(H+fn)/ae);for(let nn=0;nn<L;++nn){const Pn=nn-Pe,In=Math.max(0,Math.ceil(Pn/pe)),Za=Math.min(se,(W+Pn)/pe);for(let Wi=0;Wi<j;++Wi){const oc=Wi-Ae,Cs=Math.max(0,Math.ceil(oc/xe)),Id=Math.min(re,(z+oc)/xe);let To=0;for(let Qa=Bn;Qa<mn;++Qa){const ac=Qa*ae-fn;for(let lc=In;lc<Za;++lc){const cc=lc*pe-Pn;for(let t_=Cs;t_<Id;++t_){const JM=y*Xe+v*Qa+x*lc+w*t_,u8e=D*(H-1-ac)+k*(W-1-cc)+I*(z-1-(t_*xe-oc))+A*tt;for(let Sw=0;Sw<Z;++Sw)To+=b[JM+Sw]*C[u8e+Sw]}}}p[f*Xe+m*Qt+g*nn+_*Wi+tt]=To}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},PMe=Zt(lm,n=>Math.cos(n)),LMe={kernelName:lm,backendName:"cpu",kernelFunc:PMe},$Me=Zt(cm,n=>Math.cosh(n)),VMe={kernelName:cm,backendName:"cpu",kernelFunc:$Me},zMe={kernelName:yI,backendName:"cpu",kernelFunc:function BMe(n){const{inputs:t,backend:e,attrs:i}=n,{image:r,boxes:s,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=i,[d,u,h,p]=r.shape,f=s.shape[0],[m,g]=a,_=vt([f,m,g,p],"float32"),b=e.data.get(s.dataId).values,y=e.data.get(o.dataId).values,v=e.data.get(r.dataId).values,x=Le(r.shape),w=Le(_.shape);for(let C=0;C<f;C++){const D=4*C,k=b[D],I=b[D+1],A=b[D+2],$=b[D+3],H=y[C];if(H>=d)continue;const W=m>1?(A-k)*(u-1)/(m-1):0,z=g>1?($-I)*(h-1)/(g-1):0;for(let M=0;M<m;M++){const F=m>1?k*(u-1)+M*W:.5*(k+A)*(u-1);if(F<0||F>u-1)for(let L=0;L<g;L++)for(let j=0;j<p;j++)_.values[j+L*w[2]+M*w[1]+C*w[0]]=c;else if("bilinear"===l){const L=Math.floor(F),j=Math.ceil(F),Z=F-L;for(let ee=0;ee<g;ee++){const se=g>1?I*(h-1)+ee*z:.5*(I+$)*(h-1);if(se<0||se>h-1){for(let xe=0;xe<p;xe++)_.values[xe+ee*w[2]+M*w[1]+C*w[0]]=c;continue}const re=Math.floor(se),ae=Math.ceil(se),pe=se-re;for(let xe=0;xe<p;xe++){let Ce=xe+re*x[2]+L*x[1]+H*x[0];const Pe=v[Ce];Ce=xe+ae*x[2]+L*x[1]+H*x[0];const Ae=v[Ce];Ce=xe+re*x[2]+j*x[1]+H*x[0];const Xe=v[Ce];Ce=xe+ae*x[2]+j*x[1]+H*x[0];const tt=v[Ce],Qt=Pe+(Ae-Pe)*pe;Ce=xe+ee*w[2]+M*w[1]+C*w[0],_.values[Ce]=Qt+(Xe+(tt-Xe)*pe-Qt)*Z}}}else for(let L=0;L<g;++L){const j=g>1?I*(h-1)+L*z:.5*(I+$)*(h-1);if(j<0||j>h-1){for(let se=0;se<p;se++)_.values[se+L*w[2]+M*w[1]+C*w[0]]=c;continue}const Z=Math.round(j),ee=Math.round(F);for(let se=0;se<p;se++)_.values[se+L*w[2]+M*w[1]+C*w[0]]=v[se+Z*x[2]+ee*x[1]+H*x[0]]}}}return e.makeTensorInfo(_.shape,_.dtype,_.values)}},HMe={kernelName:bI,backendName:"cpu",kernelFunc:function UMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,exclusive:o,reverse:a}=i;Te(r,"cumprod");const l=Rn([s],r.shape.length);let c=r;null!=l&&(c=$r({inputs:{x:r},backend:e,attrs:{perm:l}}));const d=Xn(1,r.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const u=Gr(c.dtype,"int32"),h=rI(K(c.shape),u),p=e.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=a?(_,b)=>_+f-b-1:(_,b)=>_+b;for(let _=0;_<p.length;_+=f)for(let b=0;b<f;b++){const y=m(_,b);if(0===b)h[y]=o?1:p[y];else{const v=m(_,b-1);h[y]=o?p[v]*h[v]:p[y]*h[v]}}const g=e.makeTensorInfo(c.shape,u,h);if(null!=l){const b=$r({inputs:{x:g},backend:e,attrs:{perm:Vl(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}},WMe={kernelName:Sv,backendName:"cpu",kernelFunc:function jMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,exclusive:o,reverse:a}=i;Te(r,"cumsum");const l=Rn([s],r.shape.length);let c=r;null!=l&&(c=$r({inputs:{x:r},backend:e,attrs:{perm:l}}));const d=Xn(1,r.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const u=Gr(c.dtype,"int32"),h=Xi(K(c.shape),u),p=e.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=a?(_,b)=>_+f-b-1:(_,b)=>_+b;for(let _=0;_<p.length;_+=f)for(let b=0;b<f;b++){const y=m(_,b);if(0===b)h[y]=o?0:p[y];else{const v=m(_,b-1);h[y]=o?p[v]+h[v]:p[y]+h[v]}}const g=e.makeTensorInfo(c.shape,u,h);if(null!=l){const b=$r({inputs:{x:g},backend:e,attrs:{perm:Vl(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}},qMe={kernelName:vI,backendName:"cpu",kernelFunc:function GMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,weights:s}=t,{size:o,binaryOutput:a}=i;if(1===r.shape.length){const d=jA(e.data.get(r.dataId).values,e.data.get(s.dataId).values,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,d)}if(2===r.shape.length){const d=y8(e.bufferSync(r),e.bufferSync(s),o,a);return e.makeTensorInfo(d.shape,s.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},KMe={kernelName:xI,backendName:"cpu",kernelFunc:function YMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{blockSize:s,dataFormat:o}=i;S("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=r.shape[0],l=r.shape[1],c=r.shape[2],d=r.shape[3],u=l*s,h=c*s,p=d/(s*s),f=e.data.get(r.dataId).values,m=new Float32Array(a*u*h*p);let g=0;for(let _=0;_<a;++_)for(let b=0;b<u;++b){const y=Math.floor(b/s),v=b%s;for(let x=0;x<h;++x){const w=Math.floor(x/s),D=(v*s+x%s)*p;for(let k=0;k<p;++k)m[g++]=f[k+D+d*(w+c*(y+l*_))]}}return e.makeTensorInfo([a,u,h,p],r.dtype,m)}};function C8(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=i;Te([r,s],"depthwiseConv2DNative");const d=Le(r.shape),u=Le(s.shape);let h=l;null==h&&(h=[1,1]),S(Ui(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const p=Ti(r.shape,s.shape,o,h,a,c,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:_,padInfo:b}=p,y=b.left,v=b.top,x=p.outChannels/p.inChannels,w=new Zi(p.outShape,r.dtype),C=e.data.get(r.dataId).values,D=e.data.get(s.dataId).values,k=w.values;for(let I=0;I<p.batchSize;++I){const A=I*d[0],$=I*w.strides[0];for(let H=0;H<p.outHeight;++H){const W=$+H*w.strides[1],z=H*p.strideHeight-v;for(let M=0;M<f;++M){const F=z+M*g;if(F<0||F>=p.inHeight)continue;const L=M*u[0],j=A+F*d[1];for(let Z=0;Z<p.outWidth;++Z){const ee=W+Z*w.strides[2],se=Z*p.strideWidth-y;for(let re=0;re<m;++re){const ae=se+re*_;if(ae<0||ae>=p.inWidth)continue;const xe=j+ae*p.inChannels;let Ce=ee,Pe=L+re*u[1];for(let Ae=0;Ae<p.inChannels;++Ae){const Xe=C[xe+Ae];for(let tt=0;tt<x;++tt)k[Ce+tt]+=Xe*D[Pe+tt];Ce+=x,Pe+=x}}}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const XMe={kernelName:kv,backendName:"cpu",kernelFunc:C8},QMe={kernelName:wI,backendName:"cpu",kernelFunc:function ZMe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,dy:s}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:d}=i;Te([r,s],"depthwiseConv2dNativeBackpropFilter");const u=Ti(r.shape,d,o,a,l,c,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=u,g=new Zi(u.filterShape,"float32"),_=u.padInfo.left,b=u.padInfo.top,y=u.outChannels/u.inChannels,v=e.data.get(r.dataId).values,x=new Zi(r.shape,r.dtype,v),w=e.data.get(s.dataId).values,C=new Zi(s.shape,s.dtype,w);for(let D=0;D<f;++D){const k=Math.max(0,Math.ceil((b-D)/h)),I=Math.min(u.outHeight,(u.inHeight+b-D)/h);for(let A=0;A<m;++A){const $=Math.max(0,Math.ceil((_-A)/p)),H=Math.min(u.outWidth,(u.inWidth+_-A)/p);for(let W=0;W<u.outChannels;++W){const z=Math.trunc(W/y),M=W%y;let F=0;for(let L=0;L<u.batchSize;++L)for(let j=k;j<I;++j){const Z=D+j*h-b;for(let ee=$;ee<H;++ee)F+=x.get(L,Z,A+ee*p-_,z)*C.get(L,j,ee,W)}g.set(F,D,A,z,M)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},eNe={kernelName:CI,backendName:"cpu",kernelFunc:function JMe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,filter:s}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:d}=i;Te([r,s],"depthwiseConv2DNativeBackpropInput");const u=Le(r.shape),h=Le(s.shape),p=Ti(d,s.shape,o,a,l,c,!0),f=new Zi(p.inShape,"float32"),m=f.values,[g,_,b]=f.strides,y=e.data.get(r.dataId).values,[v,x,w]=u,C=e.data.get(s.dataId).values,[D,k,I]=h,{batchSize:A,filterHeight:$,filterWidth:H,inChannels:W,inHeight:z,inWidth:M,outChannels:F,outHeight:L,outWidth:j,strideHeight:Z,strideWidth:ee}=p,se=$-1-p.padInfo.top,re=H-1-p.padInfo.left,ae=F/W;for(let pe=0;pe<A;++pe)for(let xe=0;xe<W;++xe)for(let Ce=0;Ce<z;++Ce){const Pe=Ce-se,Ae=Math.max(0,Math.ceil(Pe/Z)),Xe=Math.min(L,($+Pe)/Z);for(let tt=0;tt<M;++tt){const Qt=tt-re,fn=Math.max(0,Math.ceil(Qt/ee)),Bn=Math.min(j,(H+Qt)/ee);let mn=0;for(let nn=Ae;nn<Xe;++nn){const Pn=nn*Z-Pe;for(let In=fn;In<Bn;++In){const Wi=v*pe+x*nn+w*In,oc=D*($-1-Pn)+k*(H-1-(In*ee-Qt))+I*xe;for(let Cs=0;Cs<ae;++Cs)mn+=y[Wi+(xe*ae+Cs)]*C[oc+Cs]}}m[g*pe+_*Ce+b*tt+xe]=mn}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}},nNe={kernelName:"Diag",backendName:"cpu",kernelFunc:function tNe(n){const{inputs:t,backend:e}=n,{x:i}=t,r=K(i.shape),s=e.data.get(i.dataId).values,o=vt([r,r],i.dtype),a=o.values;for(let c=0;c<s.length;c++)a[c*r+c]=s[c];const l=[...i.shape,...i.shape];return e.makeTensorInfo(l,o.dtype,o.values)}},iNe={kernelName:Ev,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:i,filter:r}=n,{strides:s,pad:o,dilations:a}=e,l=t,c=l.data.get(i.dataId).values,d=i.shape.length,u=l.data.get(r.dataId).values,h=r.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:_,outWidth:b,padInfo:y,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:C,dilationHeight:D,dilationWidth:k,outShape:I}=ng(i.shape,r.shape,s,o,"NHWC",a),A=K(I),$=I.length,H=ii(i.dtype,A);for(let z=0;z<p;++z)for(let M=0;M<_;++M){const F=M*v-y.top;for(let L=0;L<b;++L){const j=L*x-y.left;for(let Z=0;Z<g;++Z){let ee=Number.MIN_SAFE_INTEGER;for(let re=0;re<w;++re){const ae=F+re*D;if(ae>=0&&ae<f)for(let pe=0;pe<C;++pe){const xe=j+pe*k;if(xe>=0&&xe<m){const Ce=Xo([z,ae,xe,Z],d,Le(i.shape)),Pe=Xo([re,pe,Z],h,Le(r.shape)),Ae=c[Ce]+u[Pe];Ae>ee&&(ee=Ae)}}}H[Xo([z,M,L,Z],$,Le(I))]=ee}}}return{dataId:l.write(Zc(H,i.dtype),I,i.dtype),shape:I,dtype:i.dtype}}},rNe={kernelName:SI,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:i,filter:r,dy:s}=n,{strides:o,pad:a,dilations:l}=e,c=t,d=_o(i.shape,c.data.get(i.dataId).values),u=_o(r.shape,c.data.get(r.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:_,padInfo:b,strideHeight:y,strideWidth:v,filterHeight:x,filterWidth:w,dilationHeight:C,dilationWidth:D,outShape:k}=ng(i.shape,r.shape,o,a,"NHWC",l);S(s.rank===k.length,()=>`Error in ${SI}, dy must have the same rank as output ${k.length}, but got ${s.rank}`);const I=_o(k,c.data.get(s.dataId).values),A=EH(r.shape,r.dtype);for(let H=0;H<h;++H)for(let W=0;W<g;++W){const z=W*y-b.top;for(let M=0;M<_;++M){const F=M*v-b.left;for(let L=0;L<m;++L){let j=Number.MIN_SAFE_INTEGER,Z=0,ee=0;for(let se=0;se<x;++se){const re=z+se*C;if(re>=0&&re<p)for(let ae=0;ae<w;++ae){const pe=F+ae*D;if(pe>=0&&pe<f){const xe=d[H][re][pe][L]+u[se][ae][L];xe>j&&(j=xe,Z=se,ee=ae)}}}A[Z][ee][L]+=I[H][W][M][L]}}}return{dataId:c.write(Zc(A,i.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},sNe={kernelName:DI,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:i,filter:r,dy:s}=n,{strides:o,pad:a,dilations:l}=e,c=t,d=_o(i.shape,c.data.get(i.dataId).values),u=_o(r.shape,c.data.get(r.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:_,padInfo:b,strideHeight:y,strideWidth:v,filterHeight:x,filterWidth:w,dilationHeight:C,dilationWidth:D,outShape:k}=ng(i.shape,r.shape,o,a,"NHWC",l);S(s.rank===k.length,()=>`Error in ${DI}, dy must have the same rank as output ${k.length}, but got ${s.rank}`);const I=_o(k,c.data.get(s.dataId).values),A=EH(i.shape,i.dtype);for(let H=0;H<h;++H)for(let W=0;W<g;++W){const z=W*y-b.top;for(let M=0;M<_;++M){const F=M*v-b.left;for(let L=0;L<m;++L){let j=Number.MIN_SAFE_INTEGER,Z=z<0?0:z,ee=F<0?0:F;for(let se=0;se<x;++se){const re=z+se*C;if(re>=0&&re<p)for(let ae=0;ae<w;++ae){const pe=F+ae*D;if(pe>=0&&pe<f){const xe=d[H][re][pe][L]+u[se][ae][L];xe>j&&(j=xe,Z=re,ee=pe)}}}A[H][Z][ee][L]+=I[H][W][M][L]}}}return{dataId:c.write(Zc(A,i.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},WA=ri((n,t)=>n*t),oNe=zA((n,t,e,i)=>({real:n*e-t*i,imag:n*i+t*e})),N0=Ri(Em,WA,oNe),aNe={kernelName:Em,backendName:"cpu",kernelFunc:N0};function Ag(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i;let a;Te(r,"sum"),a="bool"===r.dtype?Zl({inputs:{x:r},backend:e,attrs:{dtype:"int32"}}):ca({inputs:{x:r},backend:e});const l=a.shape.length,c=yt(s,a.shape),d=Rn(c,l);let u=c,h=a;null!=d&&(h=$r({inputs:{x:a},backend:e,attrs:{perm:d}}),u=Xn(u.length,l)),Hi("sum",u,h.shape.length);const[p,f]=Ai(h.shape,u);let g=M0(e,p,Gr(h.dtype,"int32"));const _=K(f),b=e.data.get(g.dataId).values,y=e.data.get(h.dataId).values;for(let v=0;v<b.length;++v){const x=v*_;let w=0;for(let C=0;C<_;++C)w+=y[x+C];b[v]=w}if(o){const x=g;g=hn({inputs:{x:g},backend:e,attrs:{shape:Kn(g.shape,c)}}),e.disposeIntermediateTensorInfo(x)}return e.disposeIntermediateTensorInfo(a),null!=d&&e.disposeIntermediateTensorInfo(h),g}const lNe={kernelName:ox,backendName:"cpu",kernelFunc:Ag},dNe={kernelName:"Einsum",backendName:"cpu",kernelFunc:function cNe(n){const{inputs:t,backend:e,attrs:i}=n,{equation:r}=i,s=t,{allDims:o,summedDims:a,idDims:l}=MT(r,s.length);RT(o.length,l,s);const{path:c,steps:d}=OT(a,l),u=d.length;let h=null,p=o.length;const f=[];for(let m=0;m<u;++m){for(const g of d[m]){const{permutationIndices:_,expandDims:b}=NT(p,l[g]);let y;FT(_)?y=s[g]:(y=$r({inputs:{x:s[g]},backend:e,attrs:{perm:_}}),f.push(y));const v=y.shape.slice();for(let x=0;x<b.length;++x)v.splice(b[x],0,1);Ut(y.shape,v)||(y=hn({inputs:{x:y},backend:e,attrs:{shape:v}}),f.push(y)),null===h?h=y:(h=N0({inputs:{a:y,b:h},backend:e}),f.push(h))}m<u-1&&(c[m]>=0&&(h=Ag({inputs:{x:h},backend:e,attrs:{axis:c[m]-(o.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},hNe={kernelName:kI,backendName:"cpu",kernelFunc:function uNe(n){const{inputs:t,backend:e}=n,{dy:i,y:r}=t;Te([i,r],"eluGrad");const s=new Float32Array(K(r.shape)),o=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];s[l]=c>=1?a[l]:a[l]*(c+1)}return e.makeTensorInfo(r.shape,"float32",s)}},D8=ri((n,t)=>n===t?1:0),S8=Ri(Iv,D8,null,"bool"),pNe={kernelName:Iv,backendName:"cpu",kernelFunc:S8},fNe=CT,mNe=DT,gNe=ST,_Ne=kT,bNe=ET,yNe=IT,vNe=Zt(hm,n=>{const t=Math.sign(n),e=Math.abs(n),i=1/(1+fNe*e);return t*(1-((((yNe*i+bNe)*i+_Ne)*i+gNe)*i+mNe)*i*Math.exp(-e*e))}),xNe={kernelName:hm,backendName:"cpu",kernelFunc:vNe},k8=Xl(n=>Math.exp(n)),E8=wh(pm,k8,"float32"),wNe={kernelName:pm,backendName:"cpu",kernelFunc:E8};function R0(n){const{inputs:t,backend:e,attrs:i}=n,{input:r}=t,{dim:s}=i,o=r.shape.length,a=r.shape.slice();let l=s;return s<0&&(S(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),hn({inputs:{x:r},backend:e,attrs:{shape:a}})}const CNe={kernelName:Tv,backendName:"cpu",kernelFunc:R0},I8=Xl(n=>Math.expm1(n)),DNe=wh(fm,I8),SNe={kernelName:fm,backendName:"cpu",kernelFunc:DNe},kNe=ri((n,t)=>n/t),GA=Ri(dm,kNe),qA={kernelName:dm,backendName:"cpu",kernelFunc:GA},T8=ri((n,t)=>n-t),ENe=zA((n,t,e,i)=>({real:n-e,imag:t-i})),YA=Ri(Um,T8,ENe),INe={kernelName:Um,backendName:"cpu",kernelFunc:YA};function A8(n,t,e){const i=n.shape,r=i[0],s=i[1],o=e.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[r,s],d=K(c),u=zi("float32",d),h=zi("float32",d);for(let g=0;g<r;g++){const _=yd({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,s]}}),b=yd({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,s]}}),y=Kr({inputs:{real:_,imag:b},backend:e}),{real:v,imag:x}=TNe(y,t,e),w=qa(v,x);for(let C=0;C<s;C++){const D=TT(w,C);u[g*s+C]=D.real,h[g*s+C]=D.imag}e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(y)}const p=e.makeTensorInfo(c,"float32",u),f=e.makeTensorInfo(c,"float32",h),m=Kr({inputs:{real:p,imag:f},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),m}function TNe(n,t,e){const i=K(n.shape),r=e.data.get(n.dataId),s=e.data.get(r.complexTensorInfos.real.dataId).values,o=e.data.get(r.complexTensorInfos.imag.dataId).values;if(function ANe(n){return 0==(n&n-1)}(i)){const a=KA(s,o,i,t,e),l=[n.shape[0],n.shape[1]];if(t){const c=e.makeTensorInfo(l,"float32",a.real),d=e.makeTensorInfo(l,"float32",a.imag),u=e.makeTensorInfo([],"float32",Ml(i,"float32")),h=ca({inputs:{x:u},backend:e}),p=qA.kernelFunc({inputs:{a:c,b:u},backend:e}),f=qA.kernelFunc({inputs:{a:d,b:h},backend:e}),m=e.data.get(p.dataId).values,g=e.data.get(f.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return a}{const l=function MNe(n,t,e){const i=new Float32Array(2*t);for(let r=0;r<t;r++){let s=0,o=0;for(let a=0;a<t;a++){const l=Rj(r*a,t,e),c=TT(n,a);s+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}e&&(s/=t,o/=t),Mj(i,s,o,r)}return i}(qa(s,o),i,t);return Ij(l)}}function KA(n,t,e,i,r){if(1===e)return{real:n,imag:t};const s=qa(n,t),o=e/2,a=Tj(s),l=a.real,c=a.imag,d=[l.length],u=r.makeTensorInfo(d,"float32",l),h=r.makeTensorInfo(d,"float32",c),p=Kr({inputs:{real:u,imag:h},backend:r}),f=Aj(s),m=f.real,g=f.imag,_=[m.length],b=r.makeTensorInfo(_,"float32",m),y=r.makeTensorInfo(_,"float32",g),v=Kr({inputs:{real:b,imag:y},backend:r}),x=KA(l,c,o,i,r),w=x.real,C=x.imag,D=[w.length],k=r.makeTensorInfo(D,"float32",w),I=r.makeTensorInfo(D,"float32",C),A=Kr({inputs:{real:k,imag:I},backend:r}),$=KA(m,g,o,i,r),H=$.real,W=$.imag,z=[H.length],M=r.makeTensorInfo(z,"float32",H),F=r.makeTensorInfo(z,"float32",W),L=Kr({inputs:{real:M,imag:F},backend:r}),j=Nj(e,i),Z=[j.real.length],ee=r.makeTensorInfo(Z,"float32",j.real),se=r.makeTensorInfo(Z,"float32",j.imag),re=Kr({inputs:{real:ee,imag:se},backend:r}),ae=N0({inputs:{a:re,b:L},backend:r}),pe=Ch({inputs:{a:A,b:ae},backend:r}),xe=YA({inputs:{a:A,b:ae},backend:r}),Ce=bd({inputs:{input:pe},backend:r}),Pe=bd({inputs:{input:xe},backend:r}),Ae=Dh({inputs:{input:pe},backend:r}),Xe=Dh({inputs:{input:xe},backend:r}),tt=Sh({inputs:[Ce,Pe],backend:r,attrs:{axis:0}}),Qt=Sh({inputs:[Ae,Xe],backend:r,attrs:{axis:0}}),fn=r.data.get(tt.dataId).values,Bn=r.data.get(Qt.dataId).values;return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(se),r.disposeIntermediateTensorInfo(re),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(pe),r.disposeIntermediateTensorInfo(xe),r.disposeIntermediateTensorInfo(Ce),r.disposeIntermediateTensorInfo(Ae),r.disposeIntermediateTensorInfo(Pe),r.disposeIntermediateTensorInfo(Xe),r.disposeIntermediateTensorInfo(tt),r.disposeIntermediateTensorInfo(Qt),{real:fn,imag:Bn}}const RNe={kernelName:"FFT",backendName:"cpu",kernelFunc:function NNe(n){const{inputs:t,backend:e}=n,{input:i}=t,r=K(i.shape),s=i.shape[i.shape.length-1],a=hn({inputs:{x:i},backend:e,attrs:{shape:[r/s,s]}}),l=A8(a,!1,e),c=hn({inputs:{x:l},backend:e,attrs:{shape:i.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}};function XA(n){const{backend:t,attrs:e}=n,{shape:i,value:r,dtype:s}=e,o=s||Zf(r),a=ii(o,K(i));return function FNe(n,t,e){n.fill(t)}(a,r),t.makeTensorInfo(i,o,a)}const ONe={kernelName:II,backendName:"cpu",kernelFunc:XA},PNe={kernelName:TI,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:i}=n,r=e,s=zi(i.dtype,K(i.shape)),[o,a,l,c]=i.shape,d=r.data.get(i.dataId).values;for(let h=0;h<o;h++){const p=h*l*a*c;for(let f=0;f<a;f++){const m=f*(l*c);for(let g=0;g<l;g++){const _=g*c;for(let b=0;b<c;b++){const y=Math.round(l-g-1),v=p+m+_+b;let x=d[v];y>=0&&y<l&&(x=d[p+m+y*c+b]),s[v]=x}}}}return{dataId:r.write(s,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},M8=Xl(n=>Math.floor(n)),LNe=wh(mm,M8),$Ne={kernelName:mm,backendName:"cpu",kernelFunc:LNe},VNe=ri((n,t)=>Math.floor(n/t)),BNe=Ri(gm,VNe,null,"int32"),zNe={kernelName:gm,backendName:"cpu",kernelFunc:BNe},HNe={kernelName:fx,backendName:"cpu",kernelFunc:function UNe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:d,dilations:u,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=i;let m=w8({inputs:{x:r,filter:s},backend:e,attrs:{strides:l,pad:c,dataFormat:d,dilations:u,dimRoundingMode:h}});if(o){const g=m;if("NCHW"===d&&1===o.shape.length&&1!==o.shape[0]){const _=hn({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});m=Ch({inputs:{a:m,b:_},backend:e}),e.disposeIntermediateTensorInfo(_)}else m=Ch({inputs:{a:m,b:o},backend:e});e.disposeIntermediateTensorInfo(g)}if(p){const g=m;if("NCHW"===d&&"prelu"===p&&1===a.shape.length&&1!==a.shape[0]){const _=hn({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});m=A0(e,m,p,_,f),e.disposeIntermediateTensorInfo(_)}else m=A0(e,m,p,a,f);e.disposeIntermediateTensorInfo(g)}return m}},WNe={kernelName:mx,backendName:"cpu",kernelFunc:function jNe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:d,dilations:u,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=i;let m=C8({inputs:{x:r,filter:s},backend:e,attrs:{strides:l,pad:c,dataFormat:d,dilations:u,dimRoundingMode:h}});if(o){const g=m;m=Ch({inputs:{a:m,b:o},backend:e}),e.disposeIntermediateTensorInfo(g)}if(p){const g=m;m=A0(e,m,p,a,f),e.disposeIntermediateTensorInfo(g)}return m}};function N8(n,t,e,i,r,s,o,a,l){const c=vt([i,s],e);for(let d=0;d<i;d++){const u=[];let h=0;for(let p=0;p<r;p++){const f=n[d*r+p];h+=f*o[p],u.push(f)}if(h<0||h>=l/s)throw new Error(`Invalid indices: ${u} does not index into ${a}`);for(let p=0;p<s;p++)c.values[d*s+p]=t.get(...t.indexToLoc(h*s+p))}return c}const qNe={kernelName:OH,backendName:"cpu",kernelFunc:function GNe(n){const{inputs:t,backend:e}=n,{params:i,indices:r}=t,s=K(i.shape),o=r.shape,a=o[o.length-1],[l,c,d,u]=wT(i,r);if(0===c)return e.makeTensorInfo(l,i.dtype,[]);const f=N8(e.data.get(r.dataId).values,e.bufferSync(i),i.dtype,c,a,d,u,i.shape,s);return e.makeTensorInfo(l,i.dtype,f.values)}};function R8(n,t,e){const i=vt(e,n.dtype);for(let r=0;r<i.size;++r){const o=i.indexToLoc(r).slice(),c=t.locToIndex([o[0],o[2]]);o[2]=t.values[c];const d=n.locToIndex(o);0<=d&&d<n.values.length&&(i.values[r]=n.values[d])}return i}const KNe={kernelName:Mv,backendName:"cpu",kernelFunc:function YNe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,indices:s}=t,{axis:o,batchDims:a}=i;Te([r,s],"gatherV2");const l=yt(o,r.shape)[0],c=e.data.get(s.dataId).values,d=r.shape[l];for(let v=0;v<c.length;++v){const x=c[v];S(x<=d-1&&x>=0,()=>`GatherV2: the index value ${x} is not in [0, ${d-1}]`)}let u=a;null==a&&(u=0);const h=K(s.shape),p=$T(r,s,l,u),f=hn({inputs:{x:r},backend:e,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=hn({inputs:{x:s},backend:e,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],_=e.bufferSync(m),y=R8(e.bufferSync(f),_,g);return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.makeTensorInfo(p.outputShape,y.dtype,y.values)}},O8=ri((n,t)=>n>t?1:0),XNe=Ri(Nv,O8,null,"bool"),ZNe={kernelName:Nv,backendName:"cpu",kernelFunc:XNe},F8=ri((n,t)=>n>=t?1:0),QNe=Ri(_m,F8,null,"bool"),JNe={kernelName:_m,backendName:"cpu",kernelFunc:QNe},tRe={kernelName:AI,backendName:"cpu",kernelFunc:function eRe(n){const{inputs:t,backend:e}=n,{input:i}=t,r=K(i.shape),s=i.shape[i.shape.length-1],a=hn({inputs:{x:i},backend:e,attrs:{shape:[r/s,s]}}),l=A8(a,!0,e),c=hn({inputs:{x:l},backend:e,attrs:{shape:i.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}},nRe=Zt(ym,n=>Number.isFinite(n)?1:0,"bool"),iRe={kernelName:ym,backendName:"cpu",kernelFunc:nRe},rRe=Zt(vm,n=>Math.abs(n)===1/0?1:0,"bool"),sRe={kernelName:vm,backendName:"cpu",kernelFunc:rRe},oRe=Zt(xm,n=>Number.isNaN(n)?1:0,"bool"),aRe={kernelName:xm,backendName:"cpu",kernelFunc:oRe},P8=ri((n,t)=>n<t?1:0),lRe=Ri(Ov,P8,null,"bool"),cRe={kernelName:Ov,backendName:"cpu",kernelFunc:lRe},L8=ri((n,t)=>n<=t?1:0),dRe=Ri(Fv,L8,null,"bool"),uRe={kernelName:Fv,backendName:"cpu",kernelFunc:dRe};function $8(n,t,e){const i=(t-n)/(e-1),r=Xi(e,"float32");r[0]=n;for(let s=1;s<r.length;s++)r[s]=r[s-1]+i;return r}const pRe={kernelName:FH,backendName:"cpu",kernelFunc:function hRe(n){const{backend:t,attrs:e}=n,{start:i,stop:r,num:s}=e,o=$8(i,r,s);return t.makeTensorInfo([o.length],"float32",o)}},V8=Xl(n=>Math.log(n)),fRe=wh(wm,V8),mRe={kernelName:wm,backendName:"cpu",kernelFunc:fRe},gRe=Zt(Cm,n=>Math.log1p(n)),_Re={kernelName:Cm,backendName:"cpu",kernelFunc:gRe},bRe=ri((n,t)=>n&&t),yRe=Ri(Pv,bRe,null,"bool"),vRe={kernelName:Pv,backendName:"cpu",kernelFunc:yRe},xRe=Zt(Lv,n=>n?0:1,"bool"),wRe={kernelName:Lv,backendName:"cpu",kernelFunc:xRe},CRe=ri((n,t)=>n||t),DRe=Ri($v,CRe,null,"bool"),SRe={kernelName:$v,backendName:"cpu",kernelFunc:DRe},ERe={kernelName:Vv,backendName:"cpu",kernelFunc:function kRe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{depthRadius:s,bias:o,alpha:a,beta:l}=i;Te(r,"LRN");const c=r.shape[3],d=c-1,u=e.data.get(r.dataId).values,h=K(r.shape),p=new Float32Array(h);function f(m){const g=m%c;let _=m-g+Math.max(0,g-s);const b=m-g+Math.min(g+s,d);let y=0;for(;_<=b;_++){const v=u[_];y+=v*v}return y}for(let m=0;m<h;m++){const g=f(m),_=u[m]*Math.pow(o+a*g,-l);p[m]=_}return e.makeTensorInfo(r.shape,r.dtype,p)}},TRe={kernelName:NI,backendName:"cpu",kernelFunc:function IRe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,y:s,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:d}=i;Te(o,"LRNGrad");const u=K(o.shape),h=o.shape[3],p=e.data.get(o.dataId).values,f=e.data.get(r.dataId).values,m=e.data.get(s.dataId).values,g=new Float32Array(u),_=u;for(let b=0;b<_;b++){const y=b%h,v=b-y+Math.max(0,y-a),x=b-y+Math.min(h,y+a+1);let w=0;for(let C=v;C<x;C++)w+=Math.pow(f[C],2);w=c*w+l;for(let C=v;C<x;C++){let D=-2*c*d*f[C]*m[b]/w;b===C&&(D+=Math.pow(w,-d)),D*=p[b],g[C]+=D}}return e.makeTensorInfo(o.shape,r.dtype,g)}};function B8(n,t,e,i){const r=zi(i,K(e));for(let s=0;s<r.length;++s){const o=s*t;let a=n[o];for(let l=0;l<t;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}r[s]=a}return r}function z8(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{reductionIndices:s,keepDims:o}=i,a=e;let l=r.shape;const c=l.length,d=yt(s,l);let u=d;const h=Rn(u,c);let p=a.data.get(r.dataId).values;if(null!=h){const v=new Array(c);for(let x=0;x<v.length;x++)v[x]=l[h[x]];p=UA(p,l,r.dtype,h,v),u=Xn(u.length,c),l=v}Te(r,"max"),Hi("max",u,c);const[f,m]=Ai(l,u),_=B8(p,K(m),f,r.dtype),b=a.write(_,f,r.dtype);let y=f;return o&&(y=Kn(f,d)),{dataId:b,shape:y,dtype:r.dtype}}const ARe={kernelName:Bv,backendName:"cpu",kernelFunc:z8},U8=ri((n,t)=>Math.max(n,t)),MRe=Ri(Dm,U8),NRe={kernelName:Dm,backendName:"cpu",kernelFunc:MRe},ORe={kernelName:zv,backendName:"cpu",kernelFunc:function RRe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t;Te(r,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i;S(Ui(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=Hs(r.shape,s,o,1,a,l);let u;if(1===d.filterWidth&&1===d.filterHeight&&Ut(d.inShape,d.outShape))u=ca({inputs:{x:r},backend:e});else{const h=e.data.get(r.dataId).values,p=Le(r.shape),f=HA(h,0,r.dtype,p,d,"max");u=e.makeTensorInfo(d.outShape,r.dtype,f.values)}return u}},PRe={kernelName:Uv,backendName:"cpu",kernelFunc:function FRe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=i;Te(r,"maxPool3d");const d=Ua(r.shape,s,o,1,a,l,c),h=_8(e.data.get(r.dataId).values,0,r.dtype,Le(r.shape),d,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},$Re={kernelName:OI,backendName:"cpu",kernelFunc:function LRe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,input:s}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=i;Te([r,s],"maxPool3DGrad");const d=Ua(s.shape,o,a,1,l,c),h=function eMe(n,t){const e=vt(t.outShape,"int32"),i=t.strideDepth,r=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,d=t.effectiveFilterHeight,u=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let _=0;_<t.outDepth;++_){const b=_*i-h;let y=b;for(;y<0;)y+=o;const v=Math.min(t.inDepth,c+b);for(let x=0;x<t.outHeight;++x){const w=x*r-p;let C=w;for(;C<0;)C+=a;const D=Math.min(t.inHeight,d+w);for(let k=0;k<t.outWidth;++k){const I=k*s-f;let A=I;for(;A<0;)A+=l;const $=Math.min(t.inWidth,u+I);let H=Number.NEGATIVE_INFINITY,W=-1;for(let z=y;z<v;z+=o){const M=z-b;for(let F=C;F<D;F+=a){const L=F-w;for(let j=A;j<$;j+=l){const Z=j-I,ee=n.get(m,z,F,j,g);ee>=H&&(H=ee,W=M*d*u+L*d+Z)}}}e.set(W,m,_,x,k,g)}}}return e}(e.bufferSync(s),d),p=d.strideDepth,f=d.strideHeight,m=d.strideWidth,g=d.dilationDepth,_=d.dilationHeight,b=d.dilationWidth,y=d.effectiveFilterDepth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=y-1-d.padInfo.front,C=x-1-d.padInfo.left,D=v-1-d.padInfo.top,k=vt(s.shape,"float32"),I=e.bufferSync(r);for(let A=0;A<d.batchSize;++A)for(let $=0;$<d.inChannels;++$)for(let H=0;H<d.inDepth;++H)for(let W=0;W<d.inHeight;++W)for(let z=0;z<d.inWidth;++z){const M=H-w,F=W-D,L=z-C;let j=0;for(let Z=0;Z<y;Z+=g){const ee=(M+Z)/p;if(!(ee<0||ee>=d.outDepth||Math.floor(ee)!==ee))for(let se=0;se<v;se+=_){const re=(F+se)/f;if(!(re<0||re>=d.outHeight||Math.floor(re)!==re))for(let ae=0;ae<x;ae+=b){const pe=(L+ae)/m;if(pe<0||pe>=d.outWidth||Math.floor(pe)!==pe)continue;const Pe=y*v*x-1-h.get(A,ee,re,pe,$)===Z*v*x+se*x+ae?1:0;0!==Pe&&(j+=I.get(A,ee,re,pe,$)*Pe)}}}k.set(j,A,H,W,z,$)}return e.makeTensorInfo(k.shape,k.dtype,k.values)}},BRe={kernelName:RI,backendName:"cpu",kernelFunc:function VRe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,input:s,output:o}=t,a=s;Te([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:u}=i,h=Hs(a.shape,l,c,1,d,u),p=e.data.get(a.dataId).values,f=vt(h.outShape,a.dtype,g8(p,a.shape,a.dtype,h).values),m=h.strideHeight,g=h.strideWidth,_=h.dilationHeight,b=h.dilationWidth,y=h.effectiveFilterHeight,v=h.effectiveFilterWidth,x=v-1-h.padInfo.left,w=y-1-h.padInfo.top,C=vt(a.shape,"float32"),D=e.data.get(r.dataId).values,k=vt(r.shape,"float32",D);for(let I=0;I<h.batchSize;++I)for(let A=0;A<h.inChannels;++A)for(let $=0;$<h.inHeight;++$)for(let H=0;H<h.inWidth;++H){const W=$-w,z=H-x;let M=0;for(let F=0;F<y;F+=_){const L=(W+F)/m;if(!(L<0||L>=h.outHeight||Math.floor(L)!==L))for(let j=0;j<v;j+=b){const Z=(z+j)/g;if(Z<0||Z>=h.outWidth||Math.floor(Z)!==Z)continue;const re=y*v-1-f.get(I,L,Z,A)===F*v+j?1:0;0!==re&&(M+=k.get(I,L,Z,A)*re)}}C.set(M,I,$,H,A)}return e.makeTensorInfo(C.shape,C.dtype,C.values)}},URe={kernelName:PH,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:i}=n,{filterSize:r,strides:s,pad:o,includeBatchInIndex:a}=t,l=e;Te(i,"MaxPoolWithArgmax");const c=l.data.get(i.dataId).values,d=Hs(i.shape,r,s,[1,1],o),[u,h]=function zRe(n,t,e,i,r){const o=HA(n,0,e,Le(t),r,"max"),a=g8(n,t,e,r,!0,i);return[o.values,a.values]}(c,i.shape,i.dtype,a,d),p=l.write(u,d.outShape,i.dtype),f=l.write(h,d.outShape,i.dtype);return[{dataId:p,shape:d.outShape,dtype:i.dtype},{dataId:f,shape:d.outShape,dtype:"int32"}]}},jRe={kernelName:Hv,backendName:"cpu",kernelFunc:function HRe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i,a=yt(s,r.shape),d=K(Ai(r.shape,a)[1]),u=[],h=e.makeTensorInfo([],"float32",new Float32Array([d]));u.push(h);const p=Zl({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});u.push(p);const f=GA({inputs:{a:p,b:h},backend:e});u.push(f);const m=Ag({inputs:{x:f},backend:e,attrs:{axis:s,keepDims:o}});return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}},GRe={kernelName:jv,backendName:"cpu",kernelFunc:function WRe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i;Te(r,"min");const a=yt(s,r.shape);let l=a;const c=Rn(l,r.shape.length);let d=r;null!=c&&(d=$r({inputs:{x:r},backend:e,attrs:{perm:c}}),l=Xn(l.length,r.shape.length)),Hi("min",l,d.shape.length);const[u,h]=Ai(d.shape,l),p=K(h),f=Xi(K(u),d.dtype),m=e.data.get(d.dataId).values;for(let _=0;_<f.length;++_){const b=_*p;let y=m[b];for(let v=0;v<p;++v){const x=m[b+v];(Number.isNaN(x)||x<y)&&(y=x)}f[_]=y}null!=c&&e.disposeIntermediateTensorInfo(d);const g=e.makeTensorInfo(u,d.dtype,f);if(o){const b=hn({inputs:{x:g},backend:e,attrs:{shape:Kn(u,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},H8=ri((n,t)=>Math.min(n,t)),qRe=Ri(Sm,H8),YRe={kernelName:Sm,backendName:"cpu",kernelFunc:qRe},XRe={kernelName:Wv,backendName:"cpu",kernelFunc:function KRe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{paddings:s,mode:o}=i;Te(r,"mirrorPad");const a=s.map((y,v)=>y[0]+r.shape[v]+y[1]),l=s.map(y=>y[0]),c=s.map((y,v)=>y[0]+r.shape[v]),d="reflect"===o?0:1,u=e.data.get(r.dataId).values,h=r.shape.length,p=Le(r.shape),f=K(a),m=a.length,g=Le(a),_=zi(r.dtype,f);for(let y=0;y<f;y++){let v=Qu(y,m,g);for(let w=0;w<m;w++)v[w]<l[w]?v[w]=2*l[w]-v[w]-d:v[w]>=c[w]&&(v[w]=2*(c[w]-1)-v[w]+d);v=v.map((w,C)=>w-l[C]);const x=Xo(v,h,p);_[y]=u[x]}return{dataId:e.write(_,a,r.dtype),shape:a,dtype:r.dtype}}},ZRe=ri((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),QRe=Ri(km,ZRe),JRe={kernelName:km,backendName:"cpu",kernelFunc:QRe};function j8(n){const{inputs:t,backend:e,attrs:i}=n,{logits:r}=t,{dim:s}=i,o=r.shape.length;let a=s;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=yt([a],r.shape),c=z8({inputs:{x:r},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),d=Kn(c.shape,l),u=hn({inputs:{x:c},backend:e,attrs:{shape:d}}),h=YA({inputs:{a:r,b:u},backend:e}),p=E8({inputs:{x:h},backend:e}),f=Ag({inputs:{x:p},backend:e,attrs:{axis:l,keepDims:!1}}),m=hn({inputs:{x:f},backend:e,attrs:{shape:d}}),g=GA({inputs:{a:p,b:m},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}const eOe={kernelName:cx,backendName:"cpu",kernelFunc:j8},nOe={kernelName:LH,backendName:"cpu",kernelFunc:function tOe(n){const{inputs:t,backend:e,attrs:i}=n,{logits:r}=t,{numSamples:s,seed:o,normalized:a}=i;Te(r,"multinomial");const l=a?r:j8({inputs:{logits:r},backend:e,attrs:{dim:-1}}),c=l.shape[0],d=l.shape[1],u=e.data.get(l.dataId).values,h=[c,s],p=Xi(K(h),"int32");for(let f=0;f<c;++f){const m=f*d,g=new Float32Array(d-1);g[0]=u[m];for(let y=1;y<g.length;++y)g[y]=g[y-1]+u[m+y];const _=J1.alea(o.toString()),b=f*s;for(let y=0;y<s;++y){const v=_();p[b+y]=g.length;for(let x=0;x<g.length;x++)if(v<g[x]){p[b+y]=x;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",p)}};function W8(n,t,e){const i=Ml(-1,e);return WA([],t,i,n,e)}const rOe={kernelName:Gv,backendName:"cpu",kernelFunc:function iOe(n){const{inputs:t,backend:e}=n,{x:i}=t;Te(i,"neg");const r=e.data.get(i.dataId).values,[s,o]=W8(r,i.shape,i.dtype);return e.makeTensorInfo(o,i.dtype,s)}},sOe=dT,aOe={kernelName:FI,backendName:"cpu",kernelFunc:function oOe(n){const{inputs:t,backend:e,attrs:i}=n,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=i;Te(r,"NonMaxSuppression");const c=e.data.get(r.dataId).values,d=e.data.get(s.dataId).values,{selectedIndices:u}=sOe(c,d,o,a,l);return e.makeTensorInfo([u.length],"int32",new Int32Array(u))}},lOe=uT,dOe={kernelName:PI,backendName:"cpu",kernelFunc:function cOe(n){const{inputs:t,backend:e,attrs:i}=n,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=i;Te(r,"NonMaxSuppressionPadded");const d=e.data.get(r.dataId).values,u=e.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=lOe(d,u,o,a,l,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}},uOe=hT,pOe={kernelName:LI,backendName:"cpu",kernelFunc:function hOe(n){const{inputs:t,backend:e,attrs:i}=n,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=i;Te(r,"NonMaxSuppressionWithScore");const d=e.data.get(r.dataId).values,u=e.data.get(s.dataId).values,h=o,p=a,f=l,m=c,{selectedIndices:g,selectedScores:_}=uOe(d,u,h,p,f,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([_.length],"float32",new Float32Array(_))]}},G8=ri((n,t)=>n!==t?1:0),fOe=Ri(qv,G8,null,"bool"),mOe={kernelName:qv,backendName:"cpu",kernelFunc:fOe},_Oe={kernelName:Kv,backendName:"cpu",kernelFunc:function gOe(n){const{inputs:t,backend:e,attrs:i}=n,{indices:r}=t,{dtype:s,depth:o,onValue:a,offValue:l}=i;Te(r,"oneHot");const c=K(r.shape),d=new Float32Array(c*o);d.fill(l);const u=e.data.get(r.dataId).values;for(let h=0;h<c;++h)u[h]>=0&&u[h]<o&&(d[h*o+u[h]]=a);return e.makeTensorInfo([...r.shape,o],s,d)}};function O0(n){const{inputs:t,backend:e}=n,{x:i}=t;if("string"===i.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===i.dtype){const r=bd({inputs:{input:i},backend:e}),s=O0({inputs:{x:r},backend:e}),o=Dh({inputs:{input:i},backend:e}),a=O0({inputs:{x:o},backend:e}),l=Kr({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return XA({backend:e,attrs:{shape:i.shape,value:0,dtype:i.dtype}})}const bOe={kernelName:hx,backendName:"cpu",kernelFunc:O0},yOe={kernelName:Yv,backendName:"cpu",kernelFunc:function q8(n){const{inputs:t,backend:e}=n,{x:i}=t;if("string"===i.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===i.dtype){const r=bd({inputs:{input:i},backend:e}),s=q8({inputs:{x:r},backend:e}),o=Dh({inputs:{input:i},backend:e}),a=O0({inputs:{x:o},backend:e}),l=Kr({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return XA({backend:e,attrs:{shape:i.shape,value:1,dtype:i.dtype}})}};function Y8(n){const{inputs:t,backend:e,attrs:i}=n,{axis:r}=i;if(1===t.length)return R0({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach(d=>{zs(s,d.shape,"All tensors passed to stack must have matching shapes"),S(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=Sh({inputs:t.map(d=>{const u=R0({inputs:{input:d},backend:e,attrs:{dim:r}});return a.push(u),u}),backend:e,attrs:{axis:r}});return a.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}const vOe={kernelName:Xv,backendName:"cpu",kernelFunc:Y8},K8={kernelName:Zv,backendName:"cpu",kernelFunc:function xOe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{paddings:s,constantValue:o}=i;Te(r,"pad");const a=s.map((b,y)=>b[0]+r.shape[y]+b[1]),l=s.map(b=>b[0]),c=e.data.get(r.dataId).values,d=K(r.shape),u=r.shape.length,h=Le(r.shape),p=K(a),f=a.length,m=Le(a),g=zi(r.dtype,p);0!==o&&g.fill(o);for(let b=0;b<d;b++)g[Xo(Qu(b,u,h).map((w,C)=>w+l[C]),f,m)]=c[b];return{dataId:e.write(g,a,r.dtype),shape:a,dtype:r.dtype}}},wOe=ri((n,t)=>Math.pow(n,t)),COe=Ri(Im,wOe),DOe={kernelName:Im,backendName:"cpu",kernelFunc:COe};function X8(n,t,e,i){const[r,s]=Ai(n,i),o=Gr(t,"int32"),a=Xi(K(r),o),l=K(s);for(let c=0;c<a.length;++c){const d=c*l;let u=1;for(let h=0;h<l;++h)u*=e[d+h];a[c]=u}return{outVals:a,outShape:r,outDtype:o}}const kOe={kernelName:Jv,backendName:"cpu",kernelFunc:function SOe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i;Te(r,"prod");const a=r.shape.length,l=yt(s,r.shape),c=Rn(l,a);let d=l,u=r;const h=[];null!=c&&(u=$r({inputs:{x:r},backend:e,attrs:{perm:c}}),h.push(u),d=Xn(d.length,a));const p=e.data.get(u.dataId).values,{outVals:f,outShape:m,outDtype:g}=X8(u.shape,u.dtype,p,d);let _=m;return o&&(_=Kn(m,l)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(_,g,f)}};function Z8(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let i=t;i<n.length;i++)e[t-1]*=n[i];return e}function Q8(n,t,e,i,r,s,o,a){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function EOe(n,t,e){n.forEach((i,r)=>{if(i<0||i>=e){const s=Qu(r,t.length,Le(t)).join(",");throw new Error(`indices[${s}] = ${i} is not in [0, ${e})`)}})}(s,o,t[0][0]-1),0===i.length)throw new Error("params.rank must be nonzero");const c=i[0],{outSplits:d,valueSlices:u,numValues:h}=function TOe(n,t,e,i){const r=[];let s=0;const a=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function IOe(n,t){for(let e=0;e<n.length;++e){const i=n[e],r=e===n.length-1?t:n[e+1].length;if(0===i.length)throw new Error("Ragged splits may not be empty");if(i[0]<0)throw new Error("Ragged splits must be non-negative");if(i[i.length-1]>r)throw new Error("Ragged splits must not point past values");for(let s=1;s<i.length;++s)if(i[s-1]>i[s])throw new Error("Ragged splits must be sorted in ascending order")}}(e,i);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const d=t[c+1];for(let u=1;u<l+1;++u)a[c].push(u*d)}for(let c=0;c<n.length;++c){let d=n[c],u=n[c]+1;for(let h=0;h<e.length;++h){const p=e[h],f=h+t.length-1;if(f>=0){const m=a[f],g=m[m.length-1]-p[d];for(let _=d;_<u;++_)a[f].push(p[_+1]+g)}d=p[d],u=p[u]}u!==d&&(r.push([d,u]),s+=u-d)}return{outSplits:a,valueSlices:r,numValues:s}}(s,o,n,c),p=function AOe(n){const t=[];for(let e=0;e<n.length;++e){const r=ii("int32",n[e].length);t.push(r),n[e].forEach((s,o)=>r[o]=s)}return t}(d),f=function NOe(n,t,e,i,r){const s=t.slice();s[0]=r;const o=ii(e,K(s)),a=n.length;return function MOe(n,t,e,i,r,s){const o=Z8(t,2)[1],a=Z8(s,2)[1];let l=0;for(const c of e)for(let d=c[0];d<c[1];++d){for(let u=0;u<i;++u)r[l*a+u]=n[d*o+u];++l}}(n,t,i,0===a?0:a/t[0],o,s),[o,s]}(e,i,r,u,h);return[p,f[0],f[1]]}const OOe={kernelName:$H,backendName:"cpu",kernelFunc:function ROe(n){const{inputs:t,backend:e,attrs:i}=n,{paramsNestedSplits:r,paramsDenseValues:s,indices:o}=t,l=r.map(_=>e.data.get(_.dataId).values),c=r.map(_=>_.shape),d=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,[h,p,f]=Q8(l,c,d,s.shape,s.dtype,u,o.shape),m=h.map(_=>e.makeTensorInfo([_.length],"int32",_)),g=e.makeTensorInfo(f,s.dtype,p);return m.concat([g])}},J8=2147483647;function e6(n,t,e,i,r,s,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=0===t.length,l=0===r.length,c=0===o.length,d=[];a||d.push(t[0]),l||d.push(r[0]),c||d.push(o[0]);for(let g=1;g<d.length;++g)if(d[g]!==d[g-1])throw new Error("starts, limits, and deltas must have the same shape");const u=0===d.length?1:d[0],h=ii("int32",u+1);h[0]=0;for(let g=0;g<u;++g){const _=a?n[0]:n[g],b=l?i[0]:i[g],y=c?s[0]:s[g];if(0===y)throw new Error("Requires delta != 0");let v;if(y>0&&b<_||y<0&&b>_)v=0;else if(v=Math.ceil(Math.abs((b-_)/y)),v>J8)throw new Error(`Requires ((limit - start) / delta) <= ${J8}`);h[g+1]=h[g]+v}const f=ii(e,h[u]);let m=0;for(let g=0;g<u;++g){const _=h[g+1]-h[g];let b=a?n[0]:n[g];const y=c?s[0]:s[g];for(let v=0;v<_;++v)f[m++]=b,b+=y}return[h,f]}const POe={kernelName:VH,backendName:"cpu",kernelFunc:function FOe(n){const{inputs:t,backend:e}=n,{starts:i,limits:r,deltas:s}=t,o=e.data.get(i.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,[c,d]=e6(o,i.shape,i.dtype,a,r.shape,l,s.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([d.length],i.dtype,d)]}};var Zs=qs;class F0{constructor(t,e,i,r,s,o,a,l,c,d){this.shape=t,this.shapeShape=e,this.values=i,this.valuesShape=r,this.valuesDType=s,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=Dj(d),this.raggedRank=Sj(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Zs.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Zs.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Zs.VALUE_ROWIDS:return F0.getMaxWidthValueRowID(e);case Zs.ROW_SPLITS:return F0.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Zs[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let i=0;for(let r=0;r<e-1;++r){const s=t[r+1]-t[r];s>i&&(i=s)}return i}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let i=0,r=t[0],s=0;for(let o=1;o<e;++o){const a=t[o];a!==r&&(r=a,s=Math.max(o-i,s),i=o)}return Math.max(e-i,s)}tensorShapeFromTensor(t,e,i=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return n6(t,i)}calculateOutputSize(t){const e=this.valuesShape;kj(this.defaultValueShape,e);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=Cj(this.raggedRank,r,e);o[0]<0&&(o[0]=t);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(t,e,i){const r=Math.min(t,i),s=[];let o=0;for(let a=0;a<r;++a,o+=e)s.push(o);for(let a=r;a<t;++a)s.push(-1);return S(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,e,i,r){const s=t.length,o=[];for(let a=0;a<s-1;++a){const l=t[a+1]-t[a];let c=Math.min(r,l),d=e[a];-1===d&&(c=0);for(let u=0;u<c;++u)o.push(d),d+=i;for(let u=0;u<l-c;++u)o.push(-1)}if(s>0&&o.length!==t[s-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,i,r){const s=t.length,o=[];if(0===s)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let c=e[l];o.push(c);for(let d=1;d<s;++d){const u=t[d];if(u===l)c>=0&&(++a,a<r?c+=i:c=-1);else{if(a=0,l=u,u>=e.length)throw new Error(`Got nextValueRowId=${u} which is not less than ${e.length}`);c=e[u]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,i,r){const s=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case Zs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,i,r);case Zs.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,i,r);default:throw new Error(`Unsupported partition type: ${Zs[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Zs.FIRST_DIM_SIZE:return t[0];case Zs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Zs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Zs[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),i=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*i[l+1];const s=n6(i,!1),o=ii(this.valuesDType,K(s));if(r[0]*i[0]>0){let l=this.calculateFirstParentOutputIndex(e,r[0],i[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,r[c],i[c]);this.setOutput(this.raggedRank,l,o,s)}return[s,o]}setOutput(t,e,i,r){if(0===i.length)return;const s=this.values,o=i;let a=r.slice();a=a.slice(t+1);const l=K(a),c=e.length;let d=this.defaultValue;if(d.length!==l&&1!==d.length){const f=this.defaultValueShape;G(()=>{const m=B(d,f);d=sg(m,a).dataSync()})}let u=0,h=0,p=0;for(let f=0;f<=c;++f){let m=f<c?e[f]:-1;if(m!==p){if(h<p){const g=s.subarray(u*l);t6(o.subarray(h*l),g,(p-h)*l)}if(f>=c&&(m=Math.floor(i.length/l)),m>p)if(1===this.defaultValue.length)o.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;)t6(o.slice(p*l),d,l),++p;m<0?(u=f+1,h=p):(u=f,h=p,p=h+1)}else++p}}}function t6(n,t,e){for(let i=0;i<e;i++)n[i]=t[i]}function n6(n,t){const e=[];for(let i of n){if(i<0){if(!t)throw new Error(`Dimension ${i} must be >= 0`);if(i<-1)throw new Error(`Dimension ${i} must be >= -1`);i=-1}e.push(i)}return e}function r6(n,t,e,i,r,s,o,a,l,c){return new F0(n,t,e,i,r,s,o,a,l,c).compute()}const $Oe={kernelName:BH,backendName:"cpu",kernelFunc:function LOe(n){const{inputs:t,backend:e,attrs:i}=n,{shape:r,values:s,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=i,c=e.data.get(r.dataId).values,d=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,h=a.map(g=>e.data.get(g.dataId).values),p=a.map(g=>g.shape),[f,m]=r6(c,r.shape,d,s.shape,s.dtype,u,o.shape,h,p,l);return e.makeTensorInfo(f,s.dtype,m)}};function s6(n,t,e,i){if(n===t||n<t&&e<0||t<n&&e>1)return Xi(0,i);const l=Xi(Math.abs(Math.ceil((t-n)/e)),i);t<n&&1===e&&(e=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}const BOe={kernelName:$I,backendName:"cpu",kernelFunc:function VOe(n){const{backend:t,attrs:e}=n,{start:i,stop:r,dtype:s,step:o}=e,a=s6(i,r,o,s);return t.makeTensorInfo([a.length],s,a)}},zOe=Zt(Tm,n=>1/n),UOe={kernelName:Tm,backendName:"cpu",kernelFunc:zOe},jOe={kernelName:nx,backendName:"cpu",kernelFunc:function HOe(n){const{inputs:t,backend:e,attrs:i}=n,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:a}=i;Te(r,"resizeBilinear");const l=Le(r.shape),[c,d]=a,[u,h,p,f]=r.shape,m=e.data.get(r.dataId).values,g=new Float32Array(K([u,c,d,f])),_=[s&&c>1?h-1:h,s&&d>1?p-1:p],b=[s&&c>1?c-1:c,s&&d>1?d-1:d];let y=0;const v=_[0]/b[0],x=_[1]/b[1];for(let w=0;w<u;w++)for(let C=0;C<c;C++){let D;D=o?v*(C+.5)-.5:v*C;const k=Math.max(0,Math.floor(D)),I=D-k,A=Math.min(h-1,Math.ceil(D)),$=w*l[0]+k*l[1],H=w*l[0]+A*l[1];for(let W=0;W<d;W++){let z;z=o?x*(W+.5)-.5:x*W;const M=Math.max(0,Math.floor(z)),F=z-M,L=Math.min(p-1,Math.ceil(z)),j=$+M*l[2],Z=H+M*l[2],ee=$+L*l[2],se=H+L*l[2];for(let re=0;re<f;re++){const ae=m[j+re],pe=m[Z+re],Pe=ae+(m[ee+re]-ae)*F;g[y++]=Pe+(pe+(m[se+re]-pe)*F-Pe)*I}}}return e.makeTensorInfo([u,c,d,f],"float32",g)}},GOe={kernelName:zI,backendName:"cpu",kernelFunc:function WOe(n){const{inputs:t,backend:e,attrs:i}=n,{images:r,dy:s}=t,{alignCorners:o}=i;Te([s,r],"resizeBilinearGrad");const a=Le(r.shape),[l,c,d,u]=r.shape,[,h,p]=s.shape,f=new Float32Array(l*c*d*u),m=[o&&h>1?c-1:c,o&&p>1?d-1:d],g=[o&&h>1?h-1:h,o&&p>1?p-1:p],_=m[0]/g[0],b=m[1]/g[1],y=e.data.get(s.dataId).values;let v=0;for(let x=0;x<l;x++){const w=x*a[0];for(let C=0;C<h;C++){const D=C*_,k=Math.floor(D),I=Math.min(Math.ceil(D),c-1),A=w+k*a[1],$=w+I*a[1],H=D-k,W=1-H;for(let z=0;z<p;z++){const M=z*b,F=Math.floor(M),L=Math.min(Math.ceil(M),d-1),j=M-F,Z=1-j,ee=A+F*a[2],se=A+L*a[2],re=$+F*a[2],ae=$+L*a[2],pe=W*Z,xe=W*j,Ce=H*Z,Pe=H*j;for(let Ae=0;Ae<u;Ae++){const Xe=y[v++];f[ee+Ae]+=Xe*pe,f[se+Ae]+=Xe*xe,f[re+Ae]+=Xe*Ce,f[ae+Ae]+=Xe*Pe}}}}return e.makeTensorInfo([l,d,c,u],"float32",f)}},YOe={kernelName:tx,backendName:"cpu",kernelFunc:function qOe(n){const{inputs:t,backend:e,attrs:i}=n,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:a}=i;Te(r,"resizeNearestNeighbor");const l=Le(r.shape),[c,d]=a,[u,h,p,f]=r.shape,m=e.data.get(r.dataId).values,g=new Float32Array(u*c*d*f),_=[s&&c>1?h-1:h,s&&d>1?p-1:p],b=[s&&c>1?c-1:c,s&&d>1?d-1:d],y=_[0]/b[0],v=_[1]/b[1];let x=0;for(let w=0;w<u;w++){const C=w*l[0];for(let D=0;D<c;D++){const k=o?y*(D+.5):y*D;let I=Math.min(h-1,s?Math.round(k):Math.floor(k));o&&(I=Math.max(0,I));const A=C+I*l[1];for(let $=0;$<d;$++){const H=o?v*($+.5):v*$;let W=Math.min(p-1,s?Math.round(H):Math.floor(H));o&&(W=Math.max(0,W));const z=A+W*l[2];for(let M=0;M<f;M++)g[x++]=m[z+M]}}}return e.makeTensorInfo([u,c,d,f],r.dtype,g)}},XOe={kernelName:BI,backendName:"cpu",kernelFunc:function KOe(n){const{inputs:t,backend:e,attrs:i}=n,{images:r,dy:s}=t,{alignCorners:o}=i;Te([s,r],"resizeNearestNeighborGrad");const a=Le(r.shape),l=Le(s.shape),[c,d,u,h]=r.shape,[,p,f]=s.shape,m=new Float32Array(c*d*u*h),g=e.data.get(s.dataId).values,_=[o&&p>1?d-1:d,o&&f>1?u-1:u],b=[o&&p>1?p-1:p,o&&f>1?f-1:f],y=_[0]/b[0],v=_[1]/b[1],x=1/y,w=1/v,C=2*Math.ceil(x)+2,D=2*Math.ceil(w)+2;for(let k=0;k<c;k++){const I=k*a[0];for(let A=0;A<d;A++){const $=I+A*a[1],H=Math.floor(A*x),W=Math.floor(H-C/2);for(let z=0;z<u;z++){const M=$+z*a[2],F=Math.floor(z*w),L=Math.floor(F-D/2);for(let j=0;j<h;j++){let Z=0;for(let ee=0;ee<C;ee++){const se=ee+W;if(se<0||se>=p)continue;const re=I+se*l[1],ae=se*y;if(A===Math.min(d-1,o?Math.round(ae):Math.floor(ae)))for(let xe=0;xe<D;xe++){const Ce=xe+L;if(Ce<0||Ce>=f)continue;const Pe=re+Ce*l[2],Ae=Ce*v;z===Math.min(u-1,o?Math.round(Ae):Math.floor(Ae))&&(Z+=g[Pe+j])}}m[M+j]=Z}}}}return e.makeTensorInfo(r.shape,r.dtype,m)}},QOe={kernelName:ix,backendName:"cpu",kernelFunc:function ZOe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{dims:s}=i;Te(r,"reverse");const o=r.shape.length,a=yt(s,r.shape);if(0===o)return ca({inputs:{x:r},backend:e});const l=new Zi(r.shape,r.dtype),c=e.bufferSync(r);for(let d=0;d<l.size;d++){const u=l.indexToLoc(d),h=u.slice();a.forEach(p=>h[p]=r.shape[p]-1-h[p]),l.set(c.get(...h),...u)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},JOe={kernelName:t1,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:i}=n,{radians:r,fillValue:s,center:o}=t,a=e,l=zi(i.dtype,K(i.shape)),[c,d,u,h]=i.shape,[p,f]=yT(o,d,u),g=Math.sin(r),_=Math.cos(r),b=a.data.get(i.dataId).values;for(let v=0;v<c;v++){const x=v*u*d*h;for(let w=0;w<d;w++){const C=w*(u*h);for(let D=0;D<u;D++){const k=D*h;for(let I=0;I<h;I++){const A=[c,w,D,I],$=A[2],H=A[1];let W=($-p)*_-(H-f)*g,z=($-p)*g+(H-f)*_;W=Math.round(W+p),z=Math.round(z+f);let M=s;"number"!=typeof s&&(M=3===I?255:s[I]),W>=0&&W<u&&z>=0&&z<d&&(M=b[x+z*(u*h)+W*h+I]),l[x+C+k+I]=M}}}}return{dataId:a.write(l,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},eFe=Zt(Nm,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),tFe={kernelName:Nm,backendName:"cpu",kernelFunc:eFe},o6=Xl(n=>1/Math.sqrt(n)),nFe=wh(Rm,o6),iFe={kernelName:Rm,backendName:"cpu",kernelFunc:nFe};function kh(n,t,e,i,r,s,o,a,l,c){const d=[i/r,r],u=n.values,h=t.values;if(0===i)return vt(e,t.dtype);const p=vt(d,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){const m=[];let g=0;for(let _=0;_<o;_++){const b=u[f*o+_];m.push(b),g+=b*a[_]}if(g<0||g>=i/r)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let _=0;_<r;_++)c?p.values[g*r+_]+=h[f*r+_]:p.values[g*r+_]=0===t.rank?h[0]:h[f*r+_]}return p}const sFe={kernelName:zH,backendName:"cpu",kernelFunc:function rFe(n){const{inputs:t,backend:e,attrs:i}=n,{indices:r,updates:s}=t,{shape:o}=i,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:u}=mg(0,r,o),m=kh(e.bufferSync(r),e.bufferSync(s),o,u,c,l,a,d,0,!0);return e.makeTensorInfo(o,m.dtype,m.values)}};function oFe(n,t){let e=0,i=n.length,r=0;for(;e<i;)r=Math.floor((e+i)/2),n[r]<t?e=r+1:i=r;return i}function aFe(n,t){let e=0,i=n.length,r=0;for(;e<i;)r=Math.floor((e+i)/2),n[r]<=t?e=r+1:i=r;return i}const dFe={kernelName:UH,backendName:"cpu",kernelFunc:function cFe(n){const{inputs:t,backend:e,attrs:i}=n,{sortedSequence:r,values:s}=t,{side:o}=i,c=function lFe(n,t,e,i,r,s){const o=ii("int32",e*r);for(let a=0;a<e;++a){const l=n.slice(a*i,(a+1)*i),c=a*r;for(let d=0;d<r;++d)o[c+d]="left"===s?oFe(l,t[d+c]):aFe(l,t[d+c])}return o}(e.data.get(r.dataId).values,e.data.get(s.dataId).values,r.shape[0],r.shape[1],s.shape[1],o);return e.makeTensorInfo(s.shape,"int32",c)}},hFe={kernelName:rx,backendName:"cpu",kernelFunc:function uFe(n){const{inputs:t,backend:e}=n,{condition:i,t:r,e:s}=t;Te([i,r,s],"select");const o=i.shape.length,a=e.data.get(i.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(s.dataId).values,d=Gr(r.dtype,s.dtype),u=Xi(K(r.shape),d);let h=0;const p=0===o||o>1||1===r.shape.length?1:K(r.shape.slice(1));for(let f=0;f<a.length;f++)for(let m=0;m<p;m++)u[h++]=1===a[f]?l[f]:c[f];return e.makeTensorInfo(r.shape,d,u)}},pFe=Gx,fFe=qx,mFe=Zt(Om,n=>n>=0?fFe*n:pFe*(Math.exp(n)-1)),gFe={kernelName:Om,backendName:"cpu",kernelFunc:mFe},_Fe=Zt(Lm,n=>n<0?-1:n>0?1:0),bFe={kernelName:Lm,backendName:"cpu",kernelFunc:_Fe},yFe=Zt(Fm,n=>Math.sin(n)),vFe={kernelName:Fm,backendName:"cpu",kernelFunc:yFe},xFe=Zt(Pm,n=>Math.sinh(n)),wFe={kernelName:Pm,backendName:"cpu",kernelFunc:xFe},a6=Math.log(1.1920928955078125e-7)+2,CFe=Zt(Vm,n=>{const t=n>-a6,e=n<a6,i=Math.exp(n);let r;return r=e?i:t?n:Math.log(1+i),r}),DFe={kernelName:Vm,backendName:"cpu",kernelFunc:CFe},kFe={kernelName:ax,backendName:"cpu",kernelFunc:function SFe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{blockShape:s,paddings:o}=i;Te([r],"spaceToBatchND");const a=K(s),l=[[0,0]];l.push(...o);for(let w=1+s.length;w<r.shape.length;++w)l.push([0,0]);const c=K8.kernelFunc({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),d=hg(c.shape,s,a,!1),u=pg(d.length,s.length,!1),h=fg(c.shape,s,a,!1),m=hn({inputs:{x:c},backend:e,attrs:{shape:d}}),b=$r({inputs:{x:m},backend:e,attrs:{perm:u}}),x=hn({inputs:{x:b},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(b),x}};function l6(n,t,e,i,r,s,o){const a=t[0],l=s[0],c=new Array(l),d=new Array(a),u=t[1];if(0===l){if(0!==a)throw new Error(Pj(a));return[ii(e,0),[0,u],ii(r,0),c,d]}let h=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<a;++g){const _=n[g*u];if(_<0)throw new Error(Lj(g,_));if(_>=l)throw new Error($j(g,_,l));++f[_],h=h&&_>=p,p=_}let m=!0;for(let g=0;g<l;++g){const _=0===f[g];c[g]=_,m=m&&!_,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const g=n,_=i;for(let b=0;b<a;++b)d[b]=b;return[g,[a,u],_,c,d]}{const g=f[l-1],_=ii(e,g*u),b=ii(r,g),y=new Array(l).fill(0);for(let v=0;v<a;++v){const x=n[v*u],C=(0===x?0:f[x-1])+y[x];y[x]++;for(let D=0;D<u;++D)_[C*u+D]=n[v*u+D];b[C]=i[v],d[v]=C}for(let v=0;v<l;++v)if(0===y[v]){const w=0===v?0:f[v-1];_[w*u+0]=v;for(let C=1;C<u;++C)_[w*u+C]=0;b[w]=o}return[_,[g,u],b,c,d]}}const IFe={kernelName:UI,backendName:"cpu",kernelFunc:function EFe(n){const{inputs:t,backend:e}=n,{indices:i,values:r,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==i.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${i.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.data.get(i.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values[0],[u,h,p,f,m]=l6(a,i.shape,i.dtype,l,r.dtype,c,d);return[e.makeTensorInfo(h,i.dtype,u),e.makeTensorInfo([h[0]],r.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),e.makeTensorInfo([m.length],i.dtype,new Int32Array(m))]}};function c6(n,t,e,i,r){const s=K(i),o=t[0],a=r.length,l=[];let c=1,d=-1;for(let g=0;g<a;++g){const _=r[g];if(-1===_){if(-1!==d)throw new Error(Vj(d,g));d=g,l.push(1)}else{if(_<0)throw new Error(Bj(g,_));c*=_,l.push(_)}}if(-1!==d){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const g=Math.trunc(s/c);if(c*g!==s)throw new Error(Uj(i,l));l[d]=g}if(K(l)!==s)throw new Error(Hj(i,l));const h=i.length,p=[];if(h>0){p[h-1]=1;for(let g=h-2;g>=0;--g)p[g]=p[g+1]*i[g+1]}const f=[];if(a>0){f[a-1]=1;for(let g=a-2;g>=0;--g)f[g]=f[g+1]*l[g+1]}const m=ii(e,o*a);for(let g=0;g<o;++g){let _=0;for(let b=0;b<h;++b)_+=n[g*h+b]*p[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(_/f[b]),_%=f[b]}return[m,[o,a],l]}const AFe={kernelName:HI,backendName:"cpu",kernelFunc:function TFe(n){const{inputs:t,backend:e}=n,{inputIndices:i,inputShape:r,newShape:s}=t;if(2!==i.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${i.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(e.data.get(r.dataId).values),a=e.data.get(i.dataId).values,l=Array.from(e.data.get(s.dataId).values),[c,d,u]=c6(a,i.shape,i.dtype,o,l);return[e.makeTensorInfo(d,i.dtype,c),e.makeTensorInfo([u.length],s.dtype,new Int32Array(u))]}};function ZA(n,t,e,i,r,s=!1,o=0){const a=i.length,l=[t[0],n.length/t[0]],c=l[1],u=a>0?r[a-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=u;const f=ii(e,h.reduce((y,v)=>y*v,1));if(0===a)return u>0&&f.fill(o),[f,h];if(u<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,_=0,b=r[m];for(;;){let y=0;if(g<a){if(y=r[g],b===y){++g;continue}if(b>=y)throw new Error("segment ids are not increasing")}if(b<0||b>=u)throw new Error(Wj(b,u));b>_&&f.fill(o,_*c,b*c);for(let v=m;v<g;++v){const x=i[v];if(x<0||x>=l[0])throw new Error(Gj(v,i[v],l[0]));for(let w=0;w<c;w++)f[b*c+w]+=n[x*c+w]}if(s)for(let v=0;v<c;v++)f[b*c+v]/=g-m;if(m=g,++g,_=b+1,b=y,g>a)break}return _<u&&f.fill(o,_*c,u*c),[f,h]}const NFe={kernelName:jI,backendName:"cpu",kernelFunc:function MFe(n){const{inputs:t,backend:e}=n,{data:i,indices:r,segmentIds:s}=t;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(i.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,[c,d]=ZA(o,i.shape,i.dtype,a,l,!0);return e.makeTensorInfo(d,i.dtype,c)}},OFe={kernelName:WI,backendName:"cpu",kernelFunc:function RFe(n){const{inputs:t,backend:e}=n,{data:i,indices:r,segmentIds:s}=t;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(i.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,[c,d]=ZA(o,i.shape,i.dtype,a,l);return e.makeTensorInfo(d,i.dtype,c)}},PFe={kernelName:HH,backendName:"cpu",kernelFunc:function FFe(n){const{inputs:t,backend:e,attrs:i}=n,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:a}=i,{sliceRank:l,numUpdates:c,sliceSize:d,strides:u,outputSize:h}=mg(0,r,a),p=!1,f=e.bufferSync(r);let m;switch(s.dtype){case"bool":m=kh(f,e.bufferSync(s),a,h,d,c,l,u,Boolean(e.data.get(o.dataId).values[0]),p);break;case"float32":case"int32":m=kh(f,e.bufferSync(s),a,h,d,c,l,u,e.data.get(o.dataId).values[0],p);break;case"string":m=kh(f,e.bufferSync(s),a,h,d,c,l,u,Rl(e.data.get(o.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(a,m.dtype,m.values)}},$Fe={kernelName:lx,backendName:"cpu",kernelFunc:function LFe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{numOrSizeSplits:s,axis:o}=i,a=yt(o,r.shape)[0],l=PT(r,s,a),c=new Array(r.shape.length).fill(0),d=r.shape.slice();return l.map(u=>{const h=[...d];h[a]=u;const p=yd({inputs:{x:r},backend:e,attrs:{begin:c,size:h}});return c[a]+=u,p})}},VFe=Xl(n=>Math.sqrt(n)),BFe=Zt(Bm,n=>Math.sqrt(n)),zFe={kernelName:Bm,backendName:"cpu",kernelFunc:BFe},UFe={kernelName:GI,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,i=t;Te(e,"square");const r=i.data.get(e.dataId).values,s=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];s[a]=l*l}return{dataId:i.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},d6=ri((n,t)=>{const e=n-t;return e*e}),HFe=Ri(zm,d6),jFe={kernelName:zm,backendName:"cpu",kernelFunc:HFe},WFe=Zt(Gm,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),GFe={kernelName:Gm,backendName:"cpu",kernelFunc:WFe};function u6(n,t,e,i){const r=vt(n,t.dtype);for(let s=0;s<r.size;s++){const o=r.indexToLoc(s),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*e[l]+i[l];r.set(t.get(...a),...o)}return r}const YFe={kernelName:qI,backendName:"cpu",kernelFunc:function qFe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{begin:s,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:u,shrinkAxisMask:h}=i;Te(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:_,begin:b,end:y,strides:v}=V1(r.shape,s,o,a,l,c,d,u,h);let x;if(m)x=hn({inputs:{x:r},backend:e,attrs:{shape:f}});else if(g||_){S(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const w=P1(b,y,v),C=yd({inputs:{x:r},backend:e,attrs:{begin:b,size:w}});x=hn({inputs:{x:C},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(C)}else{const C=u6(p,e.bufferSync(r),v,b);x=e.makeTensorInfo(f,C.dtype,C.values)}return x}};class KFe{constructor(t,e,i,r,s,o){this.separator=Nl(t),this.nGramWidths=e,this.leftPad=Nl(i),this.rightPad=Nl(r),this.padWidth=s,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const i=this.getPadWidth(e);return Math.max(0,t+2*i-e+1)}createNGrams(t,e,i,r,s,o){for(let a=0;a<s;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),d=Math.max(0,l-(s-(a+1))),u=o-(c+d),h=e+(c>0?0:a-l);let p=0;p+=c*this.leftPad.length;for(let b=0;b<u;++b)p+=t[h+b].length;p+=d*this.rightPad.length,p+=(c+d+u-1)*this.separator.length,i[r+a]=new Uint8Array(p);const m=i[r+a];let g=0;const _=b=>b.forEach(y=>m[g++]=y);for(let b=0;b<c;++b)_(this.leftPad),_(this.separator);for(let b=0;b<u-1;++b)_(t[h+b]),_(this.separator);if(u>0){_(t[h+u-1]);for(let b=0;b<d;++b)_(this.separator),_(this.rightPad)}else{for(let b=0;b<d-1;++b)_(this.rightPad),_(this.separator);_(this.rightPad)}}}compute(t,e){const i=t.length,r=e.length;if(r>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<r;++c){let d=e[c]>=l;if(d=d&&e[c]<=i,!d)throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${i}]`);l=e[c]}if(l!==i)throw new Error(`Last split value must be data size. Expected ${i}, got ${l}`)}const s=r-1,o=ii("int32",r);if(0===i||0===r){const l=new Array(i);for(let c=0;c<=s;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=s;++l){const c=e[l]-e[l-1];let d=0;this.nGramWidths.forEach(u=>{d+=this.getNumNGrams(c,u)}),this.preserveShort&&c>0&&0===d&&(d=1),o[l]=o[l-1]+d}const a=new Array(o[s]);for(let l=0;l<s;++l){const c=e[l];let d=o[l];if(this.nGramWidths.forEach(u=>{const p=this.getNumNGrams(e[l+1]-e[l],u);this.createNGrams(t,c,a,d,p,u),d+=p}),this.preserveShort&&d===o[l]){const u=e[l+1]-e[l];if(0===u)continue;this.createNGrams(t,c,a,d,1,u+2*this.padWidth)}}return[a,o]}}function h6(n,t,e,i,r,s,o,a){return new KFe(e,i,r,s,o,a).compute(n,t)}const ZFe={kernelName:YI,backendName:"cpu",kernelFunc:function XFe(n){const{inputs:t,backend:e,attrs:i}=n,{separator:r,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=i,{data:d,dataSplits:u}=t,h=e.data.get(d.dataId).values,p=e.data.get(u.dataId).values,[f,m]=h6(h,p,r,s,o,a,l,c);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(u.shape,"int32",m)]}};function QFe(n,t,e,i){if(!n.length)return;if(0===t.length){for(let s=0;s<n.length;++s)i.push(n.subarray(s,s+1));return}if(1===t.length){const s=t[0];let o=n.indexOf(s);for(;-1!==o;){const a=n.subarray(0,o);(!e||0!==a.length)&&i.push(a),o=(n=n.subarray(o+1)).indexOf(s)}return void((!e||0!==n.length)&&i.push(n))}let r=0;for(let s=0;s<n.length+1;s++)if(s===n.length||-1!==t.indexOf(n[s])){const o=n.subarray(r,s);(!e||0!==o.length)&&i.push(o),r=s+1}}function p6(n,t,e){const i=n.length,r=[];let s=0,o=0;const a=new Array(i);for(let h=0;h<i;++h){const p=r.length;QFe(n[h],t,e,r);const f=r.length-p;a[h]=f,s+=f,o=Math.max(o,f)}const l=ii("int32",2*s),c=new Array(s),d=[i,o];let u=0;for(let h=0;h<i;++h)for(let p=0;p<a[h];++p)l[2*u]=h,l[2*u+1]=p,c[u]=r[u],++u;return[l,c,d]}const ePe={kernelName:KI,backendName:"cpu",kernelFunc:function JFe(n){const{inputs:t,backend:e,attrs:i}=n,{skipEmpty:r}=i,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values[0],[c,d,u]=p6(a,l,r),h=d.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(u))]}};function f6(n,t){const e=ii("int32",n.length);for(let i=0;i<n.length;++i)e[i]=xve(n[i]).modulo(t).getLowBitsUnsigned();return e}const nPe={kernelName:XI,backendName:"cpu",kernelFunc:function tPe(n){const{inputs:t,backend:e,attrs:i}=n,{numBuckets:r}=i,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=f6(e.data.get(s.dataId).values,r);return e.makeTensorInfo(s.shape,"int32",a)}},iPe=Zt(Hm,n=>Math.tan(n)),rPe={kernelName:Hm,backendName:"cpu",kernelFunc:iPe},sPe=Zt(jm,n=>Math.tanh(n));function m6(n,t){const e=new Array(n.rank);for(let r=0;r<e.length;r++)e[r]=n.shape[r]*t[r];const i=vt(e,n.dtype);for(let r=0;r<i.values.length;++r){const s=i.indexToLoc(r),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=s[l]%n.shape[l];const a=n.locToIndex(o);i.values[r]=n.values[a]}return i}const lPe={kernelName:Wm,backendName:"cpu",kernelFunc:function aPe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{reps:s}=i;Te(r,"tile");const o=m6(e.bufferSync(r),s);return e.makeTensorInfo(o.shape,o.dtype,o.values)}},Mg=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function g6(n,t,e=0,i=n.length-1){for(;i>e;){if(i-e>600){const a=i-e+1,l=t-e+1,c=Math.log(a),d=.5*Math.exp(2*c/3),u=.5*Math.sqrt(c*d*(a-d)/a)*Math.sign(l-a/2);g6(n,t,Math.max(e,Math.floor(t-l*d/a+u)),Math.min(i,Math.floor(t+(a-l)*d/a+u)))}const r=n[t];let s=e,o=i;for(Il(n,e,t),Mg(n[i],r)>0&&Il(n,e,i);s<o;){for(Il(n,s,o),s++,o--;Mg(n[s],r)<0;)s+=1;for(;Mg(n[o],r)>0;)o-=1}0===Mg(n[e],r)?Il(n,e,o):(o+=1,Il(n,o,i)),o<=t&&(e=o+1),t<=o&&(i=o-1)}}function _6(n,t,e,i,r){const s=t[t.length-1],[o,a]=[n.length/s,s],l=zi(e,o*i),c=zi("int32",o*i);for(let u=0;u<o;u++){const h=u*a,p=n.subarray(h,h+a);let f=new Array(p.length);p.forEach((b,y)=>f[y]={value:b,index:y}),i<f.length&&(g6(f,i),f=f.slice(0,i)),r&&f.sort(Mg);const m=u*i,g=l.subarray(m,m+i),_=c.subarray(m,m+i);for(let b=0;b<i;b++)g[b]=f[b].value,_[b]=f[b].index}const d=t.slice();return d[d.length-1]=i,[vt(d,e,l),vt(d,"int32",c)]}const dPe={kernelName:ZI,backendName:"cpu",kernelFunc:function cPe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{k:s,sorted:o}=i;Te(r,"topk");const a=e.data.get(r.dataId).values,[l,c]=_6(a,r.shape,r.dtype,s,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},hPe={kernelName:QI,backendName:"cpu",kernelFunc:function uPe(n){const{inputs:t,attrs:e,backend:i}=n,{image:r,transforms:s}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=e,[d,u,h,p]=r.shape,[f,m]=c??[u,h],g=[d,f,m,p],_=Le(r.shape),b=_[0],y=_[1],v=_[2],x=Le(g),w=x[0],C=x[1],D=x[2],k=zi(r.dtype,K(g));k.fill(l);const I=i.data.get(r.dataId).values,A=i.data.get(s.dataId).values;for(let H=0;H<d;++H){const W=1===s.shape[0]?A:A.subarray(8*H,8*H+8);for(let z=0;z<f;++z)for(let M=0;M<m;++M)for(let F=0;F<p;++F){let L;const j=W[6]*M+W[7]*z+1;if(0===j)continue;const ee=(W[3]*M+W[4]*z+W[5])/j,se=b6((W[0]*M+W[1]*z+W[2])/j,h,a),re=b6(ee,u,a);switch(o){case"nearest":L=_Pe(I,u,h,b,y,v,H,re,se,F,l);break;case"bilinear":L=bPe(I,u,h,b,y,v,H,re,se,F,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}k[H*w+z*C+M*D+F]=L}return i.makeTensorInfo(g,r.dtype,k)}return{dataId:i.write(k,g,r.dtype),shape:r.shape,dtype:r.dtype}}};function b6(n,t,e){switch(e){case"reflect":return function pPe(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const i=2*t;e<i&&(e=i*Math.trunc(-e/i)+e),e=e<-t?e+i:-e-1}else if(e>t-1)if(t<=1)e=0;else{const i=2*t;e-=i*Math.trunc(e/i),e>=t&&(e=i-e-1)}return Yc(0,e,t-1)}(n,t);case"wrap":return function fPe(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),Yc(0,e,t-1)}(n,t);case"nearest":return function gPe(n,t){return Yc(0,n,t-1)}(n,t);default:return function mPe(n,t){return n}(n)}}function Ng(n,t,e,i,r,s,o,a,l,c,d){return 0<=a&&a<t&&0<=l&&l<e?n[o*i+a*r+l*s+c]:d}function _Pe(n,t,e,i,r,s,o,a,l,c,d){return Ng(n,t,e,i,r,s,o,Math.round(a),Math.round(l),c,d)}function bPe(n,t,e,i,r,s,o,a,l,c,d){const u=Math.floor(a),h=Math.floor(l),p=u+1,f=h+1;return(p-a)*((f-l)*Ng(n,t,e,i,r,s,o,u,h,c,d)+(l-h)*Ng(n,t,e,i,r,s,o,u,f,c,d))+(a-u)*((f-l)*Ng(n,t,e,i,r,s,o,p,h,c,d)+(l-h)*Ng(n,t,e,i,r,s,o,p,f,c,d))}function y6(n,t,e,i){const r=yt(t,e)[0],s=[1,e[0],1];for(let f=0;f<r;f++)s[0]*=e[f];s[1]=e[r];for(let f=r+1;f<e.length;f++)s[2]*=e[f];const o={},a=new Int32Array(e[r]),l=new Zi(s,i,n),c=[],d=1===s[0]&&1===s[2];for(let f=0;f<e[r];f++){let m;if(d)m=n[f].toString();else{const g=[];for(let _=0;_<s[0];_++)for(let b=0;b<s[2];b++)g.push(l.get(_,f,b));m=g.join(",")}if(void 0!==o[m])a[f]=o[m];else{const g=Object.keys(o).length;o[m]=g,a[f]=g,c.push(f)}}const u=s.slice();u[1]=Object.keys(o).length;const h=new Zi(u,i);c.forEach((f,m)=>{for(let g=0;g<s[0];g++)for(let _=0;_<s[2];_++)h.set(l.get(g,f,_),g,m,_)});const p=e.slice();return p[r]=u[1],{outputValues:h.values,outputShape:p,indices:a}}const vPe={kernelName:JI,backendName:"cpu",kernelFunc:function yPe(n){const{inputs:t,attrs:e,backend:i}=n,{axis:r}=e,{x:s}=t;Te(s,"unique");const o=i.data.get(s.dataId).values,{outputValues:a,outputShape:l,indices:c}=y6(o,r,s.shape,s.dtype);return[i.makeTensorInfo(l,s.dtype,a),i.makeTensorInfo([c.length],"int32",c)]}},wPe={kernelName:dx,backendName:"cpu",kernelFunc:function xPe(n){const{inputs:t,backend:e,attrs:i}=n,{value:r}=t;let{axis:s}=i;s<0&&(s+=r.shape.length);const o=r.shape.length,a=r.shape[s],l=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==s&&(l[c++]=r.shape[p]);const d=new Array(o).fill(0),u=r.shape.slice();u[s]=1;const h=new Array(a);for(let p=0;p<h.length;p++){d[s]=p;const f=yd({inputs:{x:r},backend:e,attrs:{begin:d,size:u}});h[p]=hn({inputs:{x:f},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(f)}return h}},DPe={kernelName:ux,backendName:"cpu",kernelFunc:function CPe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,segmentIds:s}=t,{numSegments:o}=i;Te(r,"unsortedSegmentSum");const c=[],d=[],u=r.shape.length-s.shape.length;let h=s;for(let f=0;f<u;++f){const m=R0({inputs:{input:h},backend:e,attrs:{dim:f+1}});h=m,d.push(m)}for(let f=0;f<o;++f){const m=Ml(f,"int32"),g=e.makeTensorInfo([],"int32",m),_=S8({inputs:{a:g,b:h},backend:e}),b=Zl({inputs:{x:_},backend:e,attrs:{dtype:"float32"}}),y=N0({inputs:{a:b,b:r},backend:e}),v=Ag({inputs:{x:y},backend:e,attrs:{axis:0,keepDims:!1}});c.push(v),d.push(g),d.push(_),d.push(b),d.push(y),d.push(v)}const p=Y8({inputs:c,backend:e,attrs:{axis:0}});return d.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}},SPe=[kAe,EAe,TAe,MAe,wAe,RAe,PAe,$Ae,BAe,UAe,jAe,GAe,YAe,ZAe,JAe,nMe,rMe,oMe,lMe,DAe,dMe,pMe,mMe,_Me,vAe,yMe,xMe,bAe,wMe,DMe,SMe,EMe,TMe,MMe,RMe,FMe,LMe,VMe,zMe,HMe,WMe,qMe,KMe,XMe,QMe,eNe,nNe,iNe,rNe,sNe,dNe,cAe,hNe,pNe,xNe,wNe,CNe,SNe,RNe,ONe,PNe,$Ne,zNe,HNe,WNe,qNe,KNe,ZNe,JNe,dAe,tRe,CMe,iRe,sRe,aRe,uAe,cRe,uRe,pRe,mRe,_Re,vRe,wRe,SRe,ERe,TRe,ARe,NRe,ORe,PRe,$Re,BRe,URe,jRe,GRe,YRe,XRe,JRe,nOe,aNe,rOe,aOe,dOe,pOe,mOe,_Oe,yOe,vOe,K8,DOe,pAe,kOe,OOe,POe,$Oe,BOe,yAe,qA,UOe,fAe,mAe,CAe,jOe,GOe,YOe,XOe,QOe,JOe,tFe,iFe,sFe,dFe,hFe,gFe,_Ae,bFe,vFe,wFe,uMe,eOe,DFe,kFe,IFe,AFe,NFe,OFe,PFe,$Fe,zFe,UFe,jFe,GFe,YFe,ZFe,ePe,nPe,INe,lNe,rPe,{kernelName:jm,backendName:"cpu",kernelFunc:sPe},lPe,dPe,hPe,OAe,vPe,wPe,DPe,bOe];for(const n of SPe)s1(n);const Ql={},P0={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Io(n,t){if(!(n in Ql)||null!=t){const i=function IPe(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function EPe(n){if(typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",i=>{i.preventDefault(),delete Ql[n]},!1),q().getBool("SOFTWARE_WEBGL_ENABLED")&&(P0.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",P0)||e.getContext("experimental-webgl",P0):e.getContext("webgl2",P0)}(n,t);if(null===i)return console.log("Could not get context for WebGL version",n),null;Ql[n]=i}const e=Ql[n];return null==e||e.isContextLost()?(delete Ql[n],Io(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Ql[n])}var Eh=(()=>(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"}(Eh||(Eh={})),Eh))(),Xr=(()=>(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"}(Xr||(Xr={})),Xr))(),Oi=(()=>(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Oi||(Oi={})),Oi))();function Rg(n,t){return[t,n]}function L0(n){const t=K(n);return eI(Math.ceil(t/4))}function Ih(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function QA(n,t){const e=n;let i,r,s,o,a,l,c,d,u,h;return 2===q().getNumber("WEBGL_VERSION")?(i=e.R32F,r=e.R16F,s=e.RGBA16F,o=e.RGBA32F,a=e.RED,c=4,d=1,u=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(i=n.RGBA,r=n.RGBA,s=n.RGBA,o=e.RGBA,a=n.RGBA,c=4,d=4,u=null!=t?t.HALF_FLOAT_OES:null,h=n.FLOAT,l=n.RGBA),{internalFormatFloat:i,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:u,textureTypeFloat:h}}function ge(n,t){const e=t();return q().getBool("DEBUG")&&function MPe(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function FPe(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}const NPe=5.96e-8,RPe=65504;function OPe(n){return!!(q().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||NPe<Math.abs(n)&&Math.abs(n)<RPe)}function $0(n,t){return Ka(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const $Pe=/ERROR: [0-9]+:([0-9]+):/g;function v6(n,t){const e=$Pe.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const i=+e[1],r=n.split("\n"),s=r.length.toString().length+2,o=r.map((u,h)=>Zu((h+1).toString(),s)+u);let a=0;for(let u=0;u<o.length;u++)a=Math.max(o[u].length,a);const l=o.slice(0,i-1),c=o.slice(i-1,i),d=o.slice(i);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Zu(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function JA(n,t){if(ge(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function x6(n,t,e,i,r,s,o){const a=n.getAttribLocation(t,e);return-1!==a&&(ge(n,()=>n.bindBuffer(n.ARRAY_BUFFER,i)),ge(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,s,o)),ge(n,()=>n.enableVertexAttribArray(a)),!0)}function KPe(n,t,e,i){ge(n,()=>function GPe(n,t,e){(function C6(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,i=t+n.TEXTURE0;if(i<n.TEXTURE0||i>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),ge(n,()=>n.activeTexture(n.TEXTURE0+e)),ge(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,i)),ge(n,()=>n.uniform1i(e,i))}function eM(n,t,e){ge(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ge(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function w6(n,t){ge(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ge(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function V0(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function XPe(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function Ka(n,t,e){const i=ge(n,()=>t());if(null==i)throw new Error(e);return i}function Th(n,t=2){return K(n.slice(0,n.length-t))}function Ah(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function B0(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[Th(n),...Ah(n)]),t}function z0(n){return n%2==0}function U0(n,t){if(Ut(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n.slice(-1)[0],i=t.slice(-1)[0];if(e===i||z0(e)&&z0(i)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&z0(n[0])&&z0(t[0])}let H0,j0;function Qs(n,t){return null!=n.getExtension(t)}function D6(n){try{if(null!=Io(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function tM(n){const t=QA(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(s),o}function Og(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Re=q();function br(){let n,t,e,i,r,s,o,a,l,c;return 2===q().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",i="in",r="texture",s="outputColor",o="out vec4 outputColor;",a=q().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",i="varying",r="texture2D",s="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:i,texture2D:r,output:s,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function vd(n,t,e="index"){const i=Le(t);return i.map((r,s)=>`int ${n[s]} = ${e} / ${r}; ${s===i.length-1?`int ${n[s+1]} = ${e} - ${n[s]} * ${r}`:`index -= ${n[s]} * ${r}`};`).join("")}function W0(n,t,e="index"){const i=Le(t);return i.map((r,s)=>`int ${n[s]} = ${e} / outShapeStrides[${s}]; ${s===i.length-1?`int ${n[s+1]} = ${e} - ${n[s]} * outShapeStrides[${s}]`:`index -= ${n[s]} * outShapeStrides[${s}]`};`).join("")}function nM(n){const t=Le(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Re.registerFlag("HAS_WEBGL",()=>Re.getNumber("WEBGL_VERSION")>0),Re.registerFlag("WEBGL_VERSION",()=>D6(2)?2:D6(1)?1:0),Re.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Re.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Re.get("WEBGL_VERSION")),Re.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Re.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Re.registerFlag("WEBGL_PACK",()=>Re.getBool("HAS_WEBGL")),Re.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_CLIP",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_REDUCE",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_LAZILY_UNPACK",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_CONV_IM2COL",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function QPe(n){if(null==H0){const t=Io(n);H0=t.getParameter(t.MAX_TEXTURE_SIZE)}return H0}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function JPe(n){if(null==j0){const t=Io(n);j0=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,j0)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Re.getNumber("WEBGL_VERSION");return 0===n?0:function e2e(n){if(0===n)return 0;let t;const e=Io(n);return t=Qs(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:Qs(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),Re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Re.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!n4()),Re.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function t2e(n){if(0===n)return!1;const t=Io(n);if(1===n){if(!Qs(t,"OES_texture_float"))return!1}else if(!Qs(t,"EXT_color_buffer_float"))return!1;return tM(t)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Re.getBool("WEBGL_FORCE_F16_TEXTURES")&&Re.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Re.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function n2e(n){if(0===n)return!1;const t=Io(n);if(1!==n){if(Qs(t,"EXT_color_buffer_float"))return tM(t);const i="EXT_color_buffer_half_float";if(Qs(t,i)){const r=t.getExtension(i);return function i2e(n,t){const e=QA(n,t),i=n.createTexture();n.bindTexture(n.TEXTURE_2D,i),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,i,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(i),n.deleteFramebuffer(o),a}(t,r)}return!1}return!(!Qs(t,"OES_texture_float")||!Qs(t,"WEBGL_color_buffer_float"))&&tM(t)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function r2e(n){return 2===n&&null!=Io(n).fenceSync}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Re.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Re.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),Re.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>n4()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),Re.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Re.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Re.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Re.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Re.registerFlag("WEBGL_EXP_CONV",()=>!1),Re.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Re.getBool("IS_TEST")),Re.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Re.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Re.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Re.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const S6="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:k6}=We;function a2e(n,t,e){const i=[];if(n.forEach(p=>{const f=K(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?i.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(i.push(`uniform sampler2D ${p.name};`),i.push(`uniform int offset${p.name};`)),e.enableShapeUniforms){const{uniformShape:m}=rM(e.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:i.push(`uniform int ${p.name}Shape;`);break;case 2:i.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:i.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:i.push(`uniform ivec4 ${p.name}Shape;`)}i.push(`uniform ivec2 ${p.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:i.push("uniform int outShape;");break;case 2:i.push("uniform ivec2 outShape;"),i.push("uniform int outShapeStrides;");break;case 3:i.push("uniform ivec3 outShape;"),i.push("uniform ivec2 outShapeStrides;");break;case 4:i.push("uniform ivec4 outShape;"),i.push("uniform ivec3 outShapeStrides;")}i.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(p=>{i.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=i.join("\n"),s=n.map(p=>function l2e(n,t,e=!1,i){let r="";r+=e?E6(n,i):Mh(n,i);return n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(r+=e?function z2e(n,t){const e=n.name,i=e.charAt(0).toUpperCase()+e.slice(1),r="get"+i+"AtOutCoords",s=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,a=k6(n.shapeInfo.logicalShape,t.logicalShape),l=pn(o),c=o-s;let d;const u=["x","y","z","w","u","v"];d=0===s?"":o<2&&a.length>=1?"coords = 0;":a.map(b=>`coords.${u[b+c]} = 0;`).join("\n");let h="";h=o<2&&s>0?"coords":n.shapeInfo.logicalShape.map((b,y)=>`coords.${u[y+c]}`).join(", ");let p="return outputValue;";const m=1===K(n.shapeInfo.logicalShape),_=1===K(t.logicalShape);if(1!==s||m||_){if(m&&!_)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const b=s-2,y=s-1;a.indexOf(b)>-1&&a.indexOf(y)>-1?p="return vec4(outputValue.x);":a.indexOf(b)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(y)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${i}(${h});\n      ${p}\n    }\n  `}(n,t):function U2e(n,t){const e=n.name,i=e.charAt(0).toUpperCase()+e.slice(1),r="get"+i+"AtOutCoords",a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&null==n.shapeInfo.flatOffset&&Ut(n.shapeInfo.texShape,t.texShape))return`\n      float ${r}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=pn(l),d=k6(n.shapeInfo.logicalShape,t.logicalShape),u=l-a;let h;const p=["x","y","z","w","u","v"];h=0===a?"":l<2&&d.length>=1?"coords = 0;":d.map(m=>`coords.${p[m+u]} = 0;`).join("\n");let f="";return f=l<2&&a>0?"coords":n.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+u]}`).join(", "),`\n    float ${r}() {\n      ${c} coords = getOutputCoords();\n      ${h}\n      return get${i}(${f});\n    }\n  `}(n,t)),r}(p,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),o=t.texShape,a=br(),l=function u2e(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,d,u=function f2e(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${m2e}\n    ${g2e}\n    ${_2e}\n  `}(a);return t.isPacked?(c=function c2e(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function y2e(n,t,e){const i=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===i[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${i[1]}.0);\n      }\n    `:1===i[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${i[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      return 2 * (resTexRC.x * ${i[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function E2e(n,t,e){const i=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Ut(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${i[0]}, ${i[1]}));\n      }\n    `;const r=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function x2e(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const i=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[2]/2),s=r*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function C2e(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const i=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[n.length-1]/2),s=r*Math.ceil(n[n.length-2]/2);let o=s,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`\n      int b${c} = index / ${o};\n      index -= b${c} * ${o};\n    `+a,l=`b${c}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,o,e.enableShapeUniforms),d=function p2e(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(c=function d2e(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function v2e(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function I2e(n,t,e){return Ut(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function w2e(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${W0(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const i=vd(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${i}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function D2e(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${W0(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const i=vd(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${i}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function S2e(n,t){const e=vd(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function k2e(n,t){const e=vd(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,e.enableShapeUniforms),d=function h2e(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(u+=b2e),[u,l,d,r,c,s,e.userCode].join("\n")}function Mh(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function A2e(n,t){const e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${i}() {return ${e};}`;const[r,s]=n.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${i}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=xd(e);if(t)return`\n    float ${i}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=n.shapeInfo.texShape;return`\n    float ${i}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function N2e(n,t){const e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${i}(int index) {\n        ${Nh(n)}\n      }\n    `;const r=n.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return`\n      float ${i}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=xd(e);return 1===o?t?`\n      float ${i}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${i}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===s?t?`\n      float ${i}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${i}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${i}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${i}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function O2e(n,t){const e=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n.shapeInfo.texShape;if(null!=s&&Ut(e,s))return t?`\n      float ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `;const{newShape:o,keptDims:a}=Tl(e);if(o.length<e.length){const p=["row","col"];return`\n      ${Mh(Rh(n,o),t)}\n      float ${r}(int row, int col) {\n        return ${r}(${Oh(p,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Nh(n)}\n      }\n    `;const c=s[0],d=s[1],u=xd(i);return 1===d?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${u}), vec3(${i}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${i}TexShape[0]));\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${u}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `:1===c?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${u}), vec3(${i}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${i}TexShape[1]), 0.5);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${u}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${i}, uv);\n    }\n  `:t?`\n      float ${r}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i}Shape[1] + col + ${u};\n        vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${u};\n    vec2 uv = uvFromFlat(${c}, ${d}, index);\n    return sampleTexture(${i}, uv);\n  }\n`}(n,t);case 3:return function P2e(n,t){const e=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=e[1]*e[2],o=e[2],{newShape:a,keptDims:l}=Tl(e);if(a.length<e.length){const g=["row","col","depth"];return`\n        ${Mh(Rh(n,a),t)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${Oh(g,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${Nh(n)}\n      }\n    `;const d=n.shapeInfo.texShape,u=d[0],h=d[1],p=n.shapeInfo.flatOffset;if(h===s&&null==p)return t?`\n      float ${r}(int row, int col, int depth) {\n        int stride1 = ${i}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${u}.0);\n          return sampleTexture(${i}, uv);\n        }\n      `;if(h===o&&null==p)return t?`\n      float ${r}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${i}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${u}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `;const f=xd(i);return t?`\n    float ${r}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${i}Shape[1] * ${i}Shape[2];\n      int stride1 = ${i}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);\n      return sampleTexture(${i}, uv);\n    }\n    `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${f};\n        vec2 uv = uvFromFlat(${u}, ${h}, index);\n        return sampleTexture(${i}, uv);\n      }\n  `}(n,t);case 4:return function $2e(n,t){const e=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=e[3],o=e[2]*s,a=e[1]*o,{newShape:l,keptDims:c}=Tl(e);if(l.length<e.length){const y=["row","col","depth","depth2"];return`\n      ${Mh(Rh(n,l),t)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${Oh(y,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${s}, 1)));\n        ${Nh(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,u=n.shapeInfo.texShape,h=u[0],p=u[1],f=`int stride2 = ${i}Shape[3];`,m=`int stride1 = ${i}Shape[2] * stride2;`,g=`int stride0 = ${i}Shape[1] * stride1;`;if(p===a&&null==d)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${i}, uv);\n      }\n    `;if(p===s&&null==d)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${i}Shape[1] * ${i}Shape[2], ${i}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${i}, uv);\n      }\n    `;const _=xd(i);return t?`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index + ${_});\n      return sampleTexture(${i}, uv);\n    }\n  `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${_});\n      return sampleTexture(${i}, uv);\n    }\n  `}(n,t);case 5:return function V2e(n){const t=n.shapeInfo.logicalShape,e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],s=t[3]*r,o=t[2]*s,a=t[1]*o,{newShape:l,keptDims:c}=Tl(t);if(l.length<t.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${Mh(Rh(n,l))}\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        return ${i}(${Oh(g,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${s}, ${r})) +\n          depth3;\n        ${Nh(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,u=n.shapeInfo.texShape,h=u[0],p=u[1];if(p===a&&null==d)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${s}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===r&&null==d)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${i}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${s} +\n          depth2 * ${r} + depth3 + ${xd(e)};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function B2e(n){const t=n.shapeInfo.logicalShape,e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:s}=Tl(t);if(r.length<t.length){const _=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Mh(Rh(n,r))}\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${i}(${Oh(_,s)});\n      }\n    `}const o=t[5],a=t[4]*o,l=t[3]*a,c=t[2]*l,d=t[1]*c;if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${c}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Nh(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],f=h[1];if(f===d&&null==u)return`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===o&&null==u)return`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${c} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${xd(e)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function E6(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function T2e(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${br().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function M2e(n,t){const e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,s=br();if(t)return`\n    vec4 ${i}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${i}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function R2e(n,t){const e=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n.shapeInfo.texShape,o=s[0],a=s[1],l=br();if(null!=s&&Ut(e,s))return t?`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n\n        return ${l.texture2D}(${i}, uv);\n      }\n    `:`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${l.texture2D}(${i}, uv);\n      }\n    `;if(t)return`\n    vec4 ${r}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${i}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${i}, uv);\n    }\n  `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${i}, uv);\n    }\n  `}(n,t);case 3:return function F2e(n,t){const e=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===e[0]){const p=[1,2],m=["b","row","col"];return`\n        ${E6(Rh(n,e.slice(1)),t)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Oh(m,p)});\n        }\n      `}const a=br();if(t)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${i}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${i}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${i}, uv);\n    }\n  `;const l=o[0],c=o[1],d=Math.ceil(e[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${c}, ${d*Math.ceil(e[1]/2)}, ${d}, b, row, col);\n      return ${a.texture2D}(${i}, uv);\n    }\n  `}(n,t);default:return function L2e(n,t){const e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),r=br();if(t)return`\n    vec4 ${i}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${e}, uv);\n    }\n  `;const s=n.shapeInfo.logicalShape,o=s.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],d=l[1],u=Math.ceil(s[o-1]/2);let h=u*Math.ceil(s[o-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${u} + (col / 2)`;for(let m=2;m<o-1;m++)p=`int b${m}, `+p,h*=s[o-m-1],f=`b${m} * ${h} + `+f;return`\n    vec4 ${i}(${p}) {\n      int index = ${f};\n      int texR = index / ${d};\n      int texC = index - texR * ${d};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});\n      return ${r.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const m2e="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",g2e="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",_2e="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",b2e="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function xd(n){return`offset${n}`}function Nh(n){const t=n.name,e=K(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function pn(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function rM(n,t,e){const{newShape:i,keptDims:r}=Tl(t),s=t.length,o=n&&3===s&&1===t[0],a=o?t.slice(1):i,l=!n&&s>1&&!Ut(t,e)&&i.length<s||o;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:r}}function Rh(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Oh(n,t){return t.map(e=>n[e]).join(", ")}function T6(n,t,e){const i={},r={},s={},o=[];let a,l,c,d=null,u=null;u=n.getUniformLocation(e,"NAN",!1),1===q().getNumber("WEBGL_VERSION")&&(d=n.getUniformLocation(e,"INFINITY",!1));const h=!1;for(let p=0;p<t.variableNames.length;p++){const f=t.variableNames[p];i[f]=n.getUniformLocation(e,f,h),i[`offset${f}`]=n.getUniformLocation(e,`offset${f}`,h),t.enableShapeUniforms&&(r[`${f}Shape`]=n.getUniformLocation(e,`${f}Shape`,h),s[`${f}TexShape`]=n.getUniformLocation(e,`${f}TexShape`,h))}return t.enableShapeUniforms&&(a=n.getUniformLocation(e,"outShape",h),c=n.getUniformLocation(e,"outShapeStrides",h),l=n.getUniformLocation(e,"outTexShape",h)),t.customUniforms&&t.customUniforms.forEach((p,f)=>{o[f]=n.getUniformLocation(e,p.name,h)}),{uniformLocations:i,customUniformLocations:o,infLoc:d,nanLoc:u,inShapesLocations:r,inTexShapesLocations:s,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}}function A6(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,i)=>{const r=e.logicalShape,s=t[i],o=s.shape;if(!Ut(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(e.isUniform&&s.isUniform)return;const a=e.texShape,l=s.isUniform?null:s.texData.texShape;if(!Ut(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function yr(n){return q().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class G2e{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Eh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=br();this.outputShape=t,this.enableShapeUniforms=yr(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?W0(["r","c","d"],t):vd(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class q2e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Eh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=br();this.outputShape=t,this.enableShapeUniforms=yr(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?W0(["r","c","d"],t):vd(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Y2e{constructor(t){this.variableNames=["A"],this.outTexUsage=Xr.DOWNLOAD;const e=br();this.outputShape=t,this.userCode=`\n      ${S6}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class K2e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Xr.DOWNLOAD;const e=br();this.outputShape=t,this.userCode=`\n      ${S6}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const X2e={R:0,G:1,B:2,A:3};class M6{constructor(t,e=!1,i="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=br();this.outputShape=t,this.enableShapeUniforms=yr(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)");let o="";for(let a=0;a<i.length;a++)o+=`\n          if(offset == ${a}) {\n            result = values[${X2e[i[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":nM(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${i.length});\n\n        flatIndex = idiv(flatIndex, ${i.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${o}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class Z2e{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=br();this.outputShape=t,this.enableShapeUniforms=yr(this.outputShape.length);let r="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=2*o+a;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${o};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${i.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":nM(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${i.output} = ${s};\n        }\n    `}}function Fg(n,t,e,i,r,s){!function jPe(n,t){const e=q().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const o=function HPe(n){return Ka(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return ge(n,()=>n.bindTexture(a,o)),ge(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ge(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ge(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),ge(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===q().getNumber("WEBGL_VERSION")?ge(n,()=>n.texImage2D(a,0,i,t,e,0,r,s,null)):ge(n,()=>n.texStorage2D(a,1,i,t,e)),ge(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function N6(n){return n.internalFormatFloat}function R6(n){return n.internalFormatHalfFloat}function O6(n){return n.downloadTextureFormat}function F6(n){return n.internalFormatPackedFloat}function P6(n){return n.internalFormatPackedHalfFloat}class sM{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=q().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function kPe(n,t){Ql[n]=t}(e,t)):this.gl=Io(e),t=this.gl,2===q().getNumber("WEBGL_VERSION")){const s=t;this.createVertexArray=()=>ge(s,()=>s.createVertexArray()),this.bindVertexArray=o=>ge(s,()=>s.bindVertexArray(o)),this.deleteVertexArray=o=>ge(s,()=>s.deleteVertexArray(o)),this.getVertexArray=()=>ge(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(null!=t){const s=t.getExtension("OES_vertex_array_object");if(null==s)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ge(t,()=>s.createVertexArrayOES()),this.bindVertexArray=o=>ge(t,()=>s.bindVertexArrayOES(o)),this.deleteVertexArray=o=>ge(t,()=>s.deleteVertexArrayOES(o)),this.getVertexArray=()=>ge(t,()=>t.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let i="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===q().getNumber("WEBGL_VERSION")){const o="OES_texture_half_float";if(this.textureFloatExtension=$0(this.gl,"OES_texture_float"),Qs(this.gl,o))this.textureHalfFloatExtension=$0(this.gl,o);else if(q().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(i),Qs(this.gl,r))this.colorBufferHalfFloatExtension=$0(this.gl,r);else if(q().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(i="EXT_color_buffer_float",Qs(this.gl,i))this.colorBufferFloatExtension=this.gl.getExtension(i);else{if(!Qs(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function J2e(n){return function zPe(n,t){const e=Ka(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ge(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),ge(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function eLe(n){return function UPe(n,t){const e=Ka(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ge(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),ge(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function WPe(n){return Ka(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=QA(this.gl,this.textureHalfFloatExtension)}get debug(){return q().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;ge(t,()=>t.finish()),ge(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ge(t,()=>t.deleteFramebuffer(this.framebuffer)),ge(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ge(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ge(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function tLe(n,t,e,i){const[r,s]=Rg(t,e);return Fg(n,r,s,N6(i),i.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function nLe(n,t,e,i){const[r,s]=Rg(t,e);return Fg(n,r,s,R6(i),i.textureFormatFloat,i.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function iLe(n,t,e,i){const[r,s]=Rg(t,e);return Fg(n,r,s,O6(i),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function lLe(n,t,e){ge(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===q().getNumber("WEBGL_VERSION")?ge(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):ge(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===q().getNumber("WEBGL_VERSION")?ge(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):ge(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),ge(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,i,r){this.throwIfDisposed(),function aLe(n,t,e,i,r,s){let o,a,l;ge(n,()=>n.bindTexture(n.TEXTURE_2D,t)),r instanceof Uint8Array?(o=new Uint8Array(e*i*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(e*i*4),a=n.FLOAT,l=s.internalFormatPackedFloat),o.set(r),2===q().getNumber("WEBGL_VERSION")?ge(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,i,n.RGBA,a,o)):ge(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,i,0,n.RGBA,a,o)),ge(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,i,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function sLe(n,t,e,i){const[r,s]=Ih(t,e);return Fg(n,r,s,P6(i),n.RGBA,i.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function rLe(n,t,e,i){const[r,s]=Ih(t,e);return Fg(n,r,s,F6(i),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(w6(this.gl,this.framebuffer),this.outputTexture=null),ge(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,i){return this.downloadMatrixDriver(t,()=>function uLe(n,t,e,i){const[r,s]=Rg(t,e),a=new Uint8Array(function TPe(n,t){return n*t}(t*e,4));return ge(n,()=>n.readPixels(0,0,r,s,i.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,i,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,i,r,s,o){return function hLe(n,t,e,i,r,s,o,a){const l=n,c=new Float32Array(function APe(n,t){const[e,i]=Ih(n,t);return e*i*4}(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,s,o)}downloadFloat32MatrixFromBuffer(t,e){return function dLe(n,t,e){const i=n,r=new Float32Array(e);return i.bindBuffer(i.PIXEL_PACK_BUFFER,t),i.getBufferSubData(i.PIXEL_PACK_BUFFER,0,r),i.bindBuffer(i.PIXEL_PACK_BUFFER,null),r}(this.gl,t,e)}createBufferFromTexture(t,e,i){this.bindTextureToFrameBuffer(t);const r=function cLe(n,t,e,i){const r=n.createBuffer();ge(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=16*t*e;return ge(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),ge(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),ge(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}(this.gl,e,i);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,i;if(q().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),i=()=>{const o=r.clientWaitSync(s,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},e=s}else q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),i=()=>this.isQueryAvailable(e,q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):i=()=>!0;return{query:e,isFencePassed:i}}downloadMatrixFromPackedTexture(t,e,i){return this.downloadMatrixDriver(t,()=>function pLe(n,t,e){const i=new Float32Array(t*e*4);return ge(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,i)),i}(this.gl,e,i))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function Q2e(n){const t=br();return function PPe(n,t){const e=Ka(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ge(n,()=>n.shaderSource(e,t)),ge(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const i=function VPe(n){return Ka(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);let r;return ge(e,()=>e.attachShader(i,this.vertexShader)),ge(e,()=>e.attachShader(i,t)),function BPe(n,t){if(ge(n,()=>n.linkProgram(t)),!q().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,i),r=Object.assign(i,{vao:this.createVertexArray()}),this.bindVertexArray(r.vao),ge(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(function oLe(n,t,e){return ge(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),x6(n,t,"clipSpacePos",e,3,20,0)&&x6(n,t,"uv",e,2,20,12)}(e,r,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&JA(e,r),this.setProgram(r),r}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(ge(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&JA(this.gl,this.program)),ge(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,i=!0){return this.throwIfDisposed(),i?function qPe(n,t,e){return Ka(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function YPe(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),ge(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,i){this.throwIfDisposed(),this.throwIfNoProgram(),KPe(this.gl,t,e,i)}setOutputMatrixTexture(t,e,i){this.setOutputMatrixTextureDriver(t,i,e)}setOutputPackedMatrixTexture(t,e,i){this.throwIfDisposed();const[r,s]=Ih(e,i);this.setOutputMatrixTextureDriver(t,r,s)}setOutputMatrixWriteRegion(t,e,i,r){this.setOutputMatrixWriteRegionDriver(i,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,i,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&JA(this.gl,this.program),V0(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ge(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ge(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=$0(this.gl,2===q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const i=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=i.createQuery();return i.beginQuery(r.TIME_ELAPSED_EXT,s),s}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,i=this.getQueryTimerExtensionWebGL2();return void e.endQuery(i.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return ie(function*(){return yield CH(()=>e.disposed||e.isQueryAvailable(t,q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const i=this.gl;return i.getQueryParameter(t,i.QUERY_RESULT)/1e6}{const i=this.getQueryTimerExtensionWebGL1();return i.getQueryObjectEXT(t,i.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const i=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=i.getQueryParameter(t,i.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const i=this.getQueryTimerExtensionWebGL1(),r=i.getQueryObjectEXT(t,i.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function fLe(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:i}=this.itemsToPoll[e];i()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let i;"setTimeoutCustom"in q().platform&&(i=q().platform.setTimeoutCustom.bind(q().platform)),CH(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,i)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),eM(this.gl,t,this.framebuffer),this.debug&&V0(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(eM(this.gl,this.outputTexture,this.framebuffer),this.debug&&V0(this.gl)):w6(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const i=e();return this.unbindTextureToFrameBuffer(),i}setOutputMatrixTextureDriver(t,e,i){this.throwIfDisposed();const r=this.gl;eM(r,t,this.framebuffer),this.debug&&V0(r),this.outputTexture=t,ge(r,()=>r.viewport(0,0,e,i)),ge(r,()=>r.scissor(0,0,e,i))}setOutputMatrixWriteRegionDriver(t,e,i,r){this.throwIfDisposed(),ge(this.gl,()=>this.gl.scissor(t,e,i,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:mLe,bincountImpl:L6,bincountReduceImpl:gLe,castImpl:_Le,ceilImpl:bLe,concatImpl:yLe,equalImpl:vLe,expImpl:xLe,expm1Impl:wLe,floorImpl:CLe,gatherNdImpl:DLe,gatherV2Impl:SLe,greaterImpl:kLe,greaterEqualImpl:ELe,lessImpl:ILe,lessEqualImpl:TLe,linSpaceImpl:ALe,logImpl:MLe,maxImpl:NLe,maximumImpl:RLe,minimumImpl:OLe,multiplyImpl:FLe,negImpl:PLe,notEqualImpl:LLe,prodImpl:$Le,raggedGatherImpl:VLe,raggedRangeImpl:BLe,raggedTensorToTensorImpl:zLe,rangeImpl:ULe,rsqrtImpl:HLe,scatterImpl:jLe,sigmoidImpl:WLe,simpleAbsImpl:$6,sliceImpl:GLe,sparseFillEmptyRowsImpl:qLe,sparseReshapeImpl:YLe,sparseSegmentReductionImpl:V6,sqrtImpl:KLe,stridedSliceImpl:XLe,stringNGramsImpl:ZLe,stringSplitImpl:QLe,stringToHashBucketFastImpl:JLe,subImpl:e$e,tileImpl:t$e,topKImpl:n$e,transposeImpl:oM,uniqueImpl:i$e}=xn;function B6(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function vr(n,t){return 1===t?[n]:B6(n,t)}class s$e{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=yr(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=vr("rc",this.rank),i=pn(this.rank),r=this.getOutOfBoundsCondition(e),s=this.getSetup(e),o=this.getOutput(e);this.userCode=`\n        void main() {\n          ${i} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let i=0;i<=1;i++)for(let r=0;r<=1;r++){let s=`${0===i?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let o=2;o<this.rank;o++)s=`${t[t.length-1-o]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let i=this.rank-2;i<this.rank;i++)e+=`${t[i]} >= ${this.enableShapeUniforms?`outShape[${i}]`:this.outputShape[i]}`,i<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class z6{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=yr(this.outputShape.length);let i="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2==1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),i+=`\n        ${s}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${function o$e(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function o2e(n,t,e="index"){const r=function s2e(n,t){const e=n.length,i=n.map(s=>`${t}[${s}]`),r=new Array(e-1);r[e-2]=i[e-1];for(let s=e-3;s>=0;--s)r[s]=`(${r[s+1]} * ${i[s+1]})`;return r}(n.map((s,o)=>o),t);return r.map((s,o)=>`int ${n[o]} = ${e} / ${r[o]}; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`};`).join("")}(["r","c","d"],"inputShape"):vd(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":nM(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${i}\n\n        setOutput(result);\n      }\n    `}}class a$e{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,i){const r=H6(e,i),s=j6(t,r,i);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=U6(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,i);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[s].shift();return this.usedTextures[s].push(l),l}let a;return r===Oi.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===Oi.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===Oi.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===Oi.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===Oi.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(t,e,i,r){if(null==this.freeTextures)return;const s=H6(i,r),o=j6(e,s,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=U6(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=q().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],d=c.indexOf(t);if(d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(d,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function U6(n,t,e,i,r){const s=function c$e(n,t){switch(n){case Oi.PACKED_2X2_FLOAT32:return F6(t);case Oi.PACKED_2X2_FLOAT16:return P6(t);case Oi.UNPACKED_FLOAT32:return N6(t);case Oi.UNPACKED_FLOAT16:return R6(t);case Oi.PACKED_4X1_UNSIGNED_BYTE:return O6(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,i);let o;if(r){const[l,c]=Ih(n[0],n[1]);o=l*c}else{const[l,c]=Rg(n[0],n[1]);o=l*c}const a=function l$e(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,s);return o*a}function H6(n,t){if(n===Xr.UPLOAD)return Oi.PACKED_2X2_FLOAT32;if(n===Xr.RENDER||null==n)return function d$e(n){return q().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Oi.PACKED_2X2_FLOAT32:Oi.UNPACKED_FLOAT32:n?Oi.PACKED_2X2_FLOAT16:Oi.UNPACKED_FLOAT16}(t);if(n===Xr.DOWNLOAD||n===Xr.PIXELS)return Oi.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function j6(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class da{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=yr(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const vs="if (isnan(x)) return x;",u$e="return x;",W6="return abs(x);",h$e="return (x >= 0.0) ? x : (exp(x) - 1.0);",p$e=vs+"\n  return (x < 0.0) ? 0.0 : x;\n",f$e=vs+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Jl="return x;",m$e="return 1.0 / (1.0 + exp(-1.0 * x));",g$e="return x;",_$e="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",b$e="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",y$e="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",v$e="return 1.0 / (1.0 + exp(-1.0 * x));";class ec{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=yr(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class x$e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=yr(this.outputShape.length);const e=t.length,i=vr("rc",e),r=pn(e),s=function r$e(n,t){if(1===n)return"rc";let e="";for(let i=0;i<n;i++)e+=t[i],i<n-1&&(e+=",");return e}(e,i),o=i.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const w$e=Xj,q0={},k$e=q().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let T$e=(()=>{class n extends ZE{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!q().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let i;if(null!=e){if(e instanceof sM)i=e;else{const r=Io(q().getNumber("WEBGL_VERSION"),e);i=new sM(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=Io(q().getNumber("WEBGL_VERSION"));i=new sM(r),this.binaryCache=function S$e(n){return n in q0||(q0[n]={}),q0[n]}(q().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=i,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new a$e(this.gpgpu),this.numMBBeforeWarning=function I$e(){return null==q().global.screen?1024:q().global.screen.height*q().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new xH(this,Qo())}nextDataId(){return n.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,i,r,s,o,a){const l=this.makeTensorInfo(i,r),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[s,o]},c.texShape=[s,o];const d=B0(i),u=new M6(d,!1,a),h=this.runWebGLProgram(u,[l],r,[[s,o]]);return h.shape=i,c.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,i,r){if((q().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||q().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===r&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:i,dtype:r,values:e,usage:Xr.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,i,r,s,o){if(q().getBool("DEBUG")&&this.checkNumericalProblems(i),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:i,usage:Xr.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const i=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:o,slice:a,shape:l,isPacked:c}=i;if(null!=a){let p;p=c?new ec(l,Jl):new da(l,Jl);const f=this.runWebGLProgram(p,[{dataId:e,shape:l,dtype:s}],s),m=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(null!=r)return this.convertAndCacheOnCPU(e);if("string"===s)return r;const d=null!=this.activeTimers;let u,h;return d&&(u=Fr()),h="complex64"===s?qa(this.readSync(o.real.dataId),this.readSync(o.imag.dataId)):this.getValuesFromTexture(e),d&&(this.downloadWaitMs+=Fr()-u),this.convertAndCacheOnCPU(e,h)}read(e){var i=this;return ie(function*(){if(i.pendingRead.has(e)){const g=i.pendingRead.get(e);return new Promise(_=>g.push(_))}const r=i.texData.get(e),{values:s,shape:o,slice:a,dtype:l,complexTensorInfos:c,isPacked:d}=r;if(null!=a){let g;g=d?new ec(o,Jl):new da(o,Jl);const _=i.runWebGLProgram(g,[{dataId:e,shape:o,dtype:l}],l),b=i.read(_.dataId);return i.disposeIntermediateTensorInfo(_),b}if(null!=s)return i.convertAndCacheOnCPU(e);if(q().getBool("DEBUG")&&!q().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===q().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,p,u=null;if("complex64"!==l&&q().get("WEBGL_BUFFER_SUPPORTED")){h=i.decode(e);const g=i.texData.get(h.dataId);u=i.gpgpu.createBufferFromTexture(g.texture.texture,...L0(o))}if(i.pendingRead.set(e,[]),"complex64"!==l&&(yield i.gpgpu.createAndWaitForFence()),"complex64"===l){const g=yield Promise.all([i.read(c.real.dataId),i.read(c.imag.dataId)]);p=qa(g[0],g[1])}else if(null==u)p=i.getValuesFromTexture(e);else{const g=K(o);p=i.gpgpu.downloadFloat32MatrixFromBuffer(u,g)}if(null!=h&&i.disposeIntermediateTensorInfo(h),null!=u){const g=i.gpgpu.gl;ge(g,()=>g.deleteBuffer(u))}const f=i.convertAndCacheOnCPU(e,p),m=i.pendingRead.get(e);return i.pendingRead.delete(e),m.forEach(g=>g(f)),i.pendingDisposal.has(e)&&(i.pendingDisposal.delete(e),i.disposeData(e)&&Qo().removeDataId(e,i),i.pendingDeletes--),f})()}readToGPU(e,i={}){const r=this.texData.get(e),{values:s,shape:o,slice:a,dtype:l,isPacked:c,texture:d}=r;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let f;f=c?new ec(o,Jl):new da(o,Jl);const m=this.runWebGLProgram(f,[{dataId:e,shape:o,dtype:l}],l),g=this.readToGPU(m,i);return this.disposeIntermediateTensorInfo(m),g}if(null==d)throw null!=s?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,i.customTexShape),h=Qo().makeTensorFromTensorInfo(u),p=this.texData.get(u.dataId);return Object.assign({tensorRef:h},p.texture)}bufferSync(e){const i=this.readSync(e.dataId);if("string"===e.dtype)try{const r=i.map(s=>Rl(s));return vt(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return vt(e.shape,e.dtype,i)}checkNumericalProblems(e){if(null!=e)for(let i=0;i<e.length;i++){const r=e[i];if(!OPe(r))throw q().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:i,dtype:r,isPacked:s}=this.texData.get(e),o=K(i);if(q().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),f=this.texData.get(p.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...L0(i)).subarray(0,o);return this.disposeIntermediateTensorInfo(p),m}const a=q().getBool("WEBGL_PACK")&&!0===s,l=a?B0(i):i,c=a?new K2e(l):new Y2e(l),d=this.runWebGLProgram(c,[{shape:l,dtype:r,dataId:e}],"float32"),u=this.texData.get(d.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(d),h}timerAvailable(){return q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var i=this;const r=this.activeTimers,s=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=s,o=!0):this.activeTimers.push(s),this.activeTimers=s,e();const a=Qc(this.activeTimers.map(d=>d.query)).filter(d=>null!=d),l=Qc(this.activeTimers.map(d=>d.name)).filter(d=>null!=d);this.activeTimers=r,o&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return ie(function*(){if(q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const d=yield Promise.all(a);c.kernelMs=function eve(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(d),c.getExtraProfileInfo=()=>d.map((u,h)=>({name:l[h],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return i.uploadWaitMs=0,i.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Fr(),endMs:null}}endTimer(e){return q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Fr(),e)}getQueryTime(e){var i=this;return ie(function*(){return q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?i.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,i=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(i?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!i&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return null!=r&&(this.disposeData(r.real.dataId,i),this.disposeData(r.imag.dataId,i)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:i,dtype:r,texShape:s,usage:o,isPacked:a,slice:l}=this.texData.get(e),c=l&&l.origDataId||e,d=this.dataRefCount.get(c);d>1?this.dataRefCount.set(c,d-1):(this.dataRefCount.delete(c),null!=i&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(i,s,o,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,i=k$e){return q().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>null==this.texData.get(r.dataId).texture&&K(r.shape)<i)}getGPGPUContext(){return this.gpgpu}where(e){hs("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const i=e.dataSync();return w$e(e.shape,i)}packedUnaryOp(e,i,r){const s=new ec(e.shape,i),o=this.compileAndRun(s,[e],r);return Qo().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const s=$6(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(q().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,W6,e.dtype);const i=new da(e.shape,W6),r=this.compileAndRun(i,[e]);return Qo().makeTensorFromTensorInfo(r)}makeTensorInfo(e,i,r){let s;if("string"===i&&null!=r&&r.length>0&&Xf(r[0])){const o=r.map(a=>Nl(a));s=this.write(o,e,i)}else s=this.write(r,e,i);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:i}}makeOutput(e,i,r){return Qo().makeTensorFromTensorInfo(this.makeTensorInfo(e,i,r),this)}unpackTensor(e){const i=new x$e(e.shape);return this.runWebGLProgram(i,[e],e.dtype)}packTensor(e){const i=new s$e(e.shape);return this.runWebGLProgram(i,[e],e.dtype,null,!0)}packedReshape(e,i){const r=[Th(e.shape),...Ah(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[Th(i),...Ah(i)],a=new z6(o,r),d=this.runWebGLProgram(a,[s],e.dtype,[r],!0);return{dataId:d.dataId,shape:i,dtype:d.dtype}}decode(e,i){const r=this.texData.get(e),{isPacked:s,shape:o,dtype:a}=r;null!=i&&S(K(o)<=i[0]*i[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=B0(o);let c;c=s?new q2e(l):new G2e(l);const u=[i??L0(l)];return{dtype:a,shape:o,dataId:this.runWebGLProgram(c,[{shape:l,dtype:a,dataId:e}],a,u,!0,i).dataId}}runWebGLProgram(e,i,r,s,o=!1,a){const l=this.makeTensorInfo(e.outputShape,r),c=this.texData.get(l.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Eh.DENSE){const b=a??L0(e.outputShape);c.texShape=b.map(y=>2*y)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===K(l.shape))return c.values=zi(l.dtype,0),l;const d=[],u=i.map(b=>{if("complex64"===b.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(b.dataId);if(null==y.texture){if(!e.packedInputs&&K(b.shape)<=q().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:y.values};e.packedInputs&&(y.isPacked=!0,y.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!y.isPacked!=!!e.packedInputs)b=y.isPacked?this.unpackTensor(b):this.packTensor(b),d.push(b),y=this.texData.get(b.dataId);else if(y.isPacked&&!U0(y.shape,b.shape)){const v=b,x=b.shape;b.shape=y.shape,b=this.packedReshape(b,x),d.push(b),y=this.texData.get(b.dataId),v.shape=x}return{shape:b.shape,texData:y,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:c,isUniform:!1},p=function W2e(n,t,e){let i="";t.concat(e).forEach(o=>{const a=null!=o.texData&&null!=o.texData.slice&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:u}=rM(n.packedInputs,o.shape,l);let h="",p="",f="";if(1===d.length&&n.packedInputs){const x=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${x[0]>1}_${x[1]>1}`}else if(2!==d.length||n.packedInputs){if(d.length>2&&!n.packedInputs){const x=Le(d);f=`${x[0]===l[1]}_${x[x.length-1]===l[1]}`}}else p=`${d[0]>1}_${d[1]>1}`;const m=o.shape.length,g=2===d.length&&Ut(o.shape,l),_=1===K(o.shape),b=ch(o.shape,e.shape),y=!n.packedInputs&&m===e.shape.length&&Ut(l,e.texData.texShape);i+=`${m}_${y}_${c?u:""}_${d.length}_${_}_${b}_${g}_${h}_${p}_${f}_${n.packedInputs||d.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else i+=`${o.shape}_${o.isUniform?"uniform":o.texData.texShape}_${a}`});let s=n.constructor.name;return s+="_"+i+"_"+n.userCode+`${q().getNumber("WEBGL_VERSION")}`,s}(e,u,h),f=this.getAndSaveBinary(p,()=>function H2e(n,t,e,i){const r=e.map((d,u)=>{const h={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:!d.isUniform&&d.texData.isPacked,flatOffset:null};return null!=d.texData&&null!=d.texData.slice&&d.texData.slice.flatOffset>0&&(h.flatOffset=d.texData.slice.flatOffset),{name:t.variableNames[u],shapeInfo:h}}),s=r.map(d=>d.shapeInfo),o={logicalShape:i.shape,texShape:i.texData.texShape,isUniform:!1,isPacked:i.texData.isPacked,flatOffset:null},a=a2e(r,o,t),l=function LPe(n,t){const e=Ka(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ge(n,()=>n.shaderSource(e,t)),ge(n,()=>n.compileShader(e)),q().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw v6(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),c=n.createProgram(l);return q().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},T6(n,t,c))}(this.gpgpu,e,u,h)),m=null!=this.activeTimers;let g;m&&(g=this.startTimer()),q().get("ENGINE_COMPILE_ONLY")||function j2e(n,t,e,i,r){t.program.enableShapeUniforms||(A6(t.inShapeInfos,e),A6([t.outShapeInfo],[i]));const s=i.texData.texture,o=i.texData.texShape;i.texData.isPacked?n.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):n.setOutputMatrixTexture(s.texture,o[0],o[1]),n.setProgram(t.webGLProgram),1===q().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN),e.forEach((l,c)=>{const d=t.program.variableNames[c],u=t.uniformLocations[d],h=t.uniformLocations[`offset${d}`],p=t.inShapesLocations[`${d}Shape`],f=t.inTexShapesLocations[`${d}TexShape`];if(p){const{uniformShape:m}=rM(t.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(p,new Int32Array(m));break;case 2:n.gl.uniform2iv(p,new Int32Array(m));break;case 3:n.gl.uniform3iv(p,new Int32Array(m));break;case 4:n.gl.uniform4iv(p,new Int32Array(m))}}if(f&&n.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),null!=u){if(l.isUniform){if(K(l.shape)<2)n.gl.uniform1f(u,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(u,m)}return}null!=l.texData.slice&&null!=h&&n.gl.uniform1i(h,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,u,c)}});const a=t.outShapeLocation;if(a)switch(i.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(i.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(i.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(i.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(i.shape))}if(t.outShapeStridesLocation){const l=Le(i.shape);switch(i.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,i.texData.texShape[0],i.texData.texShape[1]),t.program.customUniforms&&r&&t.program.customUniforms.forEach((l,c)=>{const d=t.customUniformLocations[c],u=r[c];if("float"===l.type)n.gl.uniform1fv(d,u);else if("vec2"===l.type)n.gl.uniform2fv(d,u);else if("vec3"===l.type)n.gl.uniform3fv(d,u);else if("vec4"===l.type)n.gl.uniform4fv(d,u);else if("int"===l.type)n.gl.uniform1iv(d,u);else if("ivec2"===l.type)n.gl.uniform2iv(d,u);else if("ivec3"===l.type)n.gl.uniform3iv(d,u);else{if("ivec4"!==l.type)throw Error(`uniform type ${l.type} is not supported yet.`);n.gl.uniform4iv(d,u)}}),n.executeProgram()}(this.gpgpu,f,u,h,s),d.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const _=q().get("WEBGL_FLUSH_THRESHOLD");if(_>0){const b=Fr();b-this.lastGlFlushTime>_&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!q().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===o){const b=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),b}return l}compileAndRun(e,i,r,s,o=!1){return this.runWebGLProgram(e,i,r=r||i[0].dtype,s,o)}getAndSaveBinary(e,i){return e in this.binaryCache||(this.binaryCache[e]=i()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(q().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(i=>{this.gpgpu.deleteProgram(this.binaryCache[i].webGLProgram),delete this.binaryCache[i]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=G(()=>{if(!q().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=q().getBool("DEBUG");q().set("DEBUG",!1);const i=this.abs(Ke(1e-8)).dataSync()[0];if(q().set("DEBUG",e),i>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const i=this.texData.get(e),{shape:r,dtype:s,values:o,texture:a,usage:l,isPacked:c}=i;if(null!=a)return;const d=null!=this.activeTimers;let u;d&&(u=Fr());let h=i.texShape;if(null==h&&(h=function ZPe(n,t=!1){let e=q().getNumber("WEBGL_MAX_TEXTURE_SIZE"),i=q().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");i===1/0&&q().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(i=e/2),t&&(e*=2,i*=2,1===(n=n.map((a,l)=>l>=n.length-2?QE(n[l]):n[l])).length&&(n=[2,n[0]])),2!==n.length&&(n=Tl(n).newShape);let r=K(n),s=null;n.length<=1&&r<=e?s=[1,r]:2===n.length&&n[0]<=e&&n[1]<=e?s=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?s=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?s=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?s=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(s=[n[0],n[1]*n[2]*n[3]]);const o=null!=s&&Math.max(...s)>i&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||o)if(t){const a=Th(n);let l=2,c=2;n.length&&([l,c]=Ah(n)),r=a*(l/2)*(c/2),s=eI(r).map(d=>2*d)}else s=eI(r);return s}(r,c),i.texShape=h),null!=o){const p=B0(r);let f,m=h[1],g=h[0];const _=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(c||!_)&&([m,g]=Ih(h[0],h[1])),f=c?new Z2e(p,_):new M6(p,_);const b=_?[g,m]:h,y=this.makeTensorInfo(b,s),v=this.texData.get(y.dataId);v.usage=_?Xr.PIXELS:Xr.UPLOAD,v.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),m,g,o);const C=this.runWebGLProgram(f,[y],s,[[g,m]],!0),D=this.texData.get(C.dataId);i.texShape=D.texShape,i.isPacked=D.isPacked,i.usage=D.usage,q().get("ENGINE_COMPILE_ONLY")?this.disposeData(C.dataId):(i.texture=D.texture,i.values=null,this.texData.delete(C.dataId)),this.disposeIntermediateTensorInfo(y),d&&(this.uploadWaitMs+=Fr()-u)}else{const p=this.acquireTexture(h,l,s,c);i.texture=p}}convertAndCacheOnCPU(e,i){const r=this.texData.get(e),{dtype:s}=r;return null!=i&&(r.values=function A$e(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let i=0;i<e.length;++i)e[i]=Math.round(n[i]);return e}throw new Error(`Unknown dtype ${t}`)}(i,s)),r.values}acquireTexture(e,i,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,i,s)}computeBytes(e,i){return e[0]*e[1]*hv(i)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return ie(function*(){const i=[];if(e.gpgpu.parallelCompilationExtension){for(const[,r]of Object.entries(e.binaryCache))i.push(e.checkCompletionAsync_(r));return Promise.all(i)}for(const[,r]of Object.entries(e.binaryCache)){const s=new Promise(o=>{try{e.checkCompletion_(r),o(!0)}catch(a){throw a}});i.push(s)}return Promise.all(i)})()}checkCompletionAsync_(e){var i=this;return ie(function*(){return i.gpgpu.gl.getProgramParameter(e.webGLProgram,i.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?i.checkCompletion_(e):(yield wj(),i.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(v6(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:i,customUniformLocations:r,infLoc:s,nanLoc:o,inShapesLocations:a,inTexShapesLocations:l,outShapeLocation:c,outShapeStridesLocation:d,outTexShapeLocation:u}=T6(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=i,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=o,e.inShapesLocations=a,e.inTexShapesLocations=l,e.outShapeLocation=c,e.outShapeStridesLocation=d,e.outTexShapeLocation=u}}createTensorFromGPUData(e,i,r){e.channels=e.channels||"RGBA";const{texture:s,height:o,width:a,channels:l}=e,c=Qo().backend;if(!c.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const d=c.writeTexture(s,i,r,o,a,l);return Qo().makeTensorFromDataId(d,i,r,c)}}return n.nextDataId=0,n})();r4()&&x4("webgl",()=>new T$e,2);const aM="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class Fh{constructor(t,e,i){this.variableNames=["A","B"],this.outputShape=Je(e,i),this.enableShapeUniforms=yr(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Pg="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Lg{constructor(t,e,i,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Je(e,i);const s=this.outputShape.length;this.enableShapeUniforms=yr(s);let o="";if(r)if(0===s||1===K(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${pn(s)} coords = getOutputCoords();\n        `,1===s)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=vr("coords",s);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${l[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function Zr(n){const{inputs:t,backend:e}=n,{x:i}=t;return e.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const R$e={kernelName:bm,backendName:"webgl",kernelFunc:Zr};function tc(n){const{inputs:t,backend:e}=n,{real:i,imag:r}=t,s=e.makeTensorInfo(i.shape,"complex64"),o=e.texData.get(s.dataId),a=Zr({inputs:{x:i},backend:e}),l=Zr({inputs:{x:r},backend:e});return o.complexTensorInfos={real:a,imag:l},s}const O$e={kernelName:fI,backendName:"webgl",kernelFunc:tc},G6="return (a < 0.) ? b * a : a;",q6="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",P$e={kernelName:Rv,backendName:"webgl",kernelFunc:function F$e(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{alpha:s}=i,o=e.makeTensorInfo([],"float32",Ml(s,"float32")),a=q().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Lg(q6,r.shape,o.shape):new Fh(G6,r.shape,o.shape),l=e.runWebGLProgram(a,[r,o],"float32");return e.disposeIntermediateTensorInfo(o),l}},Y6="return (a < 0.) ? b * a : a;",K6="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",$$e={kernelName:Qv,backendName:"webgl",kernelFunc:function L$e(n){const{inputs:t,backend:e}=n,{x:i,alpha:r}=t,s=q().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Lg(K6,i.shape,r.shape):new Fh(Y6,i.shape,r.shape);return e.runWebGLProgram(s,[i,r],"float32")}},Ph="if (isnan(x)) return x;";function Rt({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:i}){return({inputs:r,backend:s})=>{const{x:o}=r,a=s,l=i||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=e){const u=a.texData.get(o.dataId),h=e(u.values,l);return a.makeTensorInfo(o.shape,l,h)}let d;return d=q().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new ec(o.shape,t):new da(o.shape,n),a.runWebGLProgram(d,[o],l)}}function ji({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:i=!1,cpuKernelImpl:r,dtype:s}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,d=a;if(i&&"complex64"===l.dtype){const f=d.texData.get(l.dataId),m=d.texData.get(c.dataId),[g,_]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(y=>{const[v,x]=y,w={dataId:v.dataId,dtype:v.dtype,shape:l.shape},C={dataId:x.dataId,dtype:x.dtype,shape:c.shape},D=new Fh(n,l.shape,c.shape);return d.runWebGLProgram(D,[w,C],Gr(v.dtype,x.dtype))}),b=tc({inputs:{real:g,imag:_},backend:d});return d.disposeIntermediateTensorInfo(g),d.disposeIntermediateTensorInfo(_),b}const u=s||Gr(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([l,c]))&&null!=r){const f=d.texData.get(l.dataId).values,m=d.texData.get(c.dataId).values,g="string"===l.dtype?dd(f):f,_="string"===l.dtype?dd(m):m,[b,y]=r(l.shape,c.shape,g,_,u),v=d.makeTensorInfo(y,u);return d.texData.get(v.dataId).values=b,v}let p;return p=q().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new Lg(t,l.shape,c.shape,e):new Fh(n,l.shape,c.shape),d.runWebGLProgram(p,[l,c],u)}}function $g(n,t=!1){if("linear"===n)return t?g$e:u$e;if("relu"===n)return t?b$e:p$e;if("elu"===n)return t?_$e:h$e;if("relu6"===n)return t?y$e:f$e;if("prelu"===n)return t?K6:Y6;if("leakyrelu"===n)return t?q6:G6;if("sigmoid"===n)return t?v$e:m$e;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class X6{constructor(t,e,i,r=!1,s=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i,this.enableShapeUniforms=yr(this.outputShape.length);const u=Math.ceil((r?t[1]:t[2])/2),h=r?"i * 2, rc.y":"rc.y, i * 2",p=s?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",_="";a&&(g=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,_="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";t[0]<e[0]?y=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(v=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${y};\n        int batchB = ${v};\n        for (int i = 0; i < ${u}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${f[0]} * ${m[0]});\n          result += (${f[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${_}\n\n        setOutput(result);\n      }\n    `}}const Z6={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Q6{constructor(t,e,i){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Je(e,i),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const J6="return a * b;";function lM(n){const{inputs:t,backend:e}=n,{a:i,b:r}=t,s=Gr(i.dtype,r.dtype);if("complex64"===i.dtype){const a=e.texData.get(i.dataId),l=e.texData.get(r.dataId),c=new Q6(Z6.REAL,i.shape,r.shape),d=new Q6(Z6.IMAG,i.shape,r.shape),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],h=e.runWebGLProgram(c,u,"float32"),p=e.runWebGLProgram(d,u,"float32"),f=tc({inputs:{real:h,imag:p},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),f}if(e.shouldExecuteOnCPU([i,r])){const a=e.texData.get(i.dataId),l=e.texData.get(r.dataId),[c,d]=FLe(i.shape,r.shape,a.values,l.values,s),u=e.makeTensorInfo(d,s);return e.texData.get(u.dataId).values=c,u}let o;return o=q().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Lg(J6,i.shape,r.shape):new Fh(J6,i.shape,r.shape),e.runWebGLProgram(o,[i,r],s)}const V$e={kernelName:Em,backendName:"webgl",kernelFunc:lM};function ye(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{shape:s}=i,o=e,a=K(r.shape),l=DH(s,a),c=K(l);S(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const d=o.texData.get(r.dataId);return!d.isPacked||U0(r.shape,l)||null!==d.texture&&U0(d.shape,l)?(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype}):function B$e(n,t,e){const i=[Th(n.shape),...Ah(n.shape)],r={dtype:n.dtype,shape:i,dataId:n.dataId},s=[Th(t),...Ah(t)],o=new z6(s,i),c=e.runWebGLProgram(o,[r],n.dtype,[i],!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(r,l,o)}const z$e={kernelName:ex,backendName:"webgl",kernelFunc:ye};class eq{constructor(t,e){this.variableNames=["x"];const{windowSize:i,batchSize:r,inSize:s,outSize:o}=t;this.outputShape=[r,o];const a=4*Math.floor(i/4),l=i%4;let c="sumValue += dot(values, ones);";if(null!=e){const u=1/e;c=`sumValue += dot(values * ${Xu(u)?u.toPrecision(2):u}, ones);`}let d="";s%i>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class U$e{constructor(t,e){this.variableNames=["x"];const{windowSize:i,batchSize:r,inSize:s,outSize:o}=t;this.outputShape=[r,o];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const d=4*Math.floor(i/4),u=i%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let f="";s%i>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===u}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===u}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===u}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${c});\n      }\n    `}}function wd(n,t,e,i){const r=function H$e(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],i=Wx(e);t.push({inSize:e,windowSize:i,outSize:Math.ceil(e/i)})}return t}(n.shape);let s=n;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:c}=r[o];let d,u;d="mean"===e?0===o?new eq({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new eq({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):new U$e({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},e),u=s,s=i.runWebGLProgram(d,[s],t),u.dataId!==n.dataId&&i.disposeIntermediateTensorInfo(u)}return s}class j$e{constructor(t,e){this.variableNames=["A"];const i=new Array(t.length);for(let o=0;o<i.length;o++)i[o]=t[e[o]];this.outputShape=i,this.rank=i.length;const r=pn(this.rank),s=function W$e(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],i=new Array(t);for(let r=0;r<n.length;r++)i[n[r]]=e[r];return i.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class G$e{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const i=new Array(t.length);for(let d=0;d<i.length;d++)i[d]=t[e[d]];if(this.outputShape=i,this.rank=i.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=pn(this.rank),s=B6("rc",this.rank),o=new Array(this.rank);for(let d=0;d<e.length;d++)o[e[d]]=s[d];const a=`vec2(${o.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${i[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${l}) {\n        result[1] = ${c};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${i[this.rank-2]}) {\n        result[2] = ${c};\n        if(${l}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Y0(n,t,e){const i=q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new G$e(n.shape,t):new j$e(n.shape,t);return e.runWebGLProgram(i,[n],n.dtype)}function K0(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i;return function q$e(n,t,e,i){const s=n.shape.length,o=yt(t,n.shape);let a=o;const l=Rn(a,s),c=null!=l;let d=n;c&&(d=Y0(n,l,i),a=Xn(a.length,s)),Hi("sum",a,s);const[u,h]=Ai(d.shape,a);let p=u;e&&(p=Kn(u,o));const f=K(h),_=ye({inputs:{x:d},attrs:{shape:[K(n.shape)/f,f]},backend:i}),y=wd(_,c1(n.dtype),"sum",i),v=ye({inputs:{x:y},attrs:{shape:p},backend:i});return i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(y),c&&i.disposeIntermediateTensorInfo(d),v}(r,s,o,e)}const Y$e={kernelName:ox,backendName:"webgl",kernelFunc:K0};function xr(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{perm:s}=i,o=e,l=new Array(r.shape.length);for(let d=0;d<l.length;d++)l[d]=r.shape[s[d]];let c;if(o.shouldExecuteOnCPU([r])){const u=o.texData.get(r.dataId).values,h=oM(u,r.shape,r.dtype,s,l);c=o.makeTensorInfo(l,r.dtype),o.texData.get(c.dataId).values=h}else c=Y0(r,s,o);return c}const K$e={kernelName:eh,backendName:"webgl",kernelFunc:xr},tq=1e3;function X0({a:n,b:t,transposeA:e,transposeB:i,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,d=t.shape.length,u=e?n.shape[c-2]:n.shape[c-1],h=i?t.shape[d-1]:t.shape[d-2],p=e?n.shape[c-1]:n.shape[c-2],f=i?t.shape[d-2]:t.shape[d-1],m=n.shape.slice(0,-2),g=t.shape.slice(0,-2),_=K(m),b=K(g),v=Je(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);S(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${i} must match.`);const x=e?[_,u,p]:[_,p,u],w=i?[b,f,h]:[b,h,f],C=ye({inputs:{x:n},backend:r,attrs:{shape:x}}),D=ye({inputs:{x:t},backend:r,attrs:{shape:w}}),k=[C,D],I=Math.max(_,b),A=e?C.shape[1]:C.shape[2],$=null!=s,H=null!=o,W="leakyrelu"===l,z=null!=l?$g(l,!0):null;let F;if((1===p||1===f)&&A>tq&&!1===($||H||W||null!=z)){let j=C,Z=D;e&&(j=xr({inputs:{x:C},backend:r,attrs:{perm:[0,2,1]}}),k.push(j)),i&&(Z=xr({inputs:{x:D},backend:r,attrs:{perm:[0,2,1]}}),k.push(Z));const se=1===f;let re=j;1!==f&&(re=ye({inputs:{x:j},backend:r,attrs:{shape:[I,A,1]}}),k.push(re));const ae=1===f?2:1;let pe=Z;se&&(pe=ye({inputs:{x:Z},backend:r,attrs:{shape:[I,1,A]}}),k.push(pe));const xe=lM({inputs:{a:re,b:pe},backend:r});F=K0({inputs:{x:xe},backend:r,attrs:{axis:ae,keepDims:!0}}),k.push(xe)}else{const j=Gr(n.dtype,t.dtype),Z=new X6(x,w,[I,p,f],e,i,$,z,H,W),ee=[C,D];if(null!=s&&ee.push(s),H&&ee.push(o),W){const se=r.makeTensorInfo([],"float32",Ml(a,"float32"));ee.push(se),k.push(se)}F=r.runWebGLProgram(Z,ee,j)}const L=ye({inputs:{x:F},backend:r,attrs:{shape:v}});k.push(F);for(const j of k)r.disposeIntermediateTensorInfo(j);return L}const Z$e={kernelName:px,backendName:"webgl",kernelFunc:function X$e(n){const{inputs:t,backend:e,attrs:i}=n,{a:r,b:s,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:u}=i;return X0({a:r,b:s,transposeA:l,transposeB:c,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:u,activation:d})}},nq="return abs(x);",J$e={kernelName:pv,backendName:"webgl",kernelFunc:function Q$e(n){const{inputs:t,backend:e}=n,{x:i}=t;if(e.shouldExecuteOnCPU([i])&&"complex64"!==i.dtype){const s=e.texData.get(i.dataId),o=$6(s.values);return e.makeTensorInfo(i.shape,i.dtype,o)}let r;return r=q().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new ec(i.shape,nq):new da(i.shape,nq),e.runWebGLProgram(r,[i],i.dtype)}},tVe=Rt({opSnippet:vs+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),nVe={kernelName:Qf,backendName:"webgl",kernelFunc:tVe},rVe=Rt({opSnippet:vs+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),sVe={kernelName:Jf,backendName:"webgl",kernelFunc:rVe},iq="return a + b;",oVe=ji({opSnippet:iq,packedOpSnippet:iq,supportsComplex:!0,cpuKernelImpl:mLe}),aVe={kernelName:Ju,backendName:"webgl",kernelFunc:oVe};class lVe{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((s,o)=>`T${o}`);const i=[];this.variableNames.forEach(s=>{i.push(`float v${s} = get${s}AtOutCoords();`)});const r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`\n      void main() {\n        ${i.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class cVe{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,o)=>`T${o}`);const i=[];this.variableNames.forEach(s=>{i.push(`vec4 v${s} = get${s}AtOutCoords();`)});const r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`\n      void main() {\n        ${i.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const dVe={kernelName:lI,backendName:"webgl",kernelFunc:function Z0(n){const{inputs:t,backend:e}=n,i=t;if(1===i.length)return Zr({inputs:{x:i[0]},backend:e});if(i.length>q().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(i.length/2),c=Z0({inputs:i.slice(0,l),backend:e}),d=Z0({inputs:i.slice(l),backend:e});return Z0({inputs:[c,d],backend:e})}const r=i.map(l=>l.dtype).reduce((l,c)=>Gr(l,c)),s=i.map(l=>l.shape),a=q().getBool("WEBGL_PACK")?new cVe(i[0].shape,s):new lVe(i[0].shape,s);return e.runWebGLProgram(a,i,r)}},hVe={kernelName:"All",backendName:"webgl",kernelFunc:function uVe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i,a=r.shape.length,l=yt(s,r.shape);let c=l;const d=Rn(c,a);let u=r;null!=d&&(u=xr({inputs:{x:r},backend:e,attrs:{perm:d}}),c=Xn(c.length,a)),Hi("all",c,a);const[h,p]=Ai(u.shape,c),m=ye({inputs:{x:u},backend:e,attrs:{shape:[-1,K(p)]}}),g=wd(m,m.dtype,"all",e);let _;return _=ye(o?{inputs:{x:g},backend:e,attrs:{shape:Kn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=d&&e.disposeIntermediateTensorInfo(u),_}},fVe={kernelName:"Any",backendName:"webgl",kernelFunc:function pVe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i,a=r.shape.length,l=yt(s,r.shape);let c=l;const d=Rn(c,a);let u=r;null!=d&&(u=xr({inputs:{x:r},backend:e,attrs:{perm:d}}),c=Xn(c.length,a)),Hi("any",c,a);const[h,p]=Ai(u.shape,c),m=ye({inputs:{x:u},backend:e,attrs:{shape:[-1,K(p)]}}),g=wd(m,m.dtype,"any",e);let _;return _=ye(o?{inputs:{x:g},backend:e,attrs:{shape:Kn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=d&&e.disposeIntermediateTensorInfo(u),_}};class mVe{constructor(t,e,i){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:o}=t;i||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${i?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class gVe{constructor(t,e,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S(t.length>2,()=>`Packed arg${i.charAt(0).toUpperCase()+i.slice(1)} supports only inputs with rank above 2.`);const o=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=pn(l),d=vr("coords",l);let u,h;if(1===o){h=l+1;const D=pn(h);u=`\n        ${D} sourceLocR = ${D}(${d.join()}, 0);\n        ++${d[l-1]};\n        ${D} sourceLocG = ${D}(${d.join()}, 0);\n        ++${d[l-2]};\n        ${D} sourceLocA = ${D}(${d.join()}, 0);\n        --${d[l-1]};\n        ${D} sourceLocB = ${D}(${d.join()}, 0);\n        --${d[l-2]};`}else h=l,u=`\n        ${c} sourceLocR = coords;\n        ++${d[l-1]};\n        ${c} sourceLocG = coords;\n        ++${d[l-2]};\n        ${c} sourceLocA = coords;\n        --${d[l-1]};\n        ${c} sourceLocB = coords;\n        --${d[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],m=p.map(D=>"int "+D),g=vr("sourceLocR",h-1).concat("inIdx.r"),_=vr("sourceLocG",h-1).concat("inIdx.g"),b=vr("sourceLocB",h-1).concat("inIdx.b"),y=vr("sourceLocA",h-1).concat("inIdx.a"),v="max"===i?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${_.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,w=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${_.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,C=r?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${C}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${d[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${d[l-2]} < ${a[l-2]-1};\n        ${u}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function rq(n,t,e,i=null){let r=t.shape[0],s=t.shape[1];null!=i&&(r=i.shape[0],s=i.shape[1]);const o=Wx(s),a={windowSize:o,inSize:s,batchSize:r,outSize:Math.ceil(s/o)},l=new mVe(a,e,null==i),c=[t];null!=i&&c.push(i);const d=n.runWebGLProgram(l,c,"int32");if(1===d.shape[1])return d;const u=rq(n,t,e,d);return n.disposeIntermediateTensorInfo(d),u}function sq(n,t,e,i=null){const r=null!=i?i.shape:t.shape,o=Wx(r[r.length-1]),a=new gVe(r,o,e,null==i),c=n.runWebGLProgram(a,null==i?[t]:[t,i],"int32");if(c.shape.length===t.shape.length){const d=sq(n,t,e,c);return n.disposeIntermediateTensorInfo(c),d}return c}function oq(n,t,e,i){const r=[e];if(Hi("arg"+i.charAt(0).toUpperCase()+i.slice(1),r,t.shape.length),!q().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const s=[],o=n.texData.get(t.dataId);let l=t;null!==o&&o.isPacked&&(l=n.unpackTensor(t),s.push(l));const[c,d]=Ai(l.shape,r),u=K(d),h=ye({inputs:{x:l},backend:n,attrs:{shape:[-1,u]}});s.push(h);const p=rq(n,h,i);s.push(p);const f=ye({inputs:{x:p},backend:n,attrs:{shape:c}});return s.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}return sq(n,t,i)}const bVe={kernelName:fv,backendName:"webgl",kernelFunc:function _Ve(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s}=i;let o=yt(s,r.shape);const a=Rn(o,r.shape.length);let l=r;const c=[];null!=a&&(l=xr({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=Xn(o.length,l.shape.length)),Hi("argMax",[o[0]],l.shape.length);const d=oq(e,l,o[0],"max");return c.forEach(u=>e.disposeIntermediateTensorInfo(u)),d}},vVe={kernelName:mv,backendName:"webgl",kernelFunc:function yVe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s}=i;let o=yt(s,r.shape);const a=Rn(o,r.shape.length);let l=r;const c=[];null!=a&&(l=xr({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=Xn(o.length,l.shape.length)),Hi("argMin",[o[0]],l.shape.length);const d=oq(e,l,o[0],"min");return c.forEach(u=>e.disposeIntermediateTensorInfo(u)),d}},wVe=Rt({opSnippet:vs+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),CVe={kernelName:em,backendName:"webgl",kernelFunc:wVe},SVe=Rt({opSnippet:vs+"return log(x + sqrt(x * x + 1.0));"}),kVe={kernelName:tm,backendName:"webgl",kernelFunc:SVe},IVe=Rt({opSnippet:vs+"\n  return atan(x);\n"}),TVe={kernelName:nm,backendName:"webgl",kernelFunc:IVe},NVe=ji({opSnippet:aM+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Pg+"\n  return result;\n"}),RVe={kernelName:rm,backendName:"webgl",kernelFunc:NVe},FVe=Rt({opSnippet:vs+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),PVe={kernelName:im,backendName:"webgl",kernelFunc:FVe};class Vg{constructor(t,e,i,r=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&i)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,d=t.dilationWidth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;const m="avg"===e;let b="0.0";if(m||(b="-1.0 / 1e-20"),i)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${p}, ${f});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${u};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${d}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(v="avgValue / max(count, 1.0)");const x=4*Math.floor(o/4),w=o%4,C=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${p}, ${f});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${u};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${d};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              getValue(batch, xR, xC + 2 * ${d}, d),\n              getValue(batch, xR, xC + 3 * ${d}, d)\n            );\n\n            ${C}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${C}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${C}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              getValue(batch, xR, xC + 2 * ${d}, d),\n              initializationValue\n            );\n\n            ${C}\n          }\n        }\n        setOutput(${v});\n      }\n    `}}class cM{constructor(t,e,i,r=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&i)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideDepth,l=t.strideHeight,c=t.strideWidth,d=t.dilationDepth,u=t.dilationHeight,h=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,_=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const y="avg"===e;let v="0.0";if(y||(v="-1.0 / 1e-20"),i)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${c});\n        const ivec3 pads = ivec3(${g}, ${_}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${d}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${f};\n                wR += ${u}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(w="avgValue / max(count, 1.0)");const C=4*Math.floor(o/4),D=o%4,k=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${c});\n      const ivec3 pads = ivec3(${g}, ${_}, ${b});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${d}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${f};\n            wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${C}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${C};\n            if (${1===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n        }\n        setOutput(${w});\n      }\n    `}}const $Ve={kernelName:gv,backendName:"webgl",kernelFunc:function LVe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t;Og(r,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i;S(Ui(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=Hs(r.shape,s,o,1,a,l);if(1===d.filterWidth&&1===d.filterHeight&&Ut(d.inShape,d.outShape))return Zr({inputs:{x:r},backend:e});const u=new Vg(d,"avg",!1);return e.runWebGLProgram(u,[r],"float32")}},BVe={kernelName:_v,backendName:"webgl",kernelFunc:function VVe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=i,u=Ua(r.shape,s,o,[1,1,1],a,l,c),h=new cM(u,"avg",!1);return e.runWebGLProgram(h,[r],"float32")}};class zVe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class UVe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const u=t.effectiveFilterDepth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${u-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${p-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${u};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const jVe={kernelName:hI,backendName:"webgl",kernelFunc:function HVe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,input:s}=t,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=i,h=Ua(o.shape,a,l,[1,1,1],c,d),p=new UVe(h);return e.runWebGLProgram(p,[r],o.dtype)}},GVe={kernelName:uI,backendName:"webgl",kernelFunc:function WVe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,input:s}=t,o=s;Og([r,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=i,d=Hs(o.shape,a,l,1,c),u=new zVe(d);return e.runWebGLProgram(u,[r],o.dtype)}},YVe={kernelName:bv,backendName:"webgl",kernelFunc:function qVe(n){const{inputs:t,backend:e,attrs:i}=n,{a:r,b:s}=t,{transposeA:o,transposeB:a}=i;return X0({a:r,b:s,transposeA:o,transposeB:a,backend:e})}};class KVe{constructor(t,e,i,r,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Je(t,e),Je(t,i);let a="0.0";null!=r&&(Je(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=s&&(Je(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class XVe{constructor(t,e,i,r,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Je(t,e),Je(t,i);let a="vec4(0.0)";null!=r&&(Je(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=s&&(Je(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const ZVe={kernelName:Av,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:i,mean:r,variance:s,offset:o,scale:a}=n;S(r.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==a||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const c=[i,r,s];let d=null;null!=o&&(d=o.shape,c.push(o));let u=null;null!=a&&(u=a.shape,c.push(a));const h=q().getBool("WEBGL_PACK_NORMALIZATION")?new XVe(i.shape,r.shape,s.shape,d,u,l):new KVe(i.shape,r.shape,s.shape,d,u,l);return t.runWebGLProgram(h,c,c[0].dtype)}};class QVe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=pn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const i=function JVe(n){if(1===n)return"sourceLoc";if(n<=6)return dM.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let r;r=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((o,a)=>`sourceLoc.${dM[a]} = start[${a}] + coords.${dM[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${i}));\n      }\n    `}}const dM=["x","y","z","w","u","v"];class eBe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=pn(this.rank),i=vr("coords",this.rank),r=vr("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${s})`,a=`\n      result.x = ${o};\n      if (++${i[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${o};\n        --${r[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${i[this.rank-1]};\n      if (++${i[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${o};\n        if (++${i[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((d,u)=>`start[${u}]`).join()});`:t.map((d,u)=>`${r[u]} = ${i[u]} + start[${u}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function Lh(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{begin:s,size:o}=i,[a,l]=Tx(r,s,o);if(F1(r,a,l),0===K(l))return e.makeTensorInfo(l,r.dtype,[]);if(e.shouldExecuteOnCPU([r])||"string"===r.dtype){const u=e.texData.get(r.dataId),h=GLe(u.values,a,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,h)}const{isPacked:c}=e.texData.get(r.dataId),d=L1(r.shape,a,l);if(c||!d){const u=q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new eBe(l):new QVe(l);return e.runWebGLProgram(u,[r],r.dtype,[a])}return e.uploadToGPU(r.dataId),function tBe(n,t,e,i){const r=i.texData.get(n.dataId),s=i.makeTensorInfo(e,n.dtype),o=i.texData.get(s.dataId);Object.assign(o,r),o.refCount=1,o.shape=e,o.dtype=n.dtype;let a=$1(t,Le(n.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=i.dataRefCount.get(o.slice.origDataId)||1;return i.dataRefCount.set(o.slice.origDataId,l+1),s}(r,a,l,e)}const nBe={kernelName:sx,backendName:"webgl",kernelFunc:Lh},iBe={kernelName:yv,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{blockShape:s,crops:o}=i;S(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((b,y)=>b*y),l=hg(r.shape,s,a),c=pg(l.length,s.length),d=fg(r.shape,s,a),u=vT(o,s.length),h=xT(d,o,s.length),p=[],f=ye({inputs:{x:r},backend:e,attrs:{shape:l}}),m=xr({inputs:{x:f},backend:e,attrs:{perm:c}}),g=ye({inputs:{x:m},backend:e,attrs:{shape:d}}),_=Lh({inputs:{x:g},backend:e,attrs:{begin:u,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(b=>e.disposeIntermediateTensorInfo(b)),_}},sBe={kernelName:pI,backendName:"webgl",kernelFunc:function rBe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,weights:s}=t,{size:o}=i,a=e.readSync(r.dataId),l=e.readSync(s.dataId),c=L6(a,l,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,c)}},aBe={kernelName:MH,backendName:"webgl",kernelFunc:function oBe(n){const{inputs:t,backend:e}=n,{s0:i,s1:r}=t,s=e.readSync(i.dataId),o=e.readSync(r.dataId),a=Je(Array.from(s),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},aq=ji({opSnippet:"return float(a != b);",cpuKernelImpl:LLe,dtype:"bool"}),lBe={kernelName:qv,backendName:"webgl",kernelFunc:aq};function Bg(n){const{inputs:t,backend:e}=n,{input:i}=t;return Zr({inputs:{x:e.texData.get(i.dataId).complexTensorInfos.real},backend:e})}const cBe={kernelName:VI,backendName:"webgl",kernelFunc:Bg},hBe={kernelName:sm,backendName:"webgl",kernelFunc:function uM(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{dtype:s}=i;if("complex64"===s){if("complex64"===r.dtype)return Zr({inputs:{x:r},backend:e});const o=Mi(r.shape),a=uM({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),l=tc({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===r.dtype){const o=Bg({inputs:{input:r},backend:e}),a=uM({inputs:{x:o},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(o),a}if(!SH(r.dtype,s)){const o=Zr({inputs:{x:r},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:s}}if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId).values,[a,l,c]=_Le(o,r.shape,r.dtype,s);return e.makeTensorInfo(a,l,c)}if("int32"===s)return function uBe(n,t){const e=new da(n.shape,"return float(int(x));"),i=t.runWebGLProgram(e,[n],"int32");return{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}(r,e);if("bool"===s){const o=e.makeTensorInfo([],"bool",zi("bool",1)),l=aq({inputs:{a:r,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}},lq="return ceil(x);",pBe=Rt({opSnippet:lq,packedOpSnippet:lq,cpuKernelImpl:bLe}),fBe={kernelName:om,backendName:"webgl",kernelFunc:pBe};class mBe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class gBe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const bBe={kernelName:am,backendName:"webgl",kernelFunc:function _Be(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{clipValueMin:s,clipValueMax:o}=i;let a;return a=q().getBool("WEBGL_PACK_CLIP")?new gBe(r.shape):new mBe(r.shape),e.runWebGLProgram(a,[r],r.dtype,[[s],[o]])}};class yBe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function cq(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const xBe={kernelName:vv,backendName:"webgl",kernelFunc:function vBe(n){const{inputs:t,backend:e}=n,{x:i}=t,r=e.texData.get(i.dataId),s=new yBe(i.shape),o=[cq(i,r.complexTensorInfos.real),cq(i,r.complexTensorInfos.imag)];return e.runWebGLProgram(s,o,o[0].dtype)}};class wBe{constructor(t){this.outputShape=[],this.outputShape=ta(t,1),this.variableNames=t.map((o,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const i=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++)i.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${e[o-1]}));`);i.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${i.join("\n        ")}\n      }\n    `}}class CBe{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ta(t,e);const i=this.outputShape,r=i.length,s=pn(r),o=vr("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((m,g)=>`T${g}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][e];const c=a[e],d=a.slice(-2),u=a.join();let h=`if (${c} < ${l[0]}) {\n        return getChannel(\n            getT0(${u}), vec2(${d.join()}));\n        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`\n        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {\n          return getChannel(\n            getT${m}(${Q0(a,c,g)}),\n            vec2(${Q0(d,c,g)}));\n        }`}const f=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${Q0(a,c,f)}),\n          vec2(${Q0(d,c,f)}));`,this.userCode=`\n      float getValue(${a.map(m=>"int "+m)}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[r-1]} = ${o[r-1]} + 1;\n        if (${o[r-1]} < ${i[r-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[r-2]} = ${o[r-2]} + 1;\n        if (${o[r-2]} < ${i[r-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[r-1]} = ${o[r-1]} - 1;\n        if (${o[r-2]} < ${i[r-2]} &&\n            ${o[r-1]} < ${i[r-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function Q0(n,t,e){const i=n.indexOf(t);return n.map((s,o)=>o===i?`${s} - ${e}`:s).join()}function J0(n){const{inputs:t,backend:e}=n,{input:i}=t;return Zr({inputs:{x:e.texData.get(i.dataId).complexTensorInfos.imag},backend:e})}const DBe={kernelName:MI,backendName:"webgl",kernelFunc:J0};function zg(n,t,e){const i=n[0].dtype;if("complex64"===i){const p=n.map(b=>Bg({inputs:{input:b},backend:e})),f=n.map(b=>J0({inputs:{input:b},backend:e})),m=zg(p,t,e),g=zg(f,t,e),_=tc({inputs:{real:m,imag:g},backend:e});return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),_}let r=e.shouldExecuteOnCPU(n);if("string"===i&&(r=!0),r){const p=n.map(v=>{const w=[-1,K(v.shape.slice(t))];return ye({inputs:{x:v},backend:e,attrs:{shape:w}})}),f=p.map(v=>({vals:e.readSync(v.dataId),shape:v.shape})),m=ta(p.map(v=>v.shape),1),_=yLe(f,m,i,1===p[0].shape[0]),b=ta(n.map(v=>v.shape),t),y=e.makeTensorInfo(b,i,_);return p.forEach(v=>e.disposeIntermediateTensorInfo(v)),y}const s=n.filter(p=>K(p.shape)>0),o=q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const p=o?new da(n[0].shape,Jl):new ec(n[0].shape,Jl);return e.runWebGLProgram(p,n,i)}const a=q().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){const p=[];for(let m=0;m<s.length;m+=a){const g=s.slice(m,m+a);p.push(zg(g,t,e))}const f=zg(p,t,e);for(const m of p)e.disposeIntermediateTensorInfo(m);return f}if(o){const p=new CBe(s.map(f=>f.shape),t);return e.runWebGLProgram(p,s,i)}const{tensors2D:l,outShape:c}=function SBe(n,t,e){const i=ta(n.map(s=>s.shape),t);return{tensors2D:n.map(s=>ye({inputs:{x:s},attrs:{shape:[-1,K(s.shape.slice(t))]},backend:e})),outShape:i}}(s,t,e),d=new wBe(l.map(p=>p.shape)),u=e.runWebGLProgram(d,l,i);l.forEach(p=>e.disposeIntermediateTensorInfo(p));const h=ye({inputs:{x:u},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(u),h}function dq(n){const{inputs:t,backend:e,attrs:i}=n,{axis:r}=i,s=yt(r,t[0].shape)[0];_T(t.map(c=>c.shape),s);const a=ta(t.map(c=>c.shape),s);if(0===K(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(c=>K(c.shape)>0);return 1===l.length?Zr({inputs:{x:l[0]},backend:e}):zg(l,s,e)}const kBe={kernelName:xv,backendName:"webgl",kernelFunc:dq};class uq{constructor(t,e=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,d=t.dilationHeight,u=t.dilationWidth,h=t.filterHeight,p=t.filterWidth,f=4*Math.floor(t.inChannels/4),m=t.inChannels%4,g="channelsLast"===t.dataFormat,_=g?1:2,b=g?2:3,y=g?3:1;let v="",x="";i&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`\n          float activation(float x) {\n            ${i}\n          }\n        `,x="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${_}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${d};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${u};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${f}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===m}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${f}) *\n                    getW(wR, wC, ${f}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${f}, xR, xC) *\n                    getW(wR, wC, ${f}, d2);\n              }\n\n            } else if (${2===m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2),\n                getW(wR, wC, ${f} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1),\n                  getX(batch, xR, xC, ${f} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC),\n                  getX(batch, ${f} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}}class EBe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,i=t.padInfo.top,r=t.padInfo.left,s=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,d=t.dilationWidth,u=t.filterDepth,h=t.filterHeight,p=t.filterWidth,f=4*Math.floor(t.inChannels/4),m=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${o}, ${a});\n      const ivec3 pads = ivec3(${e}, ${i}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${u}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${d};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${f}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${f}) *\n                  getW(wF, wR, wC, ${f}, d2);\n              } else if (${2===m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1),\n                  getX(batch, xF, xR, xC, ${f} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2),\n                  getW(wF, wR, wC, ${f} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class hq{constructor(t,e=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=yr(this.outputShape.length);const o=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,d=t.filterWidth,u=d;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<d;g++)h+=`\n           vec4 xTexelC${2*g};\n           int xTexelC${2*g}Ready;\n           vec4 xTexelC${2*g+1};\n           int xTexelC${2*g+1}Ready;\n           vec4 xC${g};`;h+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let g=0;g<d;g++)h+=`\n           xTexelC${2*g} = vec4(0.0);\n           xTexelC${2*g}Ready = 0;\n           xTexelC${2*g+1} = vec4(0.0);\n           xTexelC${2*g+1}Ready = 0;\n           xC${g} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(u+1)/2;g++){const _=2*g;if(h+=`\n           xC = xCCorner + ${_*l};\n           `,1===a){if(_<d&&(o%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {\n                   xTexelC${_} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${_}.zw = vec2(0.0);\n                   }\n                   xTexelC${_}Ready = 1;\n                 }\n               `,h+=1===l&&_>0?`\n                 xC${_} = vec4(xTexelC${_-2}.zw, xTexelC${_}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${_} = vec4(previous.zw, xTexelC${_}.xy);\n                   } else {\n                     xC${_} = vec4(0.0, 0.0, xTexelC${_}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${_}Ready == 0) {\n                   xTexelC${_} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${_}.zw = vec2(0.0);\n                   }\n                   xTexelC${_}Ready = 1;\n                 }\n\n                 xC${_} = xTexelC${_};\n                 `,_+1<d)){const b=o%2==0?QE(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {\n                     xTexelC${_+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${_+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${_+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${_+1} = vec4(previous.zw, xTexelC${_+1}.xy);\n                     } else {\n                      xC${_+1} = vec4(0.0, 0.0, xTexelC${_+1}.xy);\n                     }\n                     `:`\n                     xC${_+1} = vec4(xTexelC${_}.zw, xTexelC${_+1}.xy);\n                     `):h+=1===b?`\n                     xC${_+1} = xTexelC${_};\n                     `:`\n                     xCOffset = xC + ${b};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {\n                       xTexelC${_+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${_+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${_+1}Ready = 1;\n                     }\n\n                     xC${_+1} = xTexelC${_+1};\n                     `}}else _<d&&(o%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {\n                   xTexelC${_} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${_}.zw = vec2(0.0);\n                   }\n                   xTexelC${_}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${_+1}Ready == 0) {\n                   xTexelC${_+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${_+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${_+1}Ready = 1;\n                 }\n\n                 xC${_} = vec4(xTexelC${_}.zw, xTexelC${_+1}.zw);\n               `,_+1<d&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${_+1} = vec4(xTexelC${_+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${_}Ready == 0) {\n                   xTexelC${_} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${_}.zw = vec2(0.0);\n                   }\n                   xTexelC${_}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {\n                   xTexelC${_+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${_+1}.zw = vec2(0.);\n                   }\n                   xTexelC${_+1}Ready = 1;\n                 }\n\n                 xC${_} = vec4(\n                   xTexelC${_}.xy, xTexelC${_+1}.xy);\n               `,_+1<d&&(h+=`\n                   xC${_+1} = vec4(xTexelC${_}.zw, xTexelC${_+1}.zw);\n                 `)));_<d&&(h+=`\n             wTexel = getW(r, ${_}, d1, d2);\n             dotProd += xC${_}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${_}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,_+1<d&&(h+=`\n               wTexel = getW(r, ${_+1}, d1, d2);\n               dotProd += xC${_+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${_+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let p="",f="";i&&(p=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${i}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${i}\n         }`:`vec4 activation(vec4 x) {\n           ${i}\n         }`,f="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${f}\n         setOutput(result);\n       }\n     `}}class IBe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=yr(this.outputShape.length);const{dataFormat:i}=e,r=br(),s="channelsLast"===i,o=s?1:2,a=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let d=0;d<=1;d++)for(let u=0;u<=1;u++)c+=`\n          blockIndex = rc.z + ${u};\n          pos = rc.y + ${d};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*d+u}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*d+u}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${r.output} = result;\n      }\n    `}}function ew(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function pq({x:n,filter:t,convInfo:e,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=i.texData.get(n.dataId),d=e.inChannels,u=l[0]*l[1]*l[2],h=e.outChannels,p="channelsLast"===e.dataFormat;let g;const _=[];if(null!=s){const v=ew(s.shape,p);null!=v&&(s=ye({inputs:{x:s},backend:i,attrs:{shape:v}}),_.push(s))}if(null!=r){const v=ew(r.shape,p);null!=v&&(r=ye({inputs:{x:r},backend:i,attrs:{shape:v}}),_.push(r))}if((1!==u&&1!==h||!(d>tq))&&c.isPacked&&p&&null!=c.texture&&l[2]%2!=0&&Ut(c.shape.slice(-3),l.slice(-3))){const x={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},w=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,S(U0(c.shape,x.shape),()=>`packed reshape ${c.shape} to ${x.shape} isn't free`);const C=ye({inputs:{x:t},backend:i,attrs:{shape:[1,e.inChannels,e.outChannels]}});_.push(C);const D=X0({a:x,b:C,backend:i,transposeA:!1,transposeB:!1,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),k=i.texData.get(D.dataId);S(k.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=w,k.shape=e.outShape,g=Zr({inputs:{x:D},backend:i}),g.shape=e.outShape,_.push(D)}else{const v=e.outHeight*e.outWidth,x=ye({inputs:{x:n},backend:i,attrs:{shape:p?[e.batchSize,v,e.inChannels]:[e.batchSize,e.inChannels,v]}}),w=ye({inputs:{x:t},backend:i,attrs:{shape:[1,e.inChannels,e.outChannels]}}),C=X0({a:p?x:w,b:p?w:x,transposeA:!p,transposeB:!1,backend:i,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o});g=ye({inputs:{x:C},backend:i,attrs:{shape:e.outShape}}),_.push(x),_.push(w),_.push(C)}for(const v of _)i.disposeIntermediateTensorInfo(v);return g}function fq({x:n,filter:t,convInfo:e,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:d,outWidth:u,outHeight:h,dataFormat:p}=e,f="channelsLast"===p,m=l*c*d,g=h*u,_=[e.batchSize,m,g],v=[];if(null!=s){const L=ew(s.shape,f);null!=L&&(s=ye({inputs:{x:s},backend:i,attrs:{shape:L}}),v.push(s))}if(null!=r){const L=ew(r.shape,f);null!=L&&(r=ye({inputs:{x:r},backend:i,attrs:{shape:L}}),v.push(r))}const x=ye({inputs:{x:t},backend:i,attrs:{shape:[1,m,K(t.shape)/m]}});v.push(x);const w=new IBe(_,e),D=i.runWebGLProgram(w,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),k=ye({inputs:{x:D},backend:i,attrs:{shape:_}});v.push(D),v.push(k);const I=null!=r,A=null!=s,$="leakyrelu"===a,H=a?$g(a,!0):null,W=new X6(f?k.shape:x.shape,f?x.shape:k.shape,f?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],!0,!1,I,H,A,$),z=f?[k,x]:[x,k];if(r&&z.push(r),A&&z.push(s),$){const L=i.makeTensorInfo([],"float32",Ml(o,"float32"));z.push(L),v.push(L)}const M=i.runWebGLProgram(W,z,"float32"),F=ye({inputs:{x:M},backend:i,attrs:{shape:e.outShape}});v.push(M);for(const L of v)i.disposeIntermediateTensorInfo(L);return F}const ABe={kernelName:wv,backendName:"webgl",kernelFunc:function TBe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=i,u=Ha(l),h=Ti(r.shape,s.shape,o,c,a,d,!1,u);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===u&&q().getBool("WEBGL_EXP_CONV")){const m=new hq(h);p=e.runWebGLProgram(m,[r,s],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(q().getBool("WEBGL_CONV_IM2COL"))p=fq({x:r,filter:s,convInfo:h,backend:e});else{const m=new uq(h);p=e.runWebGLProgram(m,[r,s],"float32")}else p=pq({x:r,filter:s,convInfo:h,backend:e});const f=ye({inputs:{x:p},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(p),f}};class MBe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class NBe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,i=t.filterWidth,o="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${o?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${o?1:2}], coords[${o?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${i} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class RBe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class OBe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,i=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${i-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${i}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${i} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const PBe={kernelName:mI,backendName:"webgl",kernelFunc:function FBe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,dy:s}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:d}=i,u=Ha(l),h=Ti(r.shape,d,o,1,a,c,!1,u),p=new MBe(h);return e.runWebGLProgram(p,[r,s],"float32")}},$Be={kernelName:Cv,backendName:"webgl",kernelFunc:function LBe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,filter:s}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:d}=i,u=Ha(c),h=Ti(o,s.shape,a,1,l,d,!1,u),p=new NBe(h);return e.runWebGLProgram(p,[r,s],"float32")}},BBe={kernelName:Dv,backendName:"webgl",kernelFunc:function VBe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s}=t,{strides:o,pad:a,dilations:l}=i,c=Ll(r.shape,s.shape,o,l,a),d=new EBe(c);return e.runWebGLProgram(d,[r,s],"float32")}},UBe={kernelName:gI,backendName:"webgl",kernelFunc:function zBe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,dy:s}=t,{strides:o,pad:a,filterShape:l}=i,c=Ll(r.shape,l,o,1,a),d=new RBe(c);return e.runWebGLProgram(d,[r,s],"float32")}},jBe={kernelName:_I,backendName:"webgl",kernelFunc:function HBe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,filter:s}=t,{pad:o,strides:a,inputShape:l}=i,c=Ll(l,s.shape,a,1,o),d=new OBe(c);return e.runWebGLProgram(d,[r,s],"float32")}},GBe=Rt({opSnippet:Ph+"\n  return cos(x);\n"}),qBe={kernelName:lm,backendName:"webgl",kernelFunc:GBe},YBe=Rt({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),KBe={kernelName:cm,backendName:"webgl",kernelFunc:YBe};class XBe{constructor(t,e,i,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=t,[d]=e,[u,h]=i;this.outputShape=[d,u,h,c];const p="bilinear"===r?1:0,[f,m]=[a-1+".0",l-1+".0"],[g,_,b]=u>1?[""+(a-1)/(u-1),"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[y,v,x]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${_};\n        float width_scale = ${v};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const ZBe={kernelName:yI,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:i}=n,{image:r,boxes:s,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=i,d=new XBe(r.shape,s.shape,a,l,c);return e.runWebGLProgram(d,[r,s,o],"float32")}};var $h=(()=>(function(n){n.Prod="*",n.Sum="+"}($h||($h={})),$h))();class mq{constructor(t,e,i,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=i?this.op===$h.Prod?"1.0":"0.0":`getX(${gq(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",d="";i?(c=r?"end != "+(l-1):"end != 0",d=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${l}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${pn(s)} coords = getOutputCoords();\n        int end = ${_q(s,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${d};\n          ${_q(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${gq(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function gq(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function _q(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function bq(n,t,e,i,r,s){const o=t.shape.length,a=Rn([i],o);let l=t;null!=a&&(l=xr({inputs:{x:t},backend:e,attrs:{perm:a}}));const c=Xn(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${i}`);const d=l.shape[c];let u=Zr({inputs:{x:l},backend:e});for(let h=0;h<=Math.ceil(Math.log2(d))-1;h++){const p=new mq(n,l.shape,!1,s),m=u;u=e.runWebGLProgram(p,[u],u.dtype,[[h]]),e.disposeIntermediateTensorInfo(m)}if(r){const h=new mq(n,l.shape,r,s),p=u;u=e.runWebGLProgram(h,[u],u.dtype),e.disposeIntermediateTensorInfo(p)}if(null!=a){const p=xr({inputs:{x:u},backend:e,attrs:{perm:Vl(a)}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(l),p}return u}const JBe={kernelName:bI,backendName:"webgl",kernelFunc:function QBe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,exclusive:o,reverse:a}=i;return bq($h.Prod,r,e,s,o,a)}},tze={kernelName:Sv,backendName:"webgl",kernelFunc:function eze(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,exclusive:o,reverse:a}=i;return bq($h.Sum,r,e,s,o,a)}},ize={kernelName:vI,backendName:"webgl",kernelFunc:function nze(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,weights:s}=t,{size:o,binaryOutput:a}=i;if(1===r.shape.length){const l=e.readSync(r.dataId),c=e.readSync(s.dataId),d=L6(l,c,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,d)}if(2===r.shape.length){const l=e.bufferSync(r),c=e.bufferSync(s),d=gLe(l,c,o,a);return e.makeTensorInfo(d.shape,s.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class rze{constructor(t,e,i){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=i,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const oze={kernelName:xI,backendName:"webgl",kernelFunc:function sze(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{blockSize:s,dataFormat:o}=i,a=r.shape[0],u=("NHWC"===o?r.shape[1]:r.shape[2])*s,h=("NHWC"===o?r.shape[2]:r.shape[3])*s,p=("NHWC"===o?r.shape[3]:r.shape[1])/(s*s),m=new rze("NHWC"===o?[a,u,h,p]:[a,p,u,h],s,o);return e.runWebGLProgram(m,[r],r.dtype)}};class yq{constructor(t,e=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=yr(this.outputShape.length);const o=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let c="",d="";i&&(c=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`\n          float activation(float x) {\n            ${i}\n          }\n        `,d="result = activation(result);");const u=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${u}\n        ${d}\n        setOutput(result);\n      }\n    `}}class vq{constructor(t,e=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=yr(this.outputShape.length);const o=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,d=t.filterHeight,u=t.filterWidth,h=u;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let _=0;_<u;_++)p+=`\n          vec4 xTexelC${2*_};\n          int xTexelC${2*_}Ready;\n          vec4 xTexelC${2*_+1};\n          int xTexelC${2*_+1}Ready;\n          vec4 xC${_};`;p+=`\n    for (int r = 0; r < ${d}; r++) {\n      `;for(let _=0;_<u;_++)p+=`\n          xTexelC${2*_} = vec4(0.0);\n          xTexelC${2*_}Ready = 0;\n          xTexelC${2*_+1} = vec4(0.0);\n          xTexelC${2*_+1}Ready = 0;\n          xC${_} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let _=0;_<(h+1)/2;_++){const b=2*_;if(p+=`\n          xC = xCCorner + ${b*c};\n          `,1===l){if(b<u&&(a%2==1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n              `,p+=1===c&&b>0?`\n                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                  } else {\n                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xC${b} = xTexelC${b};\n                `,b+1<u)){const y=a%2==0?QE(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${y};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${b+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${b+1}Ready = 1;\n                  }\n                  `,p+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);\n                    } else {\n                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);\n                    }\n                    `:`\n                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);\n                    `):p+=1===y?`\n                    xC${b+1} = xTexelC${b};\n                    `:`\n                    xCOffset = xC + ${y};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${b+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${b+1}Ready = 1;\n                    }\n\n                    xC${b+1} = xTexelC${b+1};\n                    `}}else b<u&&(a%2==1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n              `,b+1<u&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(\n                  xTexelC${b}.xy, xTexelC${b+1}.xy);\n              `,b+1<u&&(p+=`\n                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n                `)));b<u&&(p+=`\n            wTexel = getW(r, ${b}, d1, q);\n            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);\n          `,b+1<u&&(p+=`\n              wTexel = getW(r, ${b+1}, d1, q);\n              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let f="",m="";i&&(f=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,m="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}const lze={kernelName:kv,backendName:"webgl",kernelFunc:function aze(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=i;let d=l;null==d&&(d=[1,1]),S(Ui(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const u=Ti(r.shape,s.shape,o,d,a,c,!0);let h;return h=q().getBool("WEBGL_PACK_DEPTHWISECONV")&&u.strideWidth<=2&&u.outChannels/u.inChannels==1?new vq(u):new yq(u),e.runWebGLProgram(h,[r,s],"float32",[[u.padInfo.top,u.padInfo.left],[u.strideHeight,u.strideWidth],[u.dilationHeight,u.dilationWidth],[u.inHeight,u.inWidth]])}};class cze{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class dze{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,i=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${i} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const hze={kernelName:wI,backendName:"webgl",kernelFunc:function uze(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,dy:s}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:d}=i,u=Ti(r.shape,d,o,a,l,c,!0),h=new cze(u);return e.runWebGLProgram(h,[r,s],"float32")}},fze={kernelName:CI,backendName:"webgl",kernelFunc:function pze(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,filter:s}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:d}=i,u=Ti(d,s.shape,o,a,l,c,!0),h=new dze(u);return e.runWebGLProgram(h,[r,s],"float32")}};class mze{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const _ze={kernelName:"Diag",backendName:"webgl",kernelFunc:function gze(n){const{inputs:t,backend:e}=n,{x:i}=t,r=[...i.shape,...i.shape],s=K(i.shape),o=ye({inputs:{x:i},backend:e,attrs:{shape:[s]}}),a=new mze(s),l=e.runWebGLProgram(a,[o],o.dtype),c=ye({inputs:{x:l},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}};class bze{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:i,padInfo:r,strideHeight:s,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:d}=t,{top:u,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${o});\n      const ivec2 pads = ivec2(${u}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${d};\n\n              if (wIn >= 0 && wIn < ${i}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const vze={kernelName:Ev,backendName:"webgl",kernelFunc:function yze(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s}=t,{strides:o,pad:a,dilations:l}=i,c=ng(r.shape,s.shape,o,a,"NHWC",l);let d;const u=new bze(c);d=e.runWebGLProgram(u,[r,s],"float32");const h=ye({inputs:{x:d},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(d),h}},wze={kernelName:"Einsum",backendName:"webgl",kernelFunc:function xze(n){const{inputs:t,backend:e,attrs:i}=n,{equation:r}=i,s=t,{allDims:o,summedDims:a,idDims:l}=MT(r,s.length);RT(o.length,l,s);const{path:c,steps:d}=OT(a,l),u=d.length;let h=null,p=o.length;const f=[];for(let m=0;m<u;++m){for(const g of d[m]){const{permutationIndices:_,expandDims:b}=NT(p,l[g]);let y;FT(_)?y=s[g]:(y=xr({inputs:{x:s[g]},backend:e,attrs:{perm:_}}),f.push(y));const v=y.shape.slice();for(let x=0;x<b.length;++x)v.splice(b[x],0,1);Ut(y.shape,v)||(y=ye({inputs:{x:y},backend:e,attrs:{shape:v}}),f.push(y)),null===h?h=y:(h=lM({inputs:{a:y,b:h},backend:e}),f.push(h))}m<u-1&&(c[m]>=0&&(h=K0({inputs:{x:h},backend:e,attrs:{axis:c[m]-(o.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},Cze=Rt({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Dze={kernelName:um,backendName:"webgl",kernelFunc:Cze},Eze={kernelName:kI,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:i,y:r}=t,s=q().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Lg("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",i.shape,r.shape):new Fh("return (b >= 1.0) ? a : a * (b + 1.0);",i.shape,r.shape);return e.runWebGLProgram(s,[i,r],i.dtype)}},Ize=ji({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:vLe}),Tze={kernelName:Iv,backendName:"webgl",kernelFunc:Ize},Mze=Rt({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${CT};\n  float a1 = ${DT};\n  float a2 = ${ST};\n  float a3 = ${kT};\n  float a4 = ${ET};\n  float a5 = ${IT};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),Nze={kernelName:hm,backendName:"webgl",kernelFunc:Mze},xq=Rt({opSnippet:Ph+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:xLe,dtype:"float32"}),Oze={kernelName:pm,backendName:"webgl",kernelFunc:xq};function hM(n){const{inputs:t,attrs:e,backend:i}=n,{dim:r}=e,{input:s}=t,o=s.shape.length,a=s.shape.slice();let l=r;return r<0&&(S(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),ye({inputs:{x:s},backend:i,attrs:{shape:a}})}const Fze={kernelName:Tv,backendName:"webgl",kernelFunc:hM},wq="return exp(x) - 1.0;",Pze=Rt({opSnippet:wq,packedOpSnippet:wq,cpuKernelImpl:wLe}),Lze={kernelName:fm,backendName:"webgl",kernelFunc:Pze};class Cq{constructor(t,e,i){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const s=i?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=i?`${r}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Dq(n,t,e){const i=e.texData.get(n.dataId),r=K(n.shape),s=n.shape[n.shape.length-1],a=ye({inputs:{x:n},backend:e,attrs:{shape:[r/s,s]}}),l=a.shape,c=new Cq("real",l,t),d=new Cq("imag",l,t),u=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:l},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(c,u,"float32"),p=e.runWebGLProgram(d,u,"float32"),f=tc({inputs:{real:h,imag:p},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p);const m=ye({inputs:{x:f},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(f),m}const Vze={kernelName:"FFT",backendName:"webgl",kernelFunc:function $ze(n){const{inputs:t,backend:e}=n,{input:i}=t;return Dq(i,!1,e)}};class Bze{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Ug(n){const{backend:t,attrs:e}=n,{shape:i,value:r}=e;let{dtype:s}=e;if(s=s||Zf(r),"string"===s){const o=ii(s,K(i));return o.fill(r),t.makeTensorInfo(i,s,o)}{const o=new Bze(i,r);return t.runWebGLProgram(o,[],s,[[r]])}}const zze={kernelName:II,backendName:"webgl",kernelFunc:Ug};class Uze{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Hze={kernelName:TI,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,i=t,r=new Uze(e.shape);return i.runWebGLProgram(r,[e],e.dtype)}},Sq="return floor(x);",jze=Rt({opSnippet:Sq,packedOpSnippet:Sq,cpuKernelImpl:CLe}),Wze={kernelName:mm,backendName:"webgl",kernelFunc:jze},Gze=ji({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),qze={kernelName:gm,backendName:"webgl",kernelFunc:Gze};class Yze{constructor(t){this.variableNames=["A"];const e=br(),[i,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${i}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Kze{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=br(),[i,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${i}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const Xze={kernelName:e1,backendName:"webgl",kernelFunc:function Zze(n){const{inputs:t,backend:e,attrs:i}=n;let{pixels:r}=t;const{numChannels:s}=i,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[c,l],u=[c,l,s];if(a||o){const m=q().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Vh||m!==pM)&&(pM=m,Vh=document.createElement("canvas").getContext("2d",{willReadFrequently:pM})),Vh.canvas.width=l,Vh.canvas.height=c,Vh.drawImage(r,0,0,l,c),r=Vh.canvas}const h=e.makeTensorInfo(d,"int32");e.texData.get(h.dataId).usage=Xr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),r);const p=q().getBool("WEBGL_PACK")?new Kze(u):new Yze(u),f=e.runWebGLProgram(p,[h],"int32");return e.disposeData(h.dataId),f}};let Vh,pM=q().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const Jze={kernelName:fx,backendName:"webgl",kernelFunc:function Qze(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:d,dilations:u,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=i,m=Ha(d),g=Ti(r.shape,s.shape,l,u,c,h,!1,m);let _;const b=[],y=null!=o,v=null!=a,x="leakyrelu"===p,w=()=>{const D=[r,s],k=(I,A)=>{if("NCHW"===A&&1===I.shape.length&&1!==I.shape[0]){const $=ye({inputs:{x:I},backend:e,attrs:{shape:[I.shape[0],1,1]}});return b.push($),$}return I};if(y&&D.push(k(o,d)),v&&D.push(k(a,d)),x){const I=e.makeTensorInfo([],"float32",Ml(f,"float32"));D.push(I),b.push(I)}return D};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&q().getBool("WEBGL_EXP_CONV")){const D=p?$g(p,!0):null,k=new hq(g,y,D,v,x),I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],A=w();_=e.runWebGLProgram(k,A,"float32",I)}else if(q().getBool("WEBGL_CONV_IM2COL"))_=fq({x:r,filter:s,convInfo:g,backend:e,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const D=p?$g(p,!1):null,k=new uq(g,y,D,v,x),I=w();_=e.runWebGLProgram(k,I,"float32")}else _=pq({x:r,filter:s,convInfo:g,backend:e,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});const C=ye({inputs:{x:_},backend:e,attrs:{shape:g.outShape}});return b.push(_),b.forEach(D=>e.disposeIntermediateTensorInfo(D)),C}},t3e={kernelName:mx,backendName:"webgl",kernelFunc:function e3e(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,filter:s,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dilations:d,dimRoundingMode:u,activation:h,leakyreluAlpha:p}=i,f=[];let m=d;null==m&&(m=[1,1]),S(Ui(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=Ti(r.shape,s.shape,l,m,c,u,!0),_=q().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=h?$g(h,_):null,y=[r,s],v=null!=o,x=null!=a,w="leakyrelu"===h;if(v&&y.push(o),x&&y.push(a),w){const I=e.makeTensorInfo([],"float32",Ml(p,"float32"));y.push(I),f.push(I)}let C;C=_?new vq(g,v,b,x,w):new yq(g,v,b,x,w);const k=e.runWebGLProgram(C,y,"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]]);return f.forEach(I=>e.disposeIntermediateTensorInfo(I)),k}};class n3e{constructor(t,e,i,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=i;const s=pn(i.length);let o="\n    int index;";for(let a=0;a<this.sliceDim;a++)o+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${o}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const r3e={kernelName:OH,backendName:"webgl",kernelFunc:function i3e(n){const{inputs:t,backend:e}=n,{params:i,indices:r}=t,s=r.shape,o=s[s.length-1],a=K(i.shape),[l,c,d,u]=wT(i,r),h=ye({inputs:{x:r},backend:e,attrs:{shape:[c,o]}}),p=ye({inputs:{x:i},backend:e,attrs:{shape:[K(i.shape)/d,d]}});if(e.shouldExecuteOnCPU([i,r])||"string"===i.dtype){const _=e.readSync(r.dataId),b=e.bufferSync(i),y=DLe(_,b,i.dtype,c,o,d,u,i.shape,a);return e.makeTensorInfo(l,i.dtype,y.values)}const f=new n3e(o,u,[c,d],i.shape),m=e.runWebGLProgram(f,[p,h],p.dtype),g=ye({inputs:{x:m},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}};class s3e{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const i=pn(this.rank),r=function o3e(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let r=0;r<n.length;r++)i.push(2===r?"index":`${e[r]}`);return i.join()}(t);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function kq(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,indices:s}=t,{axis:o,batchDims:a}=i,l=yt(o,r.shape)[0];if(q().get("DEBUG")){const b=e.readSync(s.dataId),y=r.shape[l];for(let v=0;v<b.length;++v){const x=b[v];S(x<=y-1&&x>=0,()=>`GatherV2: the index value ${x} is not in [0, ${y-1}]`)}}const c=$T(r,s,l,a),d=K(s.shape),u=[],h=ye({inputs:{x:r},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=ye({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,d/c.batchSize]}});u.push(h),u.push(p);const f=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const b=e.bufferSync(p),y=e.bufferSync(h),v=SLe(y,b,f);return u.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.makeTensorInfo(c.outputShape,v.dtype,v.values)}const m=new s3e(h.shape,f),g=e.runWebGLProgram(m,[h,p],h.dtype);u.push(g);const _=ye({inputs:{x:g},backend:e,attrs:{shape:c.outputShape}});return u.forEach(b=>e.disposeIntermediateTensorInfo(b)),_}const a3e={kernelName:Mv,backendName:"webgl",kernelFunc:kq},l3e=ji({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:kLe,dtype:"bool"}),c3e={kernelName:Nv,backendName:"webgl",kernelFunc:l3e},d3e=ji({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:ELe}),u3e={kernelName:_m,backendName:"webgl",kernelFunc:d3e},p3e={kernelName:AI,backendName:"webgl",kernelFunc:function h3e(n){const{inputs:t,backend:e}=n,{input:i}=t;return Dq(i,!0,e)}},f3e=Rt({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),m3e={kernelName:ym,backendName:"webgl",kernelFunc:f3e},g3e=Rt({opSnippet:"return float(isinf(x));",dtype:"bool"}),_3e={kernelName:vm,backendName:"webgl",kernelFunc:g3e},b3e=Rt({opSnippet:"return float(isnan(x));",dtype:"bool"}),y3e={kernelName:xm,backendName:"webgl",kernelFunc:b3e},v3e=ji({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:ILe,dtype:"bool"}),x3e={kernelName:Ov,backendName:"webgl",kernelFunc:v3e},w3e=ji({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:TLe,dtype:"bool"}),C3e={kernelName:Fv,backendName:"webgl",kernelFunc:w3e},S3e={kernelName:FH,backendName:"webgl",kernelFunc:function D3e(n){const{backend:t,attrs:e}=n,{start:i,stop:r,num:s}=e,o=ALe(i,r,s);return t.makeTensorInfo([o.length],"float32",o)}},E3e=Rt({opSnippet:Ph+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:MLe}),I3e={kernelName:wm,backendName:"webgl",kernelFunc:E3e},A3e=Rt({opSnippet:Ph+"\n  return log(1.0 + x);\n"}),M3e={kernelName:Cm,backendName:"webgl",kernelFunc:A3e},N3e=ji({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),R3e={kernelName:Pv,backendName:"webgl",kernelFunc:N3e},O3e=Rt({opSnippet:"return float(!(x >= 1.0));"}),F3e={kernelName:Lv,backendName:"webgl",kernelFunc:O3e},P3e=ji({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),L3e={kernelName:$v,backendName:"webgl",kernelFunc:P3e};class $3e{constructor(t,e,i,r,s){this.variableNames=["x"],this.outputShape=[];const o=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${i}) + float(${r}) * sum`;l=.5===s?`inversesqrt(${c})`:1===s?`1.0/(${c})`:`exp(log(${c}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class V3e{constructor(t,e,i,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${i}) + float(${r}) * sum`;l=.5===s?`inversesqrt(${c})`:1===s?`1.0/(${c})`:`exp(log(${c}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const B3e={kernelName:Vv,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{depthRadius:s,bias:o,alpha:a,beta:l}=i,c=q().getBool("WEBGL_PACK_NORMALIZATION")?new V3e(r.shape,s,o,a,l):new $3e(r.shape,s,o,a,l);return e.runWebGLProgram(c,[r],r.dtype)}};class z3e{constructor(t,e,i,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=i,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${i});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const U3e={kernelName:NI,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:i}=n,{x:r,y:s,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:d}=i,u=new z3e(r.shape,a,l,c,d);return e.runWebGLProgram(u,[r,s,o],r.dtype)}};function Eq(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{reductionIndices:s,keepDims:o}=i,a=r.shape.length,l=yt(s,r.shape);let c=l;const d=Rn(c,a),u=null!=d,h=e.shouldExecuteOnCPU([r]);let p=r;if(u){if(h){const y=e.texData.get(p.dataId).values,v=new Array(a);for(let C=0;C<v.length;C++)v[C]=r.shape[d[C]];const x=oM(y,r.shape,r.dtype,d,v);p=e.makeTensorInfo(v,r.dtype),e.texData.get(p.dataId).values=x}else p=Y0(r,d,e);c=Xn(c.length,a)}Hi("max",c,a);const[f,m]=Ai(p.shape,c);let _,g=f;if(o&&(g=Kn(f,l)),h){const y=e.texData.get(p.dataId).values,v=NLe(y,K(m),g,r.dtype);_=e.makeTensorInfo(g,r.dtype),e.texData.get(_.dataId).values=v}else _=function H3e(n,t,e,i){const r=K(t),a=ye({inputs:{x:n},attrs:{shape:[K(n.shape)/r,r]},backend:i}),l=wd(a,n.dtype,"max",i),c=ye({inputs:{x:l},attrs:{shape:e},backend:i});return i.disposeIntermediateTensorInfo(a),i.disposeIntermediateTensorInfo(l),c}(p,m,g,e);return u&&e.disposeIntermediateTensorInfo(p),_}const j3e={kernelName:Bv,backendName:"webgl",kernelFunc:Eq},q3e=ji({opSnippet:aM+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Pg+"\n  return result;\n",cpuKernelImpl:RLe}),Y3e={kernelName:Dm,backendName:"webgl",kernelFunc:q3e},X3e={kernelName:zv,backendName:"webgl",kernelFunc:function K3e(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t;Og(r,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i;S(Ui(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=Hs(r.shape,s,o,1,a,l);if(1===d.filterWidth&&1===d.filterHeight&&Ut(d.inShape,d.outShape))return Zr({inputs:{x:r},backend:e});const u=new Vg(d,"max",!1);return e.runWebGLProgram(u,[r],r.dtype)}},Q3e={kernelName:Uv,backendName:"webgl",kernelFunc:function Z3e(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=i,u=Ua(r.shape,s,o,[1,1,1],a,c,l),h=new cM(u,"max",!1);return e.runWebGLProgram(h,[r],r.dtype)}};class J3e{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const s=t.effectiveFilterHeight,o=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${s-1-t.padInfo.top}, ${o-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${s*o-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class eUe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${c-1-t.padInfo.top}, ${d-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*c*d-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${d} +\n                  wR * ${d} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const nUe={kernelName:OI,backendName:"webgl",kernelFunc:function tUe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,input:s}=t,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=i,h=Ua(o.shape,a,l,[1,1,1],c,d),p=new cM(h,"max",!0),f=e.runWebGLProgram(p,[o],o.dtype),m=new eUe(h),g=e.runWebGLProgram(m,[r,f],o.dtype);return e.disposeIntermediateTensorInfo(f),g}},rUe={kernelName:RI,backendName:"webgl",kernelFunc:function iUe(n){const{inputs:t,backend:e,attrs:i}=n,{dy:r,input:s,output:o}=t,a=s;Og([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:u}=i,h=Hs(a.shape,l,c,1,d,u),f=new Vg(h,"max",!0),m=e.runWebGLProgram(f,[a],a.dtype),g=new J3e(h),_=e.runWebGLProgram(g,[r,m],a.dtype);return e.disposeIntermediateTensorInfo(m),_}},oUe={kernelName:PH,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:i}=n,{filterSize:r,strides:s,pad:o,includeBatchInIndex:a}=t,l=e;S(4===i.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${i.shape.length}.`);const c=[1,1];S(Ui(s,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);const d=Hs(i.shape,r,s,c,o),[u,h]=function sUe(n,t,e,i){let r=new Vg(e,"max",!1);const s=i.runWebGLProgram(r,[n],"float32");return r=new Vg(e,"max",!0,!0,t),[s,i.runWebGLProgram(r,[n],"float32")]}(i,a,d,l);return[u,h]}},lUe={kernelName:Hv,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:i}=n,{keepDims:r,axis:s}=t,o=e,a=i.shape.length,l=yt(s,i.shape);let c=l;const d=Rn(c,a),u=null!=d,h=o.shouldExecuteOnCPU([i]),p=[];let f=i;if(u){if(h){const v=o.texData.get(f.dataId).values,x=new Array(a);for(let D=0;D<x.length;D++)x[D]=i.shape[d[D]];const w=oM(v,i.shape,i.dtype,d,x);f=o.makeTensorInfo(x,i.dtype),o.texData.get(f.dataId).values=w}else f=Y0(i,d,o);p.push(f),c=Xn(c.length,a)}Hi("sum",c,a);const[m,g]=Ai(f.shape,c);let _=m;r&&(_=Kn(m,l));const b=function aUe(n,t,e,i){const r=K(t),a=ye({inputs:{x:n},attrs:{shape:[K(n.shape)/r,r]},backend:i}),l=wd(a,"float32","mean",i),c=ye({inputs:{x:l},attrs:{shape:e},backend:i});return i.disposeIntermediateTensorInfo(a),i.disposeIntermediateTensorInfo(l),c}(f,g,_,o);for(const y of p)o.disposeIntermediateTensorInfo(y);return b}},dUe={kernelName:jv,backendName:"webgl",kernelFunc:function cUe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i,a=r.shape.length,l=yt(s,r.shape);let c=l;const d=Rn(c,a);let u=r;null!=d&&(u=xr({inputs:{x:r},backend:e,attrs:{perm:d}}),c=Xn(c.length,r.shape.length)),Hi("min",c,a);const[h,p]=Ai(u.shape,c),m=ye({inputs:{x:u},backend:e,attrs:{shape:[-1,K(p)]}}),g=wd(m,m.dtype,"min",e);let _;return _=ye(o?{inputs:{x:g},backend:e,attrs:{shape:Kn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=d&&e.disposeIntermediateTensorInfo(u),_}},pUe=ji({opSnippet:aM+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Pg+"\n  return result;\n",cpuKernelImpl:OLe}),fUe={kernelName:Sm,backendName:"webgl",kernelFunc:pUe};class mUe{constructor(t,e,i){this.variableNames=["x"],this.outputShape=e.map((d,u)=>d[0]+t[u]+d[1]);const r=t.length,s=pn(r),o=e.map(d=>d[0]).join(","),a=e.map((d,u)=>d[0]+t[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c="reflect"===i?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class gUe{constructor(t,e,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((f,m)=>f[0]+t[m]+f[1]);const r=t.length,s=pn(r),o=e.map(f=>f[0]).join(","),a=e.map((f,m)=>f[0]+t[m]).join(","),l=vr("rc",r),c=vr("source",r),d=`${l[r-1]} < ${this.outputShape[r-1]}`,u=1===r?"source":`vec2(${c.slice(-2).join()})`,h="reflect"===i?0:1;let p="";if(1===r){const f=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;p=`\n        ${s} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${c.join()}), ${u});\n        ${l[r-1]} += 1;\n        if(${d}) {\n          ${f}\n          result[1] = getChannel(getX(${c.join()}), ${u});\n        }\n      `}else{const f=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;p=`\n        ${s} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${c.join()}), ${u});\n        ${l[r-1]} += 1;\n        if(${d}) {\n          ${f}\n          result[1] = getChannel(getX(${c.join()}), ${u});\n        }\n        rc = outputLoc;\n        ${l[r-2]} += 1;\n        if(${l[r-2]} < ${this.outputShape[r-2]}) {\n          ${f}\n          result[2] = getChannel(getX(${c.join()}), ${u});\n          ${l[r-1]} += 1;\n          if(${d}) {\n            ${f}\n            result[3] = getChannel(getX(${c.join()}), ${u});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const _Ue={kernelName:Wv,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:i}=n,{paddings:r,mode:s}=e,o=q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gUe(i.shape,r,s):new mUe(i.shape,r,s);return t.runWebGLProgram(o,[i],i.dtype)}},vUe=ji({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Pg+"\n  return result;\n"}),xUe={kernelName:km,backendName:"webgl",kernelFunc:vUe};class wUe{constructor(t,e,i){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const Iq=ji({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),CUe={kernelName:dm,backendName:"webgl",kernelFunc:Iq},Tq="return a - b;",Aq=ji({opSnippet:Tq,packedOpSnippet:Tq,supportsComplex:!0,cpuKernelImpl:e$e}),DUe={kernelName:Um,backendName:"webgl",kernelFunc:Aq};function Mq(n){const{inputs:t,backend:e,attrs:i}=n,{logits:r}=t,{dim:s}=i,o=yt([s],r.shape),a=Eq({inputs:{x:r},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),l=Kn(a.shape,o),c=ye({inputs:{x:a},backend:e,attrs:{shape:l}}),d=Aq({inputs:{a:r,b:c},backend:e}),u=xq({inputs:{x:d},backend:e}),h=K0({inputs:{x:u},backend:e,attrs:{axis:o,keepDims:!1}}),p=ye({inputs:{x:h},backend:e,attrs:{shape:l}}),f=Iq({inputs:{a:u,b:p},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),f}const SUe={kernelName:cx,backendName:"webgl",kernelFunc:Mq},EUe={kernelName:LH,backendName:"webgl",kernelFunc:function kUe(n){const{inputs:t,backend:e,attrs:i}=n,{logits:r}=t,{numSamples:s,seed:o,normalized:a}=i,l=a?r:Mq({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),u=new wUe(l.shape[0],l.shape[1],s),p=e.runWebGLProgram(u,[l],"int32",[[o]]);return a||e.disposeIntermediateTensorInfo(l),p}},IUe=vs+"\n  return -x;\n",MUe={kernelName:Gv,backendName:"webgl",kernelFunc:function AUe(n){const{inputs:t,backend:e}=n,{x:i}=t;if(e.shouldExecuteOnCPU([i])){const s=e.texData.get(i.dataId),[o,a]=PLe(s.values,i.shape,i.dtype);return e.makeTensorInfo(a,i.dtype,o)}let r;return r=q().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new ec(i.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new da(i.shape,IUe),e.runWebGLProgram(r,[i],i.dtype)}},NUe=dT,OUe={kernelName:FI,backendName:"webgl",kernelFunc:function RUe(n){hs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:i}=n,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=i,c=e.readSync(r.dataId),d=e.readSync(s.dataId),{selectedIndices:u}=NUe(c,d,o,a,l);return e.makeTensorInfo([u.length],"int32",new Int32Array(u))}},FUe=uT,LUe={kernelName:PI,backendName:"webgl",kernelFunc:function PUe(n){hs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:i}=n,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=i,d=e.readSync(r.dataId),u=e.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=FUe(d,u,o,a,l,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}},$Ue=hT,BUe={kernelName:LI,backendName:"webgl",kernelFunc:function VUe(n){hs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:i}=n,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=i,d=e.readSync(r.dataId),u=e.readSync(s.dataId),h=o,p=a,f=l,m=c,{selectedIndices:g,selectedScores:_}=$Ue(d,u,h,p,f,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([_.length],"float32",new Float32Array(_))]}};class zUe{constructor(t,e,i,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${i}),\n                      float(index == coords.y)));\n      }\n    `}}const UUe={kernelName:Kv,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:i}=n,{indices:r}=t,{dtype:s,depth:o,onValue:a,offValue:l}=i,c=K(r.shape),d=new zUe(c,o,a,l),u=ye({inputs:{x:r},backend:e,attrs:{shape:[c]}}),h=e.runWebGLProgram(d,[u],s);e.disposeIntermediateTensorInfo(u);const f=ye({inputs:{x:h},backend:e,attrs:{shape:[...r.shape,o]}});return e.disposeIntermediateTensorInfo(h),f}};function tw(n){const{inputs:t,backend:e}=n,{x:i}=t;if("complex64"===i.dtype){const r=Bg({inputs:{input:i},backend:e}),s=tw({inputs:{x:r},backend:e}),o=J0({inputs:{input:i},backend:e}),a=tw({inputs:{x:o},backend:e}),l=tc({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return Ug({attrs:{shape:i.shape,dtype:i.dtype,value:"string"===i.dtype?"":0},backend:e})}const HUe={kernelName:hx,backendName:"webgl",kernelFunc:tw},jUe={kernelName:Yv,backendName:"webgl",kernelFunc:function Nq(n){const{inputs:t,backend:e}=n,{x:i}=t;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){const r=Bg({inputs:{input:i},backend:e}),s=Nq({inputs:{x:r},backend:e}),o=J0({inputs:{input:i},backend:e}),a=tw({inputs:{x:o},backend:e}),l=tc({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return Ug({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:e})}},GUe={kernelName:Xv,backendName:"webgl",kernelFunc:function WUe(n){const{inputs:t,backend:e,attrs:i}=n,{axis:r}=i;if(1===t.length)return hM({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach(d=>{zs(s,d.shape,"All tensors passed to stack must have matching shapes"),S(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=dq({inputs:t.map(d=>{const u=hM({inputs:{input:d},backend:e,attrs:{dim:r}});return a.push(u),u}),backend:e,attrs:{axis:r}});return a.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}};class qUe{constructor(t,e,i){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,d)=>c[0]+t[d]+c[1]);const r=t.length,s=pn(r),o=e.map(c=>c[0]).join(","),a=e.map((c,d)=>c[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class YUe{constructor(t,e,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((m,g)=>m[0]+t[g]+m[1]);const r=t.length,s=pn(r),o=e.map(m=>m[0]).join(","),a=e.map((m,g)=>m[0]+t[g]).join(","),l=vr("rc",r),c=vr("source",r),d=`${l[r-1]} < ${this.outputShape[r-1]}`,u=1===r?"source":`vec2(${c.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${l[r-1]} += 1;\n       if(${d}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${l[r-2]} += 1;\n       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${l[r-1]} += 1;\n         if(${d}) {`],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=1===r?2:4;m<g;m++)f+=`\n        ${h[m]}\n        if (${p}) {\n          result[${m}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${m}] = getChannel(getX(${c.join()}), ${u});\n        }\n      `;f+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const Rq=n=>{const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{paddings:s,constantValue:o}=i;if(0===K(r.shape))return Ug({backend:e,attrs:{shape:s.map((d,u)=>d[0]+r.shape[u]+d[1]),value:o,dtype:r.dtype}});const a=q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new YUe(r.shape,s,o):new qUe(r.shape,s,o);return e.runWebGLProgram(a,[r],r.dtype,[[o]])},KUe={kernelName:Zv,backendName:"webgl",kernelFunc:Rq},QUe=ji({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Pg+"\n  return result;\n"}),JUe={kernelName:Im,backendName:"webgl",kernelFunc:QUe},tHe={kernelName:Jv,backendName:"webgl",kernelFunc:function eHe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{axis:s,keepDims:o}=i,a=r.shape.length,l=[],c=yt(s,r.shape);let d=c;const u=Rn(d,a);let p,h=r;if(null!=u&&(h=xr({inputs:{x:r},backend:e,attrs:{perm:u}}),d=Xn(d.length,a),l.push(h)),Hi("prod",d,a),e.shouldExecuteOnCPU([h])){const f=e.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:_}=$Le(h.shape,h.dtype,f,d);p=e.makeTensorInfo(g,_,m)}else{const[f,m]=Ai(h.shape,d),g=K(m),_=ye({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}}),y=wd(_,c1(r.dtype),"prod",e);p=ye({inputs:{x:y},backend:e,attrs:{shape:f}}),l.push(_),l.push(y)}if(o){l.push(p);const f=Kn(p.shape,c);p=ye({inputs:{x:p},backend:e,attrs:{shape:f}})}return l.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}},iHe={kernelName:$H,backendName:"webgl",kernelFunc:function nHe(n){const{inputs:t,backend:e,attrs:i}=n,{paramsNestedSplits:r,paramsDenseValues:s,indices:o}=t,{outputRaggedRank:a}=i,l=r.map(_=>e.readSync(_.dataId)),c=r.map(_=>_.shape),d=e.readSync(s.dataId),u=e.readSync(o.dataId),[h,p,f]=VLe(l,c,d,s.shape,s.dtype,u,o.shape,a),m=h.map(_=>e.makeTensorInfo([_.length],"int32",_)),g=e.makeTensorInfo(f,s.dtype,p);return m.concat([g])}},sHe={kernelName:VH,backendName:"webgl",kernelFunc:function rHe(n){const{inputs:t,backend:e}=n,{starts:i,limits:r,deltas:s}=t,o=e.readSync(i.dataId),a=e.readSync(r.dataId),l=e.readSync(s.dataId),[c,d]=BLe(o,i.shape,i.dtype,a,r.shape,l,s.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([d.length],i.dtype,d)]}},aHe={kernelName:BH,backendName:"webgl",kernelFunc:function oHe(n){const{inputs:t,backend:e,attrs:i}=n,{shape:r,values:s,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=i,c=e.readSync(r.dataId),d=e.readSync(s.dataId),u=e.readSync(o.dataId),h=a.map(g=>e.readSync(g.dataId)),p=a.map(g=>g.shape),[f,m]=zLe(c,r.shape,d,s.shape,s.dtype,u,o.shape,h,p,l);return e.makeTensorInfo(f,s.dtype,m)}},Oq=n=>{const{backend:t,attrs:e}=n,{start:i,stop:r,step:s,dtype:o}=e,a=ULe(i,r,s,o);return t.makeTensorInfo([a.length],o,a)},lHe={kernelName:$I,backendName:"webgl",kernelFunc:Oq},cHe=Rt({opSnippet:"return 1.0 / x;"}),dHe={kernelName:Tm,backendName:"webgl",kernelFunc:cHe},hHe=Rt({opSnippet:vs+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),pHe={kernelName:Am,backendName:"webgl",kernelFunc:hHe},mHe=Rt({opSnippet:vs+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),gHe={kernelName:Mm,backendName:"webgl",kernelFunc:mHe};class _He{constructor(t,e,i,r,s){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,i,c];const d=[r&&e>1?a-1:a,r&&i>1?l-1:l],u=[r&&e>1?e-1:e,r&&i>1?i-1:i];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/u[0]},\n          ${d[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class bHe{constructor(t,e,i,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,i,c];const d=[r&&e>1?a-1:a,r&&i>1?l-1:l],u=[r&&e>1?e-1:e,r&&i>1?i-1:i];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/u[0]},\n          ${d[1]/u[1]},\n          ${d[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${i-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const vHe={kernelName:nx,backendName:"webgl",kernelFunc:function yHe(n){const{inputs:t,backend:e,attrs:i}=n,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,c]=a,d=q().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new bHe(r.shape,l,c,s,o):new _He(r.shape,l,c,s,o);return e.runWebGLProgram(d,[r],"float32")}};class xHe{constructor(t,e,i){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,s]=e,[,o,a]=t,l=[i&&o>1?r-1:r,i&&a>1?s-1:s],c=[i&&o>1?o-1:o,i&&a>1?a-1:a],d=l[0]/c[0],u=l[1]/c[1],h=1/d,p=1/u,f=2*Math.ceil(h)+2,m=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${d});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const CHe={kernelName:zI,backendName:"webgl",kernelFunc:function wHe(n){const{inputs:t,backend:e,attrs:i}=n,{images:r,dy:s}=t,{alignCorners:o}=i,a=new xHe(s.shape,r.shape,o);return e.runWebGLProgram(a,[s],s.dtype)}};class DHe{constructor(t,e,i,r,s){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,i,c];const d=[r&&e>1?a-1:a,r&&i>1?l-1:l],u=[r&&e>1?e-1:e,r&&i>1?i-1:i];let p;p=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/u[0]},\n          ${d[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class SHe{constructor(t,e,i,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,i,c];const d=[r&&e>1?a-1:a,r&&i>1?l-1:l],u=[r&&e>1?e-1:e,r&&i>1?i-1:i];let p;p=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/u[0]},\n          ${d[1]/u[1]},\n          ${d[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${i-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const EHe={kernelName:tx,backendName:"webgl",kernelFunc:function kHe(n){const{inputs:t,backend:e,attrs:i}=n,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,c]=a,d=q().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new SHe(r.shape,l,c,s,o):new DHe(r.shape,l,c,s,o);return e.runWebGLProgram(d,[r],r.dtype)}};class IHe{constructor(t,e,i){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,s]=e,[,o,a]=t,l=[i&&o>1?r-1:r,i&&a>1?s-1:s],c=[i&&o>1?o-1:o,i&&a>1?a-1:a],d=l[0]/c[0],u=l[1]/c[1],h=1/d,p=1/u,f=2*Math.ceil(h)+2,m=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${d});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${i} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${i} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const AHe={kernelName:BI,backendName:"webgl",kernelFunc:function THe(n){const{inputs:t,backend:e,attrs:i}=n,{images:r,dy:s}=t,{alignCorners:o}=i,a=new IHe(s.shape,r.shape,o);return e.runWebGLProgram(a,[s],s.dtype)}};class MHe{constructor(t,e){this.variableNames=["x"];const i=t.length;if(i>4)throw new Error(`WebGL backend: Reverse of rank-${i} tensor is not yet supported`);if(this.outputShape=t,1===i)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const s=t.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),o=pn(i);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class NHe{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const i=t.length;if(i>4)throw new Error(`WebGL backend: Reverse of rank-${i} tensor is not yet supported`);this.outputShape=t;const r=vr("rc",i),s=`${r[i-1]} + 1 < ${this.outputShape[i-1]}`,o=`${r[i-2]} + 1 < ${this.outputShape[i-2]}`,a=pn(i);function h(f){const m=t.map((b,y)=>function p(f,m){return-1!==e.indexOf(f)&&1!==t[f]?`${t[f]} - ${m[f]} - 1`:`${m[f]}`}(y,f));return`getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`}this.userCode=1===i?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(f){return h(f)}(r.slice())};\n          if(${s}){\n            result.g = ${function c(f){return f[i-1]="("+f[i-1]+" + 1)",h(f)}(r.slice())};\n          }\n          if(${o}) {\n            result.b = ${function d(f){return f[i-2]="("+f[i-2]+" + 1)",h(f)}(r.slice())};\n            if(${s}) {\n              result.a = ${function u(f){return f[i-1]="("+f[i-1]+" + 1)",f[i-2]="("+f[i-2]+" + 1)",h(f)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const OHe={kernelName:ix,backendName:"webgl",kernelFunc:function RHe(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{dims:s}=i,o=r.shape.length,a=yt(s,r.shape);if(0===o)return Zr({inputs:{x:r},backend:e});const l=q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NHe(r.shape,a):new MHe(r.shape,a);return e.runWebGLProgram(l,[r],r.dtype)}};class FHe{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const i=t[1],r=t[2];this.outputShape=t;let s="";s="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${i}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const PHe={kernelName:t1,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:i}=n,{radians:r,fillValue:s,center:o}=t,a=e,l=new FHe(i.shape,s),[c,d]=yT(o,i.shape[1],i.shape[2]),u=[[c,d,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[i],i.dtype,u)}},LHe=Rt({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),$He={kernelName:Nm,backendName:"webgl",kernelFunc:LHe},VHe=Rt({opSnippet:"return inversesqrt(x);",cpuKernelImpl:HLe}),BHe={kernelName:Rm,backendName:"webgl",kernelFunc:VHe};class Fq{constructor(t,e,i,r,s,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=pn(s.length),c=pn(o.length);let d="";1===i?d="i":2===i&&(d="i, j");let h="";1===r?h="i":2===r&&(h="i, coords[1]"),this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${d}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${h});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const UHe={kernelName:zH,backendName:"webgl",kernelFunc:function zHe(n){const{inputs:t,backend:e,attrs:i}=n,{indices:r,updates:s}=t,{shape:o}=i,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:u}=mg(0,r,o),h=[u/c,c];if(0===u)return e.makeTensorInfo(o,r.dtype);const p=ye({inputs:{x:r},backend:e,attrs:{shape:[l,a]}}),f=ye({inputs:{x:s},backend:e,attrs:{shape:[l,c]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new Fq(l,a,p.shape.length,f.shape.length,d,h),_=e.runWebGLProgram(g,[f,p,m],f.dtype),b=ye({inputs:{x:_},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(m),b}};class HHe{constructor(t,e,i,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,i];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===q().getNumber("WEBGL_VERSION")?"while (left < right) {":o;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===r?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const WHe={kernelName:UH,backendName:"webgl",kernelFunc:function jHe(n){const{inputs:t,backend:e,attrs:i}=n,{sortedSequence:r,values:s}=t,{side:o}=i,a=new HHe(r.shape[0],r.shape[1],s.shape[1],o);return e.runWebGLProgram(a,[r,s],"int32",[[r.shape[1]]])}};class GHe{constructor(t,e,i){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=e,i>4)throw Error(`Where for rank ${i} is not yet supported`);if(1===i)s="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let d=0;d<e.length;d++)c.push(`${a[d]}`),d<t&&l.push(`${a[d]}`);r=l.join(),s=c.join()}const o=pn(i);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const YHe={kernelName:rx,backendName:"webgl",kernelFunc:function qHe(n){const{inputs:t,backend:e}=n,{condition:i,t:r,e:s}=t,o=new GHe(i.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(o,[i,r,s],Gr(r.dtype,s.dtype))}},XHe=Rt({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Gx};\n  float scale = ${qx};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),ZHe={kernelName:Om,backendName:"webgl",kernelFunc:XHe},JHe=Rt({opSnippet:Ph+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:WLe}),e4e={kernelName:$m,backendName:"webgl",kernelFunc:JHe},t4e=Rt({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),n4e={kernelName:Lm,backendName:"webgl",kernelFunc:t4e},r4e=Rt({opSnippet:Ph+"\n  return sin(x);\n"}),s4e={kernelName:Fm,backendName:"webgl",kernelFunc:r4e},o4e=Rt({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),a4e={kernelName:Pm,backendName:"webgl",kernelFunc:o4e},l4e=Rt({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),c4e={kernelName:Vm,backendName:"webgl",kernelFunc:l4e},d4e={kernelName:ax,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{blockShape:s,paddings:o}=i;S(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((_,b)=>_*b),l=[[0,0]];l.push(...o);for(let _=1+s.length;_<r.shape.length;++_)l.push([0,0]);const c=[],d=Rq({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),u=hg(d.shape,s,a,!1),h=pg(u.length,s.length,!1),p=fg(d.shape,s,a,!1),f=ye({inputs:{x:d},backend:e,attrs:{shape:u}}),m=xr({inputs:{x:f},backend:e,attrs:{perm:h}}),g=ye({inputs:{x:m},backend:e,attrs:{shape:p}});return c.push(d),c.push(f),c.push(m),c.forEach(_=>e.disposeIntermediateTensorInfo(_)),g}},h4e={kernelName:UI,backendName:"webgl",kernelFunc:function u4e(n){const{inputs:t,backend:e}=n,{indices:i,values:r,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==i.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${i.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.readSync(i.dataId),l=e.readSync(r.dataId),c=e.readSync(s.dataId),d=e.readSync(o.dataId)[0],[u,h,p,f,m]=qLe(a,i.shape,i.dtype,l,r.dtype,c,d);return[e.makeTensorInfo(h,i.dtype,u),e.makeTensorInfo([h[0]],r.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),e.makeTensorInfo([m.length],i.dtype,new Int32Array(m))]}},f4e={kernelName:HI,backendName:"webgl",kernelFunc:function p4e(n){const{inputs:t,backend:e}=n,{inputIndices:i,inputShape:r,newShape:s}=t;if(2!==i.shape.length)throw new Error(`Input indices should be a matrix but received shape ${i.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(e.readSync(r.dataId)),a=e.readSync(i.dataId),l=Array.from(e.readSync(s.dataId)),[c,d,u]=YLe(a,i.shape,i.dtype,o,l);return[e.makeTensorInfo(d,i.dtype,c),e.makeTensorInfo([u.length],s.dtype,new Int32Array(u))]}},g4e={kernelName:jI,backendName:"webgl",kernelFunc:function m4e(n){const{inputs:t,backend:e}=n,{data:i,indices:r,segmentIds:s}=t;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const o=e.readSync(i.dataId),a=e.readSync(r.dataId),l=e.readSync(s.dataId),[c,d]=V6(o,i.shape,i.dtype,a,l,!0);return e.makeTensorInfo(d,i.dtype,c)}},b4e={kernelName:WI,backendName:"webgl",kernelFunc:function _4e(n){const{inputs:t,backend:e}=n,{data:i,indices:r,segmentIds:s}=t;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const o=e.readSync(i.dataId),a=e.readSync(r.dataId),l=e.readSync(s.dataId),[c,d]=V6(o,i.shape,i.dtype,a,l);return e.makeTensorInfo(d,i.dtype,c)}},v4e={kernelName:HH,backendName:"webgl",kernelFunc:function y4e(n){const{inputs:t,backend:e,attrs:i}=n,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:a}=i,{sliceRank:l,numUpdates:c,sliceSize:d,strides:u,outputSize:h}=mg(0,r,a);if("string"===s.dtype){const _=e.bufferSync(r),b=e.bufferSync(s),y=Rl(e.readSync(o.dataId)[0]),v=jLe(_,b,a,h,d,c,l,u,y,!1);return e.makeTensorInfo(a,v.dtype,v.values)}const f=new Fq(c,l,r.shape.length,s.shape.length,u,[h,1],!1),m=e.runWebGLProgram(f,[s,r,o],s.dtype),g=ye({inputs:{x:m},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(m),g}},w4e={kernelName:lx,backendName:"webgl",kernelFunc:function x4e(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{numOrSizeSplits:s,axis:o}=i,a=yt(o,r.shape)[0],l=PT(r,s,a),d=new Array(r.shape.length).fill(0),u=r.shape.slice();return l.map(h=>{const p=[...u];p[a]=h;const f=Lh({inputs:{x:r},backend:e,attrs:{begin:d,size:p}});return d[a]+=h,f})}},Pq="return sqrt(x);",C4e=Rt({opSnippet:Pq,packedOpSnippet:Pq,cpuKernelImpl:KLe}),D4e={kernelName:Bm,backendName:"webgl",kernelFunc:C4e},k4e={kernelName:GI,backendName:"webgl",kernelFunc:Rt({opSnippet:"return x * x;"})},Lq="return (a - b) * (a - b);",E4e=ji({opSnippet:Lq,packedOpSnippet:Lq}),I4e={kernelName:zm,backendName:"webgl",kernelFunc:E4e},A4e={kernelName:Gm,backendName:"webgl",kernelFunc:function T4e({inputs:n,attrs:t,backend:e}){const{x:i}=n,s=new da(i.shape,vs+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(s,[i],i.dtype)}};class M4e{constructor(t,e,i){this.variableNames=["x"],this.outputShape=i;const r=i.length,s=pn(i.length),o=pn(i.length);let a="";if(1===r)a="coords * strides + begin";else{let l=0;a=i.map((c,d)=>(l++,1===i.length?`coords * strides[${d}] + begin[${d}]`:`coords[${l-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${t});\n      ${s} strides = ${s}(${e});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const R4e={kernelName:qI,backendName:"webgl",kernelFunc:function N4e(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{begin:s,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:u,shrinkAxisMask:h}=i,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:_,begin:b,end:y,strides:v}=V1(r.shape,s,o,a,l,c,d,u,h);let x;if(m)x=ye({inputs:{x:r},backend:e,attrs:{shape:f}});else if(g||_){S(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const C=P1(b,y,v),D=Lh({inputs:{x:r},backend:e,attrs:{begin:b,size:C}});x=ye({inputs:{x:D},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(D)}else if(e.shouldExecuteOnCPU([r])){const D=e.readSync(r.dataId),k=vt(r.shape,r.dtype,D),I=XLe(p,k,v,b);x=e.makeTensorInfo(f,r.dtype,I.values)}else{const D=new M4e(b,v,p);x=e.runWebGLProgram(D,[r],r.dtype)}const w=ye({inputs:{x},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(x),w}},F4e={kernelName:YI,backendName:"webgl",kernelFunc:function O4e(n){const{inputs:t,backend:e,attrs:i}=n,{separator:r,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=i,{data:d,dataSplits:u}=t,h=e.readSync(d.dataId),p=e.readSync(u.dataId),[f,m]=ZLe(h,p,r,s,o,a,l,c);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(u.shape,"int32",m)]}},L4e={kernelName:KI,backendName:"webgl",kernelFunc:function P4e(n){const{inputs:t,backend:e,attrs:i}=n,{skipEmpty:r}=i,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(s.dataId),l=e.readSync(o.dataId)[0],[c,d,u]=QLe(a,l,r),h=d.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(u))]}},V4e={kernelName:XI,backendName:"webgl",kernelFunc:function $4e(n){const{inputs:t,backend:e,attrs:i}=n,{numBuckets:r}=i,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(s.dataId),a=JLe(o,r);return e.makeTensorInfo(s.shape,"int32",a)}},B4e=Rt({opSnippet:"return tan(x);"}),z4e={kernelName:Hm,backendName:"webgl",kernelFunc:B4e},U4e=Rt({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),H4e={kernelName:jm,backendName:"webgl",kernelFunc:U4e};class j4e{constructor(t,e){this.variableNames=["A"];const i=new Array(t.length);for(let o=0;o<i.length;o++)i[o]=t[o]*e[o];this.outputShape=i,this.rank=i.length;const r=pn(this.rank),s=function W4e(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],i=[];for(let r=0;r<n.length;r++)i.push(`imod(${e[r]}, ${n[r]})`);return i.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function $q(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{reps:s}=i;if("string"===r.dtype||r.shape.length>5){const l=e.readSync(r.dataId),c="string"===r.dtype?l.map(h=>Rl(h)):l,d=vt(r.shape,r.dtype,c),u=t$e(d,s);return e.makeTensorInfo(u.shape,u.dtype,u.values)}const o=new j4e(r.shape,s);return e.runWebGLProgram(o,[r],r.dtype)}const G4e={kernelName:Wm,backendName:"webgl",kernelFunc:$q};class q4e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Y4e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Cd(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function Vq(n){let t=1;for(;t<n;)t*=2;return t}const X4e={kernelName:ZI,backendName:"webgl",kernelFunc:function K4e(n){const{inputs:t,backend:e,attrs:i}=n,{x:r}=t,{k:s,sorted:o}=i,a=q().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=q().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,d=c[c.length-1];if(e.shouldExecuteOnCPU([r])||d<a||s>l){const I=e.readSync(r.dataId),[A,$]=n$e(I,c,r.dtype,s,o);return[e.makeTensorInfo(A.shape,A.dtype,A.values),e.makeTensorInfo($.shape,$.dtype,$.values)]}if(0===s)return c[c.length-1]=0,[e.makeTensorInfo(c,r.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===d)return[r,Ug({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const u=e.texData.get(r.dataId),h=null!==u&&u.isPacked,p=h?e.unpackTensor(r):r,m=K(c)/d,g=ye({inputs:{x:p},attrs:{shape:[m,d]},backend:e});h&&Cd(e,p);const _=Vq(s),b=Vq(d);let y=null;const v=()=>null===y?[g,g]:[g,y],x=(I,A,$)=>{const H=v(),W=new q4e($),F=y;y=e.runWebGLProgram(W,H,"int32",[[d],[null===y?1:0],[Number.NEGATIVE_INFINITY],[I],[A]]),Cd(e,F)};for(let I=1;I<_;I*=2){const A=2*I;for(let $=I;$>=1;$/=2)x(A,$,[m,b])}for(let I=b;I>_;I/=2){const A=v(),$=new Y4e([m,I/2]),z=y;y=e.runWebGLProgram($,A,"int32",[[d],[null===y?1:0],[_]]),Cd(e,z);const M=_/2,F=2*M;for(let L=M;L>=1;L/=2)x(F,L,y.shape)}let w=y;y=Lh({inputs:{x:y},backend:e,attrs:{begin:0,size:[m,s]}}),Cd(e,w);let C=kq({inputs:{x:g,indices:y},backend:e,attrs:{axis:1,batchDims:1}});Cd(e,g);const D=c.slice(0,-1);D.push(s),w=y,y=ye({inputs:{x:y},attrs:{shape:D},backend:e}),Cd(e,w);const k=C;return C=ye({inputs:{x:C},attrs:{shape:D},backend:e}),Cd(e,k),[C,y]}};class Z4e{constructor(t,e,i,r,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a="nearest"===i?1:2;let l;switch(r){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const J4e={kernelName:QI,backendName:"webgl",kernelFunc:function Q4e(n){const{inputs:t,backend:e,attrs:i}=n,{image:r,transforms:s}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=i,[d,u,h,p]=r.shape,[f,m]=c??[u,h],_=new Z4e(u,h,o,a,l,[d,f,m,p]);return e.runWebGLProgram(_,[r,s],"float32")}},tje={kernelName:JI,backendName:"webgl",kernelFunc:function eje(n){const{inputs:t,attrs:e,backend:i}=n,{axis:r}=e,{x:s}=t;Og(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=i.readSync(s.dataId),{outputValues:a,outputShape:l,indices:c}=i$e(o,r,s.shape,s.dtype);return[i.makeTensorInfo(l,s.dtype,a),i.makeTensorInfo([c.length],"int32",c)]}},ije={kernelName:dx,backendName:"webgl",kernelFunc:function nje(n){const{inputs:t,backend:e,attrs:i}=n,{value:r}=t;let{axis:s}=i;s<0&&(s+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[s],c=new Array(a-1);let d=0;for(let m=0;m<a;m++)m!==s&&(c[d++]=o.shape[m]);const u=[],h=new Array(a).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(l);for(let m=0;m<f.length;m++){h[s]=m;const g=Lh({inputs:{x:o},backend:e,attrs:{begin:h,size:p}}),_=ye({inputs:{x:g},backend:e,attrs:{shape:c}});f[m]=_,u.push(g)}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}};class rje{constructor(t,e){this.variableNames=["x","segmentIds"];const i=t.windowSize,r=t.batchSize,s=t.inSize,o=t.numSegments,a=o*Math.ceil(s/i);this.outputShape=[r,a];const d=4*Math.floor(i/4),u=i%4,h="\n        sumValue += dot(values, segFilter);\n    ";let p="";s%i>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let f="";s%i>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${f}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${i}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const oje={kernelName:ux,backendName:"webgl",kernelFunc:function sje(n){const{inputs:t,backend:e,attrs:i}=n,{x:r,segmentIds:s}=t,{numSegments:o}=i,a=r.shape.length,l=[];let c=0;const d=Rn([c],a);let u=r;null!=d&&(u=xr({inputs:{x:r},backend:e,attrs:{perm:d}}),l.push(u),c=Xn(1,a)[0]);const h=Yj(u.shape,c,o),p=K([u.shape[c]]),f=ye({inputs:{x:u},backend:e,attrs:{shape:[-1,p]}});l.push(f);const m=c1(r.dtype),g=(v,x,w,C,D)=>{const k=v.shape[0],I=v.shape[1],A=qj(I,D),H=new rje({windowSize:A,inSize:I,batchSize:k,numSegments:D},x),W=e.compileAndRun(H,[v,w],C);if(l.push(W),W.shape[1]===D)return W;const z=Oq({backend:e,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),M=$q({inputs:{x:z},backend:e,attrs:{reps:[I/A]}});return l.push(z),l.push(M),g(W,x,M,C,D)},b=ye({inputs:{x:g(f,"unsortedSegmentSum",s,m,o)},backend:e,attrs:{shape:h}});let y=b;if(null!=d){l.push(b);const v=Vl(d);y=xr({inputs:{x:y},backend:e,attrs:{perm:v}})}return l.forEach(v=>e.disposeIntermediateTensorInfo(v)),y}},aje=[Z$e,J$e,nVe,sVe,aVe,dVe,hVe,fVe,bVe,vVe,CVe,kVe,TVe,RVe,PVe,$Ve,BVe,jVe,GVe,YVe,ZVe,iBe,sBe,aBe,hBe,fBe,bBe,O$e,xBe,kBe,ABe,PBe,$Be,BBe,UBe,jBe,qBe,KBe,ZBe,JBe,tze,ize,oze,lze,hze,fze,_ze,vze,wze,Dze,Eze,Tze,Nze,Oze,Fze,Lze,Vze,zze,Hze,Wze,qze,Xze,Jze,t3e,r3e,a3e,c3e,u3e,R$e,p3e,DBe,m3e,_3e,y3e,P$e,x3e,C3e,S3e,I3e,M3e,R3e,F3e,L3e,B3e,U3e,j3e,Y3e,X3e,Q3e,nUe,rUe,oUe,lUe,dUe,fUe,_Ue,xUe,EUe,V$e,MUe,OUe,LUe,BUe,lBe,UUe,jUe,GUe,KUe,JUe,$$e,tHe,iHe,sHe,aHe,lHe,cBe,CUe,dHe,pHe,gHe,z$e,vHe,CHe,EHe,AHe,OHe,PHe,$He,BHe,UHe,WHe,YHe,ZHe,e4e,n4e,s4e,a4e,nBe,SUe,c4e,d4e,h4e,f4e,g4e,b4e,v4e,w4e,D4e,k4e,I4e,A4e,R4e,F4e,L4e,V4e,DUe,Y$e,z4e,H4e,G4e,X4e,J4e,K$e,tje,ije,oje,HUe];for(const n of aje)s1(n);const cje=["*"],hje=[[["","mat-card-avatar",""],["","matCardAvatar",""]],[["mat-card-title"],["mat-card-subtitle"],["","mat-card-title",""],["","mat-card-subtitle",""],["","matCardTitle",""],["","matCardSubtitle",""]],"*"],pje=["[mat-card-avatar], [matCardAvatar]","mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]","*"],fje=new ne("MAT_CARD_CONFIG");let fM=(()=>{class n{constructor(e){this.appearance=e?.appearance||"raised"}}return n.\u0275fac=function(e){return new(e||n)(V(fje,8))},n.\u0275cmp=bi({type:n,selectors:[["mat-card"]],hostAttrs:[1,"mat-mdc-card","mdc-card"],hostVars:4,hostBindings:function(e,i){2&e&&ar("mat-mdc-card-outlined","outlined"===i.appearance)("mdc-card--outlined","outlined"===i.appearance)},inputs:{appearance:"appearance"},exportAs:["matCard"],ngContentSelectors:cje,decls:1,vars:0,template:function(e,i){1&e&&(rl(),Vi(0))},styles:['.mdc-card{display:flex;flex-direction:column;box-sizing:border-box}.mdc-card::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none;pointer-events:none}@media screen and (forced-colors: active){.mdc-card::after{border-color:CanvasText}}.mdc-card--outlined::after{border:none}.mdc-card__content{border-radius:inherit;height:100%}.mdc-card__media{position:relative;box-sizing:border-box;background-repeat:no-repeat;background-position:center;background-size:cover}.mdc-card__media::before{display:block;content:""}.mdc-card__media:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.mdc-card__media:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.mdc-card__media--square::before{margin-top:100%}.mdc-card__media--16-9::before{margin-top:56.25%}.mdc-card__media-content{position:absolute;top:0;right:0;bottom:0;left:0;box-sizing:border-box}.mdc-card__primary-action{display:flex;flex-direction:column;box-sizing:border-box;position:relative;outline:none;color:inherit;text-decoration:none;cursor:pointer;overflow:hidden}.mdc-card__primary-action:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.mdc-card__primary-action:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.mdc-card__actions{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;min-height:52px;padding:8px}.mdc-card__actions--full-bleed{padding:0}.mdc-card__action-buttons,.mdc-card__action-icons{display:flex;flex-direction:row;align-items:center;box-sizing:border-box}.mdc-card__action-icons{flex-grow:1;justify-content:flex-end}.mdc-card__action-buttons+.mdc-card__action-icons{margin-left:16px;margin-right:0}[dir=rtl] .mdc-card__action-buttons+.mdc-card__action-icons,.mdc-card__action-buttons+.mdc-card__action-icons[dir=rtl]{margin-left:0;margin-right:16px}.mdc-card__action{display:inline-flex;flex-direction:row;align-items:center;box-sizing:border-box;justify-content:center;cursor:pointer;user-select:none}.mdc-card__action:focus{outline:none}.mdc-card__action--button{margin-left:0;margin-right:8px;padding:0 8px}[dir=rtl] .mdc-card__action--button,.mdc-card__action--button[dir=rtl]{margin-left:8px;margin-right:0}.mdc-card__action--button:last-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-card__action--button:last-child,.mdc-card__action--button:last-child[dir=rtl]{margin-left:0;margin-right:0}.mdc-card__actions--full-bleed .mdc-card__action--button{justify-content:space-between;width:100%;height:auto;max-height:none;margin:0;padding:8px 16px;text-align:left}[dir=rtl] .mdc-card__actions--full-bleed .mdc-card__action--button,.mdc-card__actions--full-bleed .mdc-card__action--button[dir=rtl]{text-align:right}.mdc-card__action--icon{margin:-6px 0;padding:12px}.mat-mdc-card{position:relative;border-radius:var(--mdc-elevated-card-container-shape, var(--mdc-shape-medium, 4px));background-color:var(--mdc-elevated-card-container-color, transparent);border-width:0;border-style:solid;border-color:var(--mdc-elevated-card-container-color, transparent)}.mat-mdc-card .mdc-card::after{border-radius:var(--mdc-elevated-card-container-shape, var(--mdc-shape-medium, 4px))}.mat-mdc-card-outlined{border-width:var(--mdc-outlined-card-outline-width, 1px);border-style:solid;border-color:var(--mdc-outlined-card-outline-color, transparent)}.mat-mdc-card-title,.mat-mdc-card-subtitle{display:block;margin:0}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle{padding:16px 16px 0}.mat-mdc-card-header{display:flex;padding:16px 16px 0}.mat-mdc-card-content{display:block;padding:0 16px}.mat-mdc-card-content:first-child{padding-top:16px}.mat-mdc-card-content:last-child{padding-bottom:16px}.mat-mdc-card-title-group{display:flex;justify-content:space-between;width:100%}.mat-mdc-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;margin-bottom:16px;object-fit:cover}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title{line-height:normal}.mat-mdc-card-sm-image{width:80px;height:80px}.mat-mdc-card-md-image{width:112px;height:112px}.mat-mdc-card-lg-image{width:152px;height:152px}.mat-mdc-card-xl-image{width:240px;height:240px}.mat-mdc-card-subtitle~.mat-mdc-card-title,.mat-mdc-card-title~.mat-mdc-card-subtitle,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-title-group .mat-mdc-card-title,.mat-mdc-card-title-group .mat-mdc-card-subtitle{padding-top:0}.mat-mdc-card-content>:last-child:not(.mat-mdc-card-footer){margin-bottom:0}.mat-mdc-card-actions-align-end{justify-content:flex-end}'],encapsulation:2,changeDetection:0}),n})(),mM=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=we({type:n,selectors:[["mat-card-title"],["","mat-card-title",""],["","matCardTitle",""]],hostAttrs:[1,"mat-mdc-card-title"]}),n})(),gM=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=we({type:n,selectors:[["mat-card-content"]],hostAttrs:[1,"mat-mdc-card-content"]}),n})(),Bq=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=we({type:n,selectors:[["mat-card-subtitle"],["","mat-card-subtitle",""],["","matCardSubtitle",""]],hostAttrs:[1,"mat-mdc-card-subtitle"]}),n})(),_M=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=bi({type:n,selectors:[["mat-card-header"]],hostAttrs:[1,"mat-mdc-card-header"],ngContentSelectors:pje,decls:4,vars:0,consts:[[1,"mat-mdc-card-header-text"]],template:function(e,i){1&e&&(rl(hje),Vi(0),kt(1,"div",0),Vi(2,1),Lt(),Vi(3,2))},encapsulation:2,changeDetection:0}),n})(),zq=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[on,Ta,on]}),n})();class Hg{ngOnInit(){this.trainNewModel()}trainNewModel(){var t=this;return ie(function*(){t.linearModel=function J1e(n){return new uG(n)}(),t.linearModel.add(function mTe(n){return new VG(n)}({units:1,inputShape:[1]})),t.linearModel.compile({loss:"meanSquaredError",optimizer:"sgd"});const e=gr([1,2,3,4,5,6,7,8,9,10]),i=gr([11,24,32,41,50,65,71,88,95,103]);yield t.linearModel.fit(e,i),console.log("model trained!")})()}linearPrediction(t){console.log(t);const e=this.linearModel.predict(dg([+t||0],[1,1]));this.prediction=Array.from(e.dataSync())[0]}}Hg.\u0275fac=function(t){return new(t||Hg)},Hg.\u0275cmp=bi({type:Hg,selectors:[["app-linear-regression"]],decls:9,vars:1,consts:[["type","number",3,"change"],["numberEntered",""]],template:function(t,e){if(1&t){const i=function wF(){return oe()}();kt(0,"mat-card")(1,"mat-card-header")(2,"mat-card-title"),as(3," Linear Model "),Lt(),kt(4,"mat-card-subtitle"),as(5),Lt()(),kt(6,"mat-card-content")(7,"input",0,1),An("change",function(){!function jN(n){return it.lFrame.contextLView=n,n[Jn]}(i);const s=function il(n){return function Ld(n,t){return n[t]}(function fX(){return it.lFrame.contextLView}(),Dn+n)}(8);return function WN(n){return it.lFrame.contextLView=null,n}(e.linearPrediction(s.value))}),Lt()()()}2&t&&(xi(5),J_(" Prediction Value: ",e.prediction," "))},dependencies:[fM,gM,_M,Bq,mM],styles:["mat-card[_ngcontent-%COMP%]{display:flex;flex-direction:column;margin:0 auto;width:100%}mat-card-content[_ngcontent-%COMP%]{display:flex;flex-direction:column}mat-card-title[_ngcontent-%COMP%]{text-align:center;font-weight:700;padding:1rem}"]});class Bh{constructor(t){this.elementRef=t,this.newImage=new $t,this.pos={x:0,y:0}}ngOnInit(){this.canvas=this.elementRef.nativeElement,this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0})}onUp(t){this.newImage.emit(this.getImgData())}onEnter(t){this.setPosition(t)}onMove(t){this.setPosition(t)}onDown(t){1===t.buttons&&(this.ctx.beginPath(),this.ctx.lineWidth=10,this.ctx.lineCap="round",this.ctx.strokeStyle="#111111",this.ctx.moveTo(this.pos.x,this.pos.y),this.setPosition(t),this.ctx.lineTo(this.pos.x,this.pos.y),this.ctx.stroke())}onResize(t){this.ctx.canvas.width=window.innerWidth,this.ctx.canvas.height=window.innerHeight}setPosition(t){this.pos.x=t.offsetX,this.pos.y=t.offsetY}clear(){this.ctx.clearRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height)}getImgData(){return this.ctx.drawImage(this.canvas,0,0,28,28),this.ctx.getImageData(0,0,28,28)}}Bh.\u0275fac=function(t){return new(t||Bh)(V(Pt))},Bh.\u0275dir=we({type:Bh,selectors:[["","appDrawable",""]],hostBindings:function(t,e){1&t&&An("mouseup",function(r){return e.onUp(r)})("mouseenter",function(r){return e.onEnter(r)})("mousedown",function(r){return e.onMove(r)})("mousemove",function(r){return e.onDown(r)})("resize",function(r){return e.onResize(r)})},outputs:{newImage:"newImage"}});class jg{constructor(){this.barChartOptions={scaleShowVerticalLines:!1,responsive:!0,backgroundColor:"#ef6c00",scales:{xAxes:[{gridLines:{display:!1},ticks:{fontSize:40}}],yAxes:[{display:!1,gridLines:{display:!1}}]}},this.barChartLabels=["0","1","2","3","4","5","6","7","8","9"],this.barChartType="bar",this.barChartLegend=!1}ngOnChanges(){this.barChartData=[{data:this.data||[0,0,0,0,0,0,0,0,0,0],label:"Predictions",backgroundColor:"#ef6c00"}]}}jg.\u0275fac=function(t){return new(t||jg)},jg.\u0275cmp=bi({type:jg,selectors:[["app-chart"]],inputs:{data:"data"},features:[rr],decls:3,vars:4,consts:[[1,"chart-wrapper"],[2,"display","block"],["baseChart","",3,"datasets","labels","legend","type"]],template:function(t,e){1&t&&(kt(0,"div",0)(1,"div",1),Ci(2,"canvas",2),Lt()()),2&t&&(xi(2),ai("datasets",e.barChartData)("labels",e.barChartLabels)("legend",e.barChartLegend)("type","bar"))},dependencies:[Uge]});class Wg{ngOnInit(){this.loadModel()}loadModel(){var t=this;return ie(function*(){t.model=yield function X1e(n,t){return _A.apply(this,arguments)}("../../../assets/ai-models/mnist/model.json"),console.log("Model Loaded!")})()}predict(t){G(()=>{let e=Yxe(t,1);e=e.reshape([1,28,28,1]),e=be(e,"float32");const i=this.model.predict(e);this.predictions=Array.from(i.dataSync()),console.log("Predictions:",this.predictions)})}}Wg.\u0275fac=function(t){return new(t||Wg)},Wg.\u0275cmp=bi({type:Wg,selectors:[["app-mnist-handwriting"]],viewQuery:function(t,e){if(1&t&&pu(Bh,5),2&t){let i;Ms(i=Ns())&&(e.canvas=i.first)}},decls:19,vars:1,consts:[[1,"card-container"],[1,"card-drawing"],[1,"wrapper"],["appDrawable","",3,"newImage"],[1,"btn","btn-sm","btn-warning",3,"click"],[1,"card-predictions"],[3,"data"]],template:function(t,e){1&t&&(kt(0,"mat-card")(1,"mat-card-content",0)(2,"mat-card",1)(3,"mat-card-header")(4,"mat-card-title"),as(5," Draw Here "),Lt()(),kt(6,"mat-card-content")(7,"div",2)(8,"canvas",3),An("newImage",function(r){return e.predict(r)}),Lt(),Ci(9,"br"),Lt(),kt(10,"div")(11,"button",4),An("click",function(){return e.canvas.clear()}),as(12,"Erase"),Lt()()()(),kt(13,"mat-card",5)(14,"mat-card-header")(15,"mat-card-title"),as(16," Predictions "),Lt()(),kt(17,"mat-card-content"),Ci(18,"app-chart",6),Lt()()()()),2&t&&(xi(18),ai("data",e.predictions))},dependencies:[fM,gM,_M,mM,Bh,jg],styles:[".wrapper[_ngcontent-%COMP%]{display:inline-flex;justify-content:flex-end;border:10px solid #ff943d;transition:border-color .2s ease-in}.wrapper[_ngcontent-%COMP%]:hover{border:10px solid #ef6c00;transition:border-color .2s ease-in}canvas[_ngcontent-%COMP%]{cursor:crosshair}.card-container[_ngcontent-%COMP%]{display:flex;flex-direction:row}.card-predictions[_ngcontent-%COMP%]{width:100%}"]});const Dje=[{path:"welcome",component:Kf},{path:"linear-regression",component:Hg},{path:"mnist-handwriting",component:Wg},{path:"**",redirectTo:"/welcome",pathMatch:"prefix"}];class zh{}zh.\u0275fac=function(t){return new(t||zh)},zh.\u0275mod=ut({type:zh}),zh.\u0275inj=at({imports:[GU.forRoot(Dje),GU]});let Sje=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({}),n})(),nw=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[on,Ta,PS,on]}),n})(),Uq=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[on,nw,nw,Sje,on]}),n})(),Hq=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[Kp,Ac,Ta,uv,on,on]}),n})(),oY=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[on,on]}),n})(),aY=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[on,on]}),n})(),dWe=(()=>{class n{constructor(){this.changes=new dt,this.calendarLabel="Calendar",this.openCalendarLabel="Open calendar",this.closeCalendarLabel="Close calendar",this.prevMonthLabel="Previous month",this.nextMonthLabel="Next month",this.prevYearLabel="Previous year",this.nextYearLabel="Next year",this.prevMultiYearLabel="Previous 24 years",this.nextMultiYearLabel="Next 24 years",this.switchToMonthViewLabel="Choose date",this.switchToMultiYearViewLabel="Choose month and year",this.startDateLabel="Start date",this.endDateLabel="End date"}formatYearRange(e,i){return`${e} \u2013 ${i}`}formatYearRangeLabel(e,i){return`${e} to ${i}`}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const vWe={provide:new ne("mat-datepicker-scroll-strategy"),deps:[cl],useFactory:function yWe(n){return()=>n.scrollStrategies.reposition()}};let hY=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({providers:[dWe,vWe],imports:[Ta,uv,Kp,zS,Ac,on,Su]}),n})();const AWe={provide:new ne("mat-tooltip-scroll-strategy"),deps:[cl],useFactory:function TWe(n){return()=>n.scrollStrategies.reposition({scrollThrottle:20})}};let pY=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({providers:[AWe],imports:[zS,Ta,Kp,on,on,Su]}),n})(),NWe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({}),n})(),mY=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[Ta,on,NWe,Ac]}),n})(),gY=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[Ta,on,Su,Su,on]}),n})(),OWe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[on,on]}),n})(),wY=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({imports:[PS,Ta,on,iH,Iye,OWe]}),n})();const dGe=[Uq,uv,zq,nw,bH,Hq,oY,aY,hY,pY,mY,gY,wY];class Wh{}function CY(n){return new Q(3e3,!1)}function WGe(){return typeof window<"u"&&typeof window.document<"u"}function EM(){return typeof process<"u"&&"[object process]"==={}.toString.call(process)}function rc(n){switch(n.length){case 0:return new Yf;case 1:return n[0];default:return new uH(n)}}function DY(n,t,e,i,r=new Map,s=new Map){const o=[],a=[];let l=-1,c=null;if(i.forEach(d=>{const u=d.get("offset"),h=u==l,p=h&&c||new Map;d.forEach((f,m)=>{let g=m,_=f;if("offset"!==m)switch(g=t.normalizePropertyName(g,o),_){case KE:_=r.get(m);break;case $a:_=s.get(m);break;default:_=t.normalizeStyleValue(m,g,_,o)}p.set(g,_)}),h||a.push(p),c=p,l=u}),o.length)throw function RGe(n){return new Q(3502,!1)}();return a}function IM(n,t,e,i){switch(t){case"start":n.onStart(()=>i(e&&TM(e,"start",n)));break;case"done":n.onDone(()=>i(e&&TM(e,"done",n)));break;case"destroy":n.onDestroy(()=>i(e&&TM(e,"destroy",n)))}}function TM(n,t,e){const s=AM(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,e.totalTime??n.totalTime,!!e.disabled),o=n._data;return null!=o&&(s._data=o),s}function AM(n,t,e,i,r="",s=0,o){return{element:n,triggerName:t,fromState:e,toState:i,phaseName:r,totalTime:s,disabled:!!o}}function xs(n,t,e){let i=n.get(t);return i||n.set(t,i=e),i}function SY(n){const t=n.indexOf(":");return[n.substring(1,t),n.slice(t+1)]}Wh.\u0275fac=function(t){return new(t||Wh)},Wh.\u0275mod=ut({type:Wh}),Wh.\u0275inj=at({imports:[dGe,Uq,uv,zq,nw,bH,Hq,oY,aY,hY,pY,mY,gY,wY]});let MM=(n,t)=>!1,kY=(n,t,e)=>[],EY=null;function NM(n){const t=n.parentNode||n.host;return t===EY?null:t}(EM()||typeof Element<"u")&&(WGe()?(EY=(()=>document.documentElement)(),MM=(n,t)=>{for(;t;){if(t===n)return!0;t=NM(t)}return!1}):MM=(n,t)=>n.contains(t),kY=(n,t,e)=>{if(e)return Array.from(n.querySelectorAll(t));const i=n.querySelector(t);return i?[i]:[]});let Sd=null,IY=!1;const TY=MM,AY=kY;let MY=(()=>{class n{validateStyleProperty(e){return function qGe(n){Sd||(Sd=function YGe(){return typeof document<"u"?document.body:null}()||{},IY=!!Sd.style&&"WebkitAppearance"in Sd.style);let t=!0;return Sd.style&&!function GGe(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in Sd.style,!t&&IY&&(t="Webkit"+n.charAt(0).toUpperCase()+n.slice(1)in Sd.style)),t}(e)}matchesElement(e,i){return!1}containsElement(e,i){return TY(e,i)}getParentElement(e){return NM(e)}query(e,i,r){return AY(e,i,r)}computeStyle(e,i,r){return r||""}animate(e,i,r,s,o,a=[],l){return new Yf(r,s)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})(),RM=(()=>{class n{}return n.NOOP=new MY,n})();const KGe=1e3,OM="ng-enter",cw="ng-leave",dw="ng-trigger",uw=".ng-trigger",RY="ng-animating",FM=".ng-animating";function Xa(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:PM(parseFloat(t[1]),t[2])}function PM(n,t){return"s"===t?n*KGe:n}function hw(n,t,e){return n.hasOwnProperty("duration")?n:function ZGe(n,t,e){let r,s=0,o="";if("string"==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(CY()),{duration:0,delay:0,easing:""};r=PM(parseFloat(a[1]),a[2]);const l=a[3];null!=l&&(s=PM(parseFloat(l),a[4]));const c=a[5];c&&(o=c)}else r=n;if(!e){let a=!1,l=t.length;r<0&&(t.push(function uGe(){return new Q(3100,!1)}()),a=!0),s<0&&(t.push(function hGe(){return new Q(3101,!1)}()),a=!0),a&&t.splice(l,0,CY())}return{duration:r,delay:s,easing:o}}(n,t,e)}function Kg(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function OY(n){const t=new Map;return Object.keys(n).forEach(e=>{t.set(e,n[e])}),t}function sc(n,t=new Map,e){if(e)for(let[i,r]of e)t.set(i,r);for(let[i,r]of n)t.set(i,r);return t}function PY(n,t,e){return e?t+":"+e+";":""}function LY(n){let t="";for(let e=0;e<n.style.length;e++){const i=n.style.item(e);t+=PY(0,i,n.style.getPropertyValue(i))}for(const e in n.style)n.style.hasOwnProperty(e)&&!e.startsWith("_")&&(t+=PY(0,t5e(e),n.style[e]));n.setAttribute("style",t)}function ua(n,t,e){n.style&&(t.forEach((i,r)=>{const s=$M(r);e&&!e.has(r)&&e.set(r,n.style[s]),n.style[s]=i}),EM()&&LY(n))}function kd(n,t){n.style&&(t.forEach((e,i)=>{const r=$M(i);n.style[r]=""}),EM()&&LY(n))}function Xg(n){return Array.isArray(n)?1==n.length?n[0]:oH(n):n}const LM=new RegExp("{{\\s*(.+?)\\s*}}","g");function $Y(n){let t=[];if("string"==typeof n){let e;for(;e=LM.exec(n);)t.push(e[1]);LM.lastIndex=0}return t}function Zg(n,t,e){const i=n.toString(),r=i.replace(LM,(s,o)=>{let a=t[o];return null==a&&(e.push(function fGe(n){return new Q(3003,!1)}()),a=""),a.toString()});return r==i?n:r}function pw(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const e5e=/-+([a-z0-9])/g;function $M(n){return n.replace(e5e,(...t)=>t[1].toUpperCase())}function t5e(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function ws(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function mGe(n){return new Q(3004,!1)}()}}function VY(n,t){return window.getComputedStyle(n)[t]}const gw="*";function a5e(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(i=>function l5e(n,t,e){if(":"==n[0]){const l=function c5e(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,i)=>parseFloat(i)>parseFloat(e);case":decrement":return(e,i)=>parseFloat(i)<parseFloat(e);default:return t.push(function TGe(n){return new Q(3016,!1)}()),"* => *"}}(n,e);if("function"==typeof l)return void t.push(l);n=l}const i=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==i||i.length<4)return e.push(function IGe(n){return new Q(3015,!1)}()),t;const r=i[1],s=i[2],o=i[3];t.push(BY(r,o));"<"==s[0]&&!(r==gw&&o==gw)&&t.push(BY(o,r))}(i,e,t)):e.push(n),e}const _w=new Set(["true","1"]),bw=new Set(["false","0"]);function BY(n,t){const e=_w.has(n)||bw.has(n),i=_w.has(t)||bw.has(t);return(r,s)=>{let o=n==gw||n==r,a=t==gw||t==s;return!o&&e&&"boolean"==typeof r&&(o=r?_w.has(n):bw.has(n)),!a&&i&&"boolean"==typeof s&&(a=s?_w.has(t):bw.has(t)),o&&a}}const d5e=new RegExp("s*:selfs*,?","g");function VM(n,t,e,i){return new u5e(n).build(t,e,i)}class u5e{constructor(t){this._driver=t}build(t,e,i){const r=new f5e(e);return this._resetContextStyleTimingState(r),ws(this,Xg(t),r)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles=new Map,t.collectedStyles.set("",new Map),t.currentTime=0}visitTrigger(t,e){let i=e.queryCount=0,r=e.depCount=0;const s=[],o=[];return"@"==t.name.charAt(0)&&e.errors.push(function _Ge(){return new Q(3006,!1)}()),t.definitions.forEach(a=>{if(this._resetContextStyleTimingState(e),0==a.type){const l=a,c=l.name;c.toString().split(/\s*,\s*/).forEach(d=>{l.name=d,s.push(this.visitState(l,e))}),l.name=c}else if(1==a.type){const l=this.visitTransition(a,e);i+=l.queryCount,r+=l.depCount,o.push(l)}else e.errors.push(function bGe(){return new Q(3007,!1)}())}),{type:7,name:t.name,states:s,transitions:o,queryCount:i,depCount:r,options:null}}visitState(t,e){const i=this.visitStyle(t.styles,e),r=t.options&&t.options.params||null;if(i.containsDynamicStyles){const s=new Set,o=r||{};i.styles.forEach(a=>{a instanceof Map&&a.forEach(l=>{$Y(l).forEach(c=>{o.hasOwnProperty(c)||s.add(c)})})}),s.size&&(pw(s.values()),e.errors.push(function yGe(n,t){return new Q(3008,!1)}()))}return{type:0,name:t.name,style:i,options:r?{params:r}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const i=ws(this,Xg(t.animation),e);return{type:1,matchers:a5e(t.expr,e.errors),animation:i,queryCount:e.queryCount,depCount:e.depCount,options:Ed(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(i=>ws(this,i,e)),options:Ed(t.options)}}visitGroup(t,e){const i=e.currentTime;let r=0;const s=t.steps.map(o=>{e.currentTime=i;const a=ws(this,o,e);return r=Math.max(r,e.currentTime),a});return e.currentTime=r,{type:3,steps:s,options:Ed(t.options)}}visitAnimate(t,e){const i=function g5e(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return BM(hw(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(s=>"{"==s.charAt(0)&&"{"==s.charAt(1))){const s=BM(0,0,"");return s.dynamic=!0,s.strValue=e,s}const r=hw(e,t);return BM(r.duration,r.delay,r.easing)}(t.timings,e.errors);e.currentAnimateTimings=i;let r,s=t.styles?t.styles:vn({});if(5==s.type)r=this.visitKeyframes(s,e);else{let o=t.styles,a=!1;if(!o){a=!0;const c={};i.easing&&(c.easing=i.easing),o=vn(c)}e.currentTime+=i.duration+i.delay;const l=this.visitStyle(o,e);l.isEmptyStep=a,r=l}return e.currentAnimateTimings=null,{type:4,timings:i,style:r,options:null}}visitStyle(t,e){const i=this._makeStyleAst(t,e);return this._validateStyleAst(i,e),i}_makeStyleAst(t,e){const i=[],r=Array.isArray(t.styles)?t.styles:[t.styles];for(let a of r)"string"==typeof a?a===$a?i.push(a):e.errors.push(new Q(3002,!1)):i.push(OY(a));let s=!1,o=null;return i.forEach(a=>{if(a instanceof Map&&(a.has("easing")&&(o=a.get("easing"),a.delete("easing")),!s))for(let l of a.values())if(l.toString().indexOf("{{")>=0){s=!0;break}}),{type:6,styles:i,easing:o,offset:t.offset,containsDynamicStyles:s,options:null}}_validateStyleAst(t,e){const i=e.currentAnimateTimings;let r=e.currentTime,s=e.currentTime;i&&s>0&&(s-=i.duration+i.delay),t.styles.forEach(o=>{"string"!=typeof o&&o.forEach((a,l)=>{const c=e.collectedStyles.get(e.currentQuerySelector),d=c.get(l);let u=!0;d&&(s!=r&&s>=d.startTime&&r<=d.endTime&&(e.errors.push(function xGe(n,t,e,i,r){return new Q(3010,!1)}()),u=!1),s=d.startTime),u&&c.set(l,{startTime:s,endTime:r}),e.options&&function JGe(n,t,e){const i=t.params||{},r=$Y(n);r.length&&r.forEach(s=>{i.hasOwnProperty(s)||e.push(function pGe(n){return new Q(3001,!1)}())})}(a,e.options,e.errors)})})}visitKeyframes(t,e){const i={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function wGe(){return new Q(3011,!1)}()),i;let s=0;const o=[];let a=!1,l=!1,c=0;const d=t.steps.map(_=>{const b=this._makeStyleAst(_,e);let y=null!=b.offset?b.offset:function m5e(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(e instanceof Map&&e.has("offset")){const i=e;t=parseFloat(i.get("offset")),i.delete("offset")}});else if(n instanceof Map&&n.has("offset")){const e=n;t=parseFloat(e.get("offset")),e.delete("offset")}return t}(b.styles),v=0;return null!=y&&(s++,v=b.offset=y),l=l||v<0||v>1,a=a||v<c,c=v,o.push(v),b});l&&e.errors.push(function CGe(){return new Q(3012,!1)}()),a&&e.errors.push(function DGe(){return new Q(3200,!1)}());const u=t.steps.length;let h=0;s>0&&s<u?e.errors.push(function SGe(){return new Q(3202,!1)}()):0==s&&(h=1/(u-1));const p=u-1,f=e.currentTime,m=e.currentAnimateTimings,g=m.duration;return d.forEach((_,b)=>{const y=h>0?b==p?1:h*b:o[b],v=y*g;e.currentTime=f+m.delay+v,m.duration=v,this._validateStyleAst(_,e),_.offset=y,i.styles.push(_)}),i}visitReference(t,e){return{type:8,animation:ws(this,Xg(t.animation),e),options:Ed(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Ed(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Ed(t.options)}}visitQuery(t,e){const i=e.currentQuerySelector,r=t.options||{};e.queryCount++,e.currentQuery=t;const[s,o]=function h5e(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(d5e,"")),n=n.replace(/@\*/g,uw).replace(/@\w+/g,e=>uw+"-"+e.slice(1)).replace(/:animating/g,FM),[n,t]}(t.selector);e.currentQuerySelector=i.length?i+" "+s:s,xs(e.collectedStyles,e.currentQuerySelector,new Map);const a=ws(this,Xg(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=i,{type:11,selector:s,limit:r.limit||0,optional:!!r.optional,includeSelf:o,animation:a,originalSelector:t.selector,options:Ed(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function kGe(){return new Q(3013,!1)}());const i="full"===t.timings?{duration:0,delay:0,easing:"full"}:hw(t.timings,e.errors,!0);return{type:12,animation:ws(this,Xg(t.animation),e),timings:i,options:null}}}class f5e{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function Ed(n){return n?(n=Kg(n)).params&&(n.params=function p5e(n){return n?Kg(n):null}(n.params)):n={},n}function BM(n,t,e){return{duration:n,delay:t,easing:e}}function zM(n,t,e,i,r,s,o=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:i,duration:r,delay:s,totalTime:r+s,easing:o,subTimeline:a}}class yw{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let i=this._map.get(t);i||this._map.set(t,i=[]),i.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const y5e=new RegExp(":enter","g"),x5e=new RegExp(":leave","g");function UM(n,t,e,i,r,s=new Map,o=new Map,a,l,c=[]){return(new w5e).buildKeyframes(n,t,e,i,r,s,o,a,l,c)}class w5e{buildKeyframes(t,e,i,r,s,o,a,l,c,d=[]){c=c||new yw;const u=new HM(t,e,c,r,s,d,[]);u.options=l;const h=l.delay?Xa(l.delay):0;u.currentTimeline.delayNextStep(h),u.currentTimeline.setStyles([o],null,u.errors,l),ws(this,i,u);const p=u.timelines.filter(f=>f.containsAnimation());if(p.length&&a.size){let f;for(let m=p.length-1;m>=0;m--){const g=p[m];if(g.element===e){f=g;break}}f&&!f.allowOnlyTimelineStyles()&&f.setStyles([a],null,u.errors,l)}return p.length?p.map(f=>f.buildKeyframes()):[zM(e,[],[],[],0,h,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const i=e.subInstructions.get(e.element);if(i){const r=e.createSubContext(t.options),s=e.currentTimeline.currentTime,o=this._visitSubInstructions(i,r,r.options);s!=o&&e.transformIntoNewTimeline(o)}e.previousNode=t}visitAnimateRef(t,e){const i=e.createSubContext(t.options);i.transformIntoNewTimeline(),this._applyAnimationRefDelays([t.options,t.animation.options],e,i),this.visitReference(t.animation,i),e.transformIntoNewTimeline(i.currentTimeline.currentTime),e.previousNode=t}_applyAnimationRefDelays(t,e,i){for(const r of t){const s=r?.delay;if(s){const o="number"==typeof s?s:Xa(Zg(s,r?.params??{},e.errors));i.delayNextStep(o)}}}_visitSubInstructions(t,e,i){let s=e.currentTimeline.currentTime;const o=null!=i.duration?Xa(i.duration):null,a=null!=i.delay?Xa(i.delay):null;return 0!==o&&t.forEach(l=>{const c=e.appendInstructionToTimeline(l,o,a);s=Math.max(s,c.duration+c.delay)}),s}visitReference(t,e){e.updateOptions(t.options,!0),ws(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const i=e.subContextCount;let r=e;const s=t.options;if(s&&(s.params||s.delay)&&(r=e.createSubContext(s),r.transformIntoNewTimeline(),null!=s.delay)){6==r.previousNode.type&&(r.currentTimeline.snapshotCurrentStyles(),r.previousNode=vw);const o=Xa(s.delay);r.delayNextStep(o)}t.steps.length&&(t.steps.forEach(o=>ws(this,o,r)),r.currentTimeline.applyStylesToKeyframe(),r.subContextCount>i&&r.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const i=[];let r=e.currentTimeline.currentTime;const s=t.options&&t.options.delay?Xa(t.options.delay):0;t.steps.forEach(o=>{const a=e.createSubContext(t.options);s&&a.delayNextStep(s),ws(this,o,a),r=Math.max(r,a.currentTimeline.currentTime),i.push(a.currentTimeline)}),i.forEach(o=>e.currentTimeline.mergeTimelineCollectedStyles(o)),e.transformIntoNewTimeline(r),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const i=t.strValue;return hw(e.params?Zg(i,e.params,e.errors):i,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const i=e.currentAnimateTimings=this._visitTiming(t.timings,e),r=e.currentTimeline;i.delay&&(e.incrementTime(i.delay),r.snapshotCurrentStyles());const s=t.style;5==s.type?this.visitKeyframes(s,e):(e.incrementTime(i.duration),this.visitStyle(s,e),r.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const i=e.currentTimeline,r=e.currentAnimateTimings;!r&&i.hasCurrentStyleProperties()&&i.forwardFrame();const s=r&&r.easing||t.easing;t.isEmptyStep?i.applyEmptyStep(s):i.setStyles(t.styles,s,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const i=e.currentAnimateTimings,r=e.currentTimeline.duration,s=i.duration,a=e.createSubContext().currentTimeline;a.easing=i.easing,t.styles.forEach(l=>{a.forwardTime((l.offset||0)*s),a.setStyles(l.styles,l.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(r+s),e.previousNode=t}visitQuery(t,e){const i=e.currentTimeline.currentTime,r=t.options||{},s=r.delay?Xa(r.delay):0;s&&(6===e.previousNode.type||0==i&&e.currentTimeline.hasCurrentStyleProperties())&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=vw);let o=i;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!r.optional,e.errors);e.currentQueryTotal=a.length;let l=null;a.forEach((c,d)=>{e.currentQueryIndex=d;const u=e.createSubContext(t.options,c);s&&u.delayNextStep(s),c===e.element&&(l=u.currentTimeline),ws(this,t.animation,u),u.currentTimeline.applyStylesToKeyframe(),o=Math.max(o,u.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(o),l&&(e.currentTimeline.mergeTimelineCollectedStyles(l),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const i=e.parentContext,r=e.currentTimeline,s=t.timings,o=Math.abs(s.duration),a=o*(e.currentQueryTotal-1);let l=o*e.currentQueryIndex;switch(s.duration<0?"reverse":s.easing){case"reverse":l=a-l;break;case"full":l=i.currentStaggerTime}const d=e.currentTimeline;l&&d.delayNextStep(l);const u=d.currentTime;ws(this,t.animation,e),e.previousNode=t,i.currentStaggerTime=r.currentTime-u+(r.startTime-i.currentTimeline.startTime)}}const vw={};class HM{constructor(t,e,i,r,s,o,a,l){this._driver=t,this.element=e,this.subInstructions=i,this._enterClassName=r,this._leaveClassName=s,this.errors=o,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=vw,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=l||new xw(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const i=t;let r=this.options;null!=i.duration&&(r.duration=Xa(i.duration)),null!=i.delay&&(r.delay=Xa(i.delay));const s=i.params;if(s){let o=r.params;o||(o=this.options.params={}),Object.keys(s).forEach(a=>{(!e||!o.hasOwnProperty(a))&&(o[a]=Zg(s[a],o,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const i=t.params={};Object.keys(e).forEach(r=>{i[r]=e[r]})}}return t}createSubContext(t=null,e,i){const r=e||this.element,s=new HM(this._driver,r,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(r,i||0));return s.previousNode=this.previousNode,s.currentAnimateTimings=this.currentAnimateTimings,s.options=this._copyOptions(),s.updateOptions(t),s.currentQueryIndex=this.currentQueryIndex,s.currentQueryTotal=this.currentQueryTotal,s.parentContext=this,this.subContextCount++,s}transformIntoNewTimeline(t){return this.previousNode=vw,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,i){const r={duration:e??t.duration,delay:this.currentTimeline.currentTime+(i??0)+t.delay,easing:""},s=new C5e(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,r,t.stretchStartingKeyframe);return this.timelines.push(s),r}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,i,r,s,o){let a=[];if(r&&a.push(this.element),t.length>0){t=(t=t.replace(y5e,"."+this._enterClassName)).replace(x5e,"."+this._leaveClassName);let c=this._driver.query(this.element,t,1!=i);0!==i&&(c=i<0?c.slice(c.length+i,c.length):c.slice(0,i)),a.push(...c)}return!s&&0==a.length&&o.push(function EGe(n){return new Q(3014,!1)}()),a}}class xw{constructor(t,e,i,r){this._driver=t,this.element=e,this.startTime=i,this._elementTimelineStylesLookup=r,this.duration=0,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1===this._keyframes.size&&this._pendingStyles.size;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new xw(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles.set(t,e),this._globalTimelineStyles.set(t,e),this._styleSummary.set(t,{time:this.currentTime,value:e})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&this._previousKeyframe.set("easing",t);for(let[e,i]of this._globalTimelineStyles)this._backFill.set(e,i||$a),this._currentKeyframe.set(e,$a);this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,i,r){e&&this._previousKeyframe.set("easing",e);const s=r&&r.params||{},o=function D5e(n,t){const e=new Map;let i;return n.forEach(r=>{if("*"===r){i=i||t.keys();for(let s of i)e.set(s,$a)}else sc(r,e)}),e}(t,this._globalTimelineStyles);for(let[a,l]of o){const c=Zg(l,s,i);this._pendingStyles.set(a,c),this._localTimelineStyles.has(a)||this._backFill.set(a,this._globalTimelineStyles.get(a)??$a),this._updateStyle(a,c)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach((t,e)=>{this._currentKeyframe.set(e,t)}),this._pendingStyles.clear(),this._localTimelineStyles.forEach((t,e)=>{this._currentKeyframe.has(e)||this._currentKeyframe.set(e,t)}))}snapshotCurrentStyles(){for(let[t,e]of this._localTimelineStyles)this._pendingStyles.set(t,e),this._updateStyle(t,e)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){t._styleSummary.forEach((e,i)=>{const r=this._styleSummary.get(i);(!r||e.time>r.time)&&this._updateStyle(i,e.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,i=1===this._keyframes.size&&0===this.duration;let r=[];this._keyframes.forEach((a,l)=>{const c=sc(a,new Map,this._backFill);c.forEach((d,u)=>{d===KE?t.add(u):d===$a&&e.add(u)}),i||c.set("offset",l/this.duration),r.push(c)});const s=t.size?pw(t.values()):[],o=e.size?pw(e.values()):[];if(i){const a=r[0],l=new Map(a);a.set("offset",0),l.set("offset",1),r=[a,l]}return zM(this.element,r,s,o,this.duration,this.startTime,this.easing,!1)}}class C5e extends xw{constructor(t,e,i,r,s,o,a=!1){super(t,e,o.delay),this.keyframes=i,this.preStyleProps=r,this.postStyleProps=s,this._stretchStartingKeyframe=a,this.timings={duration:o.duration,delay:o.delay,easing:o.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:i,easing:r}=this.timings;if(this._stretchStartingKeyframe&&e){const s=[],o=i+e,a=e/o,l=sc(t[0]);l.set("offset",0),s.push(l);const c=sc(t[0]);c.set("offset",HY(a)),s.push(c);const d=t.length-1;for(let u=1;u<=d;u++){let h=sc(t[u]);const p=h.get("offset");h.set("offset",HY((e+p*i)/o)),s.push(h)}i=o,e=0,r="",t=s}return zM(this.element,t,this.preStyleProps,this.postStyleProps,i,e,r,!0)}}function HY(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class jM{}const S5e=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class k5e extends jM{normalizePropertyName(t,e){return $M(t)}normalizeStyleValue(t,e,i,r){let s="";const o=i.toString().trim();if(S5e.has(e)&&0!==i&&"0"!==i)if("number"==typeof i)s="px";else{const a=i.match(/^[+-]?[\d\.]+([a-z]*)$/);a&&0==a[1].length&&r.push(function gGe(n,t){return new Q(3005,!1)}())}return o+s}}function jY(n,t,e,i,r,s,o,a,l,c,d,u,h){return{type:0,element:n,triggerName:t,isRemovalTransition:r,fromState:e,fromStyles:s,toState:i,toStyles:o,timelines:a,queriedElements:l,preStyleProps:c,postStyleProps:d,totalTime:u,errors:h}}const WM={};class WY{constructor(t,e,i){this._triggerName=t,this.ast=e,this._stateStyles=i}match(t,e,i,r){return function E5e(n,t,e,i,r){return n.some(s=>s(t,e,i,r))}(this.ast.matchers,t,e,i,r)}buildStyles(t,e,i){let r=this._stateStyles.get("*");return void 0!==t&&(r=this._stateStyles.get(t?.toString())||r),r?r.buildStyles(e,i):new Map}build(t,e,i,r,s,o,a,l,c,d){const u=[],h=this.ast.options&&this.ast.options.params||WM,f=this.buildStyles(i,a&&a.params||WM,u),m=l&&l.params||WM,g=this.buildStyles(r,m,u),_=new Set,b=new Map,y=new Map,v="void"===r,x={params:I5e(m,h),delay:this.ast.options?.delay},w=d?[]:UM(t,e,this.ast.animation,s,o,f,g,x,c,u);let C=0;if(w.forEach(k=>{C=Math.max(k.duration+k.delay,C)}),u.length)return jY(e,this._triggerName,i,r,v,f,g,[],[],b,y,C,u);w.forEach(k=>{const I=k.element,A=xs(b,I,new Set);k.preStyleProps.forEach(H=>A.add(H));const $=xs(y,I,new Set);k.postStyleProps.forEach(H=>$.add(H)),I!==e&&_.add(I)});const D=pw(_.values());return jY(e,this._triggerName,i,r,v,f,g,w,D,b,y,C)}}function I5e(n,t){const e=Kg(t);for(const i in n)n.hasOwnProperty(i)&&null!=n[i]&&(e[i]=n[i]);return e}class T5e{constructor(t,e,i){this.styles=t,this.defaultParams=e,this.normalizer=i}buildStyles(t,e){const i=new Map,r=Kg(this.defaultParams);return Object.keys(t).forEach(s=>{const o=t[s];null!==o&&(r[s]=o)}),this.styles.styles.forEach(s=>{"string"!=typeof s&&s.forEach((o,a)=>{o&&(o=Zg(o,r,e));const l=this.normalizer.normalizePropertyName(a,e);o=this.normalizer.normalizeStyleValue(a,l,o,e),i.set(a,o)})}),i}}class M5e{constructor(t,e,i){this.name=t,this.ast=e,this._normalizer=i,this.transitionFactories=[],this.states=new Map,e.states.forEach(r=>{this.states.set(r.name,new T5e(r.style,r.options&&r.options.params||{},i))}),GY(this.states,"true","1"),GY(this.states,"false","0"),e.transitions.forEach(r=>{this.transitionFactories.push(new WY(t,r,this.states))}),this.fallbackTransition=function N5e(n,t,e){return new WY(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(o,a)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,i,r){return this.transitionFactories.find(o=>o.match(t,e,i,r))||null}matchStyles(t,e,i){return this.fallbackTransition.buildStyles(t,e,i)}}function GY(n,t,e){n.has(t)?n.has(e)||n.set(e,n.get(t)):n.has(e)&&n.set(t,n.get(e))}const R5e=new yw;class O5e{constructor(t,e,i){this.bodyNode=t,this._driver=e,this._normalizer=i,this._animations=new Map,this._playersById=new Map,this.players=[]}register(t,e){const i=[],r=[],s=VM(this._driver,e,i,r);if(i.length)throw function OGe(n){return new Q(3503,!1)}();this._animations.set(t,s)}_buildPlayer(t,e,i){const r=t.element,s=DY(0,this._normalizer,0,t.keyframes,e,i);return this._driver.animate(r,s,t.duration,t.delay,t.easing,[],!0)}create(t,e,i={}){const r=[],s=this._animations.get(t);let o;const a=new Map;if(s?(o=UM(this._driver,e,s,OM,cw,new Map,new Map,i,R5e,r),o.forEach(d=>{const u=xs(a,d.element,new Map);d.postStyleProps.forEach(h=>u.set(h,null))})):(r.push(function FGe(){return new Q(3300,!1)}()),o=[]),r.length)throw function PGe(n){return new Q(3504,!1)}();a.forEach((d,u)=>{d.forEach((h,p)=>{d.set(p,this._driver.computeStyle(u,p,$a))})});const c=rc(o.map(d=>{const u=a.get(d.element);return this._buildPlayer(d,new Map,u)}));return this._playersById.set(t,c),c.onDestroy(()=>this.destroy(t)),this.players.push(c),c}destroy(t){const e=this._getPlayer(t);e.destroy(),this._playersById.delete(t);const i=this.players.indexOf(e);i>=0&&this.players.splice(i,1)}_getPlayer(t){const e=this._playersById.get(t);if(!e)throw function LGe(n){return new Q(3301,!1)}();return e}listen(t,e,i,r){const s=AM(e,"","","");return IM(this._getPlayer(t),i,s,r),()=>{}}command(t,e,i,r){if("register"==i)return void this.register(t,r[0]);if("create"==i)return void this.create(t,e,r[0]||{});const s=this._getPlayer(t);switch(i){case"play":s.play();break;case"pause":s.pause();break;case"reset":s.reset();break;case"restart":s.restart();break;case"finish":s.finish();break;case"init":s.init();break;case"setPosition":s.setPosition(parseFloat(r[0]));break;case"destroy":this.destroy(t)}}}const qY="ng-animate-queued",GM="ng-animate-disabled",V5e=[],YY={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},B5e={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},Js="__ng_removed";class qM{get params(){return this.options.params}constructor(t,e=""){this.namespaceId=e;const i=t&&t.hasOwnProperty("value");if(this.value=function j5e(n){return n??null}(i?t.value:t),i){const s=Kg(t);delete s.value,this.options=s}else this.options={};this.options.params||(this.options.params={})}absorbOptions(t){const e=t.params;if(e){const i=this.options.params;Object.keys(e).forEach(r=>{null==i[r]&&(i[r]=e[r])})}}}const Qg="void",YM=new qM(Qg);class z5e{constructor(t,e,i){this.id=t,this.hostElement=e,this._engine=i,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,eo(e,this._hostClassName)}listen(t,e,i,r){if(!this._triggers.has(e))throw function $Ge(n,t){return new Q(3302,!1)}();if(null==i||0==i.length)throw function VGe(n){return new Q(3303,!1)}();if(!function W5e(n){return"start"==n||"done"==n}(i))throw function BGe(n,t){return new Q(3400,!1)}();const s=xs(this._elementListeners,t,[]),o={name:e,phase:i,callback:r};s.push(o);const a=xs(this._engine.statesByElement,t,new Map);return a.has(e)||(eo(t,dw),eo(t,dw+"-"+e),a.set(e,YM)),()=>{this._engine.afterFlush(()=>{const l=s.indexOf(o);l>=0&&s.splice(l,1),this._triggers.has(e)||a.delete(e)})}}register(t,e){return!this._triggers.has(t)&&(this._triggers.set(t,e),!0)}_getTrigger(t){const e=this._triggers.get(t);if(!e)throw function zGe(n){return new Q(3401,!1)}();return e}trigger(t,e,i,r=!0){const s=this._getTrigger(e),o=new KM(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(eo(t,dw),eo(t,dw+"-"+e),this._engine.statesByElement.set(t,a=new Map));let l=a.get(e);const c=new qM(i,this.id);if(!(i&&i.hasOwnProperty("value"))&&l&&c.absorbOptions(l.options),a.set(e,c),l||(l=YM),c.value!==Qg&&l.value===c.value){if(!function Y5e(n,t){const e=Object.keys(n),i=Object.keys(t);if(e.length!=i.length)return!1;for(let r=0;r<e.length;r++){const s=e[r];if(!t.hasOwnProperty(s)||n[s]!==t[s])return!1}return!0}(l.params,c.params)){const m=[],g=s.matchStyles(l.value,l.params,m),_=s.matchStyles(c.value,c.params,m);m.length?this._engine.reportError(m):this._engine.afterFlush(()=>{kd(t,g),ua(t,_)})}return}const h=xs(this._engine.playersByElement,t,[]);h.forEach(m=>{m.namespaceId==this.id&&m.triggerName==e&&m.queued&&m.destroy()});let p=s.matchTransition(l.value,c.value,t,c.params),f=!1;if(!p){if(!r)return;p=s.fallbackTransition,f=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:p,fromState:l,toState:c,player:o,isFallbackTransition:f}),f||(eo(t,qY),o.onStart(()=>{Gh(t,qY)})),o.onDone(()=>{let m=this.players.indexOf(o);m>=0&&this.players.splice(m,1);const g=this._engine.playersByElement.get(t);if(g){let _=g.indexOf(o);_>=0&&g.splice(_,1)}}),this.players.push(o),h.push(o),o}deregister(t){this._triggers.delete(t),this._engine.statesByElement.forEach(e=>e.delete(t)),this._elementListeners.forEach((e,i)=>{this._elementListeners.set(i,e.filter(r=>r.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(i=>i.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const i=this._engine.driver.query(t,uw,!0);i.forEach(r=>{if(r[Js])return;const s=this._engine.fetchNamespacesByElement(r);s.size?s.forEach(o=>o.triggerLeaveAnimation(r,e,!1,!0)):this.clearElementCache(r)}),this._engine.afterFlushAnimationsDone(()=>i.forEach(r=>this.clearElementCache(r)))}triggerLeaveAnimation(t,e,i,r){const s=this._engine.statesByElement.get(t),o=new Map;if(s){const a=[];if(s.forEach((l,c)=>{if(o.set(c,l.value),this._triggers.has(c)){const d=this.trigger(t,c,Qg,r);d&&a.push(d)}}),a.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,o),i&&rc(a).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),i=this._engine.statesByElement.get(t);if(e&&i){const r=new Set;e.forEach(s=>{const o=s.name;if(r.has(o))return;r.add(o);const l=this._triggers.get(o).fallbackTransition,c=i.get(o)||YM,d=new qM(Qg),u=new KM(this.id,o,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:o,transition:l,fromState:c,toState:d,player:u,isFallbackTransition:!0})})}}removeNode(t,e){const i=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let r=!1;if(i.totalAnimations){const s=i.players.length?i.playersByQueriedElement.get(t):[];if(s&&s.length)r=!0;else{let o=t;for(;o=o.parentNode;)if(i.statesByElement.get(o)){r=!0;break}}}if(this.prepareLeaveAnimationListeners(t),r)i.markElementAsRemoved(this.id,t,!1,e);else{const s=t[Js];(!s||s===YY)&&(i.afterFlush(()=>this.clearElementCache(t)),i.destroyInnerAnimations(t),i._onRemovalComplete(t,e))}}insertNode(t,e){eo(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(i=>{const r=i.player;if(r.destroyed)return;const s=i.element,o=this._elementListeners.get(s);o&&o.forEach(a=>{if(a.name==i.triggerName){const l=AM(s,i.triggerName,i.fromState.value,i.toState.value);l._data=t,IM(i.player,a.phase,l,a.callback)}}),r.markedForDestroy?this._engine.afterFlush(()=>{r.destroy()}):e.push(i)}),this._queue=[],e.sort((i,r)=>{const s=i.transition.ast.depCount,o=r.transition.ast.depCount;return 0==s||0==o?s-o:this._engine.driver.containsElement(i.element,r.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(i=>i.element===t)||e,e}}class U5e{_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}constructor(t,e,i){this.bodyNode=t,this.driver=e,this._normalizer=i,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(r,s)=>{}}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(i=>{i.queued&&t.push(i)})}),t}createNamespace(t,e){const i=new z5e(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(i,e):(this.newHostElements.set(e,i),this.collectEnterElement(e)),this._namespaceLookup[t]=i}_balanceNamespaceList(t,e){const i=this._namespaceList,r=this.namespacesByHostElement;if(i.length-1>=0){let o=!1,a=this.driver.getParentElement(e);for(;a;){const l=r.get(a);if(l){const c=i.indexOf(l);i.splice(c+1,0,t),o=!0;break}a=this.driver.getParentElement(a)}o||i.unshift(t)}else i.push(t);return r.set(e,t),t}register(t,e){let i=this._namespaceLookup[t];return i||(i=this.createNamespace(t,e)),i}registerTrigger(t,e,i){let r=this._namespaceLookup[t];r&&r.register(e,i)&&this.totalAnimations++}destroy(t,e){if(!t)return;const i=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(i.hostElement),delete this._namespaceLookup[t];const r=this._namespaceList.indexOf(i);r>=0&&this._namespaceList.splice(r,1)}),this.afterFlushAnimationsDone(()=>i.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,i=this.statesByElement.get(t);if(i)for(let r of i.values())if(r.namespaceId){const s=this._fetchNamespace(r.namespaceId);s&&e.add(s)}return e}trigger(t,e,i,r){if(ww(e)){const s=this._fetchNamespace(t);if(s)return s.trigger(e,i,r),!0}return!1}insertNode(t,e,i,r){if(!ww(e))return;const s=e[Js];if(s&&s.setForRemoval){s.setForRemoval=!1,s.setForMove=!0;const o=this.collectedLeaveElements.indexOf(e);o>=0&&this.collectedLeaveElements.splice(o,1)}if(t){const o=this._fetchNamespace(t);o&&o.insertNode(e,i)}r&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),eo(t,GM)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),Gh(t,GM))}removeNode(t,e,i,r){if(ww(e)){const s=t?this._fetchNamespace(t):null;if(s?s.removeNode(e,r):this.markElementAsRemoved(t,e,!1,r),i){const o=this.namespacesByHostElement.get(e);o&&o.id!==t&&o.removeNode(e,r)}}else this._onRemovalComplete(e,r)}markElementAsRemoved(t,e,i,r,s){this.collectedLeaveElements.push(e),e[Js]={namespaceId:t,setForRemoval:r,hasAnimation:i,removedBeforeQueried:!1,previousTriggersValues:s}}listen(t,e,i,r,s){return ww(e)?this._fetchNamespace(t).listen(e,i,r,s):()=>{}}_buildInstruction(t,e,i,r,s){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,i,r,t.fromState.options,t.toState.options,e,s)}destroyInnerAnimations(t){let e=this.driver.query(t,uw,!0);e.forEach(i=>this.destroyActiveAnimationsForElement(i)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,FM,!0),e.forEach(i=>this.finishActiveQueriedAnimationOnElement(i)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(i=>{i.queued?i.markedForDestroy=!0:i.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(i=>i.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return rc(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t[Js];if(e&&e.setForRemoval){if(t[Js]=YY,e.namespaceId){this.destroyInnerAnimations(t);const i=this._fetchNamespace(e.namespaceId);i&&i.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}t.classList?.contains(GM)&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(i=>{this.markElementAsDisabled(i,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((i,r)=>this._balanceNamespaceList(i,r)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let i=0;i<this.collectedEnterElements.length;i++)eo(this.collectedEnterElements[i],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const i=[];try{e=this._flushAnimations(i,t)}finally{for(let r=0;r<i.length;r++)i[r]()}}else for(let i=0;i<this.collectedLeaveElements.length;i++)this.processLeaveNode(this.collectedLeaveElements[i]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(i=>i()),this._flushFns=[],this._whenQuietFns.length){const i=this._whenQuietFns;this._whenQuietFns=[],e.length?rc(e).onDone(()=>{i.forEach(r=>r())}):i.forEach(r=>r())}}reportError(t){throw function UGe(n){return new Q(3402,!1)}()}_flushAnimations(t,e){const i=new yw,r=[],s=new Map,o=[],a=new Map,l=new Map,c=new Map,d=new Set;this.disabledNodes.forEach(M=>{d.add(M);const F=this.driver.query(M,".ng-animate-queued",!0);for(let L=0;L<F.length;L++)d.add(F[L])});const u=this.bodyNode,h=Array.from(this.statesByElement.keys()),p=ZY(h,this.collectedEnterElements),f=new Map;let m=0;p.forEach((M,F)=>{const L=OM+m++;f.set(F,L),M.forEach(j=>eo(j,L))});const g=[],_=new Set,b=new Set;for(let M=0;M<this.collectedLeaveElements.length;M++){const F=this.collectedLeaveElements[M],L=F[Js];L&&L.setForRemoval&&(g.push(F),_.add(F),L.hasAnimation?this.driver.query(F,".ng-star-inserted",!0).forEach(j=>_.add(j)):b.add(F))}const y=new Map,v=ZY(h,Array.from(_));v.forEach((M,F)=>{const L=cw+m++;y.set(F,L),M.forEach(j=>eo(j,L))}),t.push(()=>{p.forEach((M,F)=>{const L=f.get(F);M.forEach(j=>Gh(j,L))}),v.forEach((M,F)=>{const L=y.get(F);M.forEach(j=>Gh(j,L))}),g.forEach(M=>{this.processLeaveNode(M)})});const x=[],w=[];for(let M=this._namespaceList.length-1;M>=0;M--)this._namespaceList[M].drainQueuedTransitions(e).forEach(L=>{const j=L.player,Z=L.element;if(x.push(j),this.collectedEnterElements.length){const Ce=Z[Js];if(Ce&&Ce.setForMove){if(Ce.previousTriggersValues&&Ce.previousTriggersValues.has(L.triggerName)){const Pe=Ce.previousTriggersValues.get(L.triggerName),Ae=this.statesByElement.get(L.element);if(Ae&&Ae.has(L.triggerName)){const Xe=Ae.get(L.triggerName);Xe.value=Pe,Ae.set(L.triggerName,Xe)}}return void j.destroy()}}const ee=!u||!this.driver.containsElement(u,Z),se=y.get(Z),re=f.get(Z),ae=this._buildInstruction(L,i,re,se,ee);if(ae.errors&&ae.errors.length)return void w.push(ae);if(ee)return j.onStart(()=>kd(Z,ae.fromStyles)),j.onDestroy(()=>ua(Z,ae.toStyles)),void r.push(j);if(L.isFallbackTransition)return j.onStart(()=>kd(Z,ae.fromStyles)),j.onDestroy(()=>ua(Z,ae.toStyles)),void r.push(j);const pe=[];ae.timelines.forEach(Ce=>{Ce.stretchStartingKeyframe=!0,this.disabledNodes.has(Ce.element)||pe.push(Ce)}),ae.timelines=pe,i.append(Z,ae.timelines),o.push({instruction:ae,player:j,element:Z}),ae.queriedElements.forEach(Ce=>xs(a,Ce,[]).push(j)),ae.preStyleProps.forEach((Ce,Pe)=>{if(Ce.size){let Ae=l.get(Pe);Ae||l.set(Pe,Ae=new Set),Ce.forEach((Xe,tt)=>Ae.add(tt))}}),ae.postStyleProps.forEach((Ce,Pe)=>{let Ae=c.get(Pe);Ae||c.set(Pe,Ae=new Set),Ce.forEach((Xe,tt)=>Ae.add(tt))})});if(w.length){const M=[];w.forEach(F=>{M.push(function HGe(n,t){return new Q(3505,!1)}())}),x.forEach(F=>F.destroy()),this.reportError(M)}const C=new Map,D=new Map;o.forEach(M=>{const F=M.element;i.has(F)&&(D.set(F,F),this._beforeAnimationBuild(M.player.namespaceId,M.instruction,C))}),r.forEach(M=>{const F=M.element;this._getPreviousPlayers(F,!1,M.namespaceId,M.triggerName,null).forEach(j=>{xs(C,F,[]).push(j),j.destroy()})});const k=g.filter(M=>JY(M,l,c)),I=new Map;XY(I,this.driver,b,c,$a).forEach(M=>{JY(M,l,c)&&k.push(M)});const $=new Map;p.forEach((M,F)=>{XY($,this.driver,new Set(M),l,KE)}),k.forEach(M=>{const F=I.get(M),L=$.get(M);I.set(M,new Map([...Array.from(F?.entries()??[]),...Array.from(L?.entries()??[])]))});const H=[],W=[],z={};o.forEach(M=>{const{element:F,player:L,instruction:j}=M;if(i.has(F)){if(d.has(F))return L.onDestroy(()=>ua(F,j.toStyles)),L.disabled=!0,L.overrideTotalTime(j.totalTime),void r.push(L);let Z=z;if(D.size>1){let se=F;const re=[];for(;se=se.parentNode;){const ae=D.get(se);if(ae){Z=ae;break}re.push(se)}re.forEach(ae=>D.set(ae,Z))}const ee=this._buildAnimation(L.namespaceId,j,C,s,$,I);if(L.setRealPlayer(ee),Z===z)H.push(L);else{const se=this.playersByElement.get(Z);se&&se.length&&(L.parentPlayer=rc(se)),r.push(L)}}else kd(F,j.fromStyles),L.onDestroy(()=>ua(F,j.toStyles)),W.push(L),d.has(F)&&r.push(L)}),W.forEach(M=>{const F=s.get(M.element);if(F&&F.length){const L=rc(F);M.setRealPlayer(L)}}),r.forEach(M=>{M.parentPlayer?M.syncPlayerEvents(M.parentPlayer):M.destroy()});for(let M=0;M<g.length;M++){const F=g[M],L=F[Js];if(Gh(F,cw),L&&L.hasAnimation)continue;let j=[];if(a.size){let ee=a.get(F);ee&&ee.length&&j.push(...ee);let se=this.driver.query(F,FM,!0);for(let re=0;re<se.length;re++){let ae=a.get(se[re]);ae&&ae.length&&j.push(...ae)}}const Z=j.filter(ee=>!ee.destroyed);Z.length?G5e(this,F,Z):this.processLeaveNode(F)}return g.length=0,H.forEach(M=>{this.players.push(M),M.onDone(()=>{M.destroy();const F=this.players.indexOf(M);this.players.splice(F,1)}),M.play()}),H}elementContainsData(t,e){let i=!1;const r=e[Js];return r&&r.setForRemoval&&(i=!0),this.playersByElement.has(e)&&(i=!0),this.playersByQueriedElement.has(e)&&(i=!0),this.statesByElement.has(e)&&(i=!0),this._fetchNamespace(t).elementContainsData(e)||i}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,i,r,s){let o=[];if(e){const a=this.playersByQueriedElement.get(t);a&&(o=a)}else{const a=this.playersByElement.get(t);if(a){const l=!s||s==Qg;a.forEach(c=>{c.queued||!l&&c.triggerName!=r||o.push(c)})}}return(i||r)&&(o=o.filter(a=>!(i&&i!=a.namespaceId||r&&r!=a.triggerName))),o}_beforeAnimationBuild(t,e,i){const s=e.element,o=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const l of e.timelines){const c=l.element,d=c!==s,u=xs(i,c,[]);this._getPreviousPlayers(c,d,o,a,e.toState).forEach(p=>{const f=p.getRealPlayer();f.beforeDestroy&&f.beforeDestroy(),p.destroy(),u.push(p)})}kd(s,e.fromStyles)}_buildAnimation(t,e,i,r,s,o){const a=e.triggerName,l=e.element,c=[],d=new Set,u=new Set,h=e.timelines.map(f=>{const m=f.element;d.add(m);const g=m[Js];if(g&&g.removedBeforeQueried)return new Yf(f.duration,f.delay);const _=m!==l,b=function q5e(n){const t=[];return QY(n,t),t}((i.get(m)||V5e).map(C=>C.getRealPlayer())).filter(C=>!!C.element&&C.element===m),y=s.get(m),v=o.get(m),x=DY(0,this._normalizer,0,f.keyframes,y,v),w=this._buildPlayer(f,x,b);if(f.subTimeline&&r&&u.add(m),_){const C=new KM(t,a,m);C.setRealPlayer(w),c.push(C)}return w});c.forEach(f=>{xs(this.playersByQueriedElement,f.element,[]).push(f),f.onDone(()=>function H5e(n,t,e){let i=n.get(t);if(i){if(i.length){const r=i.indexOf(e);i.splice(r,1)}0==i.length&&n.delete(t)}return i}(this.playersByQueriedElement,f.element,f))}),d.forEach(f=>eo(f,RY));const p=rc(h);return p.onDestroy(()=>{d.forEach(f=>Gh(f,RY)),ua(l,e.toStyles)}),u.forEach(f=>{xs(r,f,[]).push(p)}),p}_buildPlayer(t,e,i){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,i):new Yf(t.duration,t.delay)}}class KM{constructor(t,e,i){this.namespaceId=t,this.triggerName=e,this.element=i,this._player=new Yf,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,this._queuedCallbacks.forEach((e,i)=>{e.forEach(r=>IM(t,i,void 0,r))}),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){xs(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function ww(n){return n&&1===n.nodeType}function KY(n,t){const e=n.style.display;return n.style.display=t??"none",e}function XY(n,t,e,i,r){const s=[];e.forEach(l=>s.push(KY(l)));const o=[];i.forEach((l,c)=>{const d=new Map;l.forEach(u=>{const h=t.computeStyle(c,u,r);d.set(u,h),(!h||0==h.length)&&(c[Js]=B5e,o.push(c))}),n.set(c,d)});let a=0;return e.forEach(l=>KY(l,s[a++])),o}function ZY(n,t){const e=new Map;if(n.forEach(a=>e.set(a,[])),0==t.length)return e;const i=1,r=new Set(t),s=new Map;function o(a){if(!a)return i;let l=s.get(a);if(l)return l;const c=a.parentNode;return l=e.has(c)?c:r.has(c)?i:o(c),s.set(a,l),l}return t.forEach(a=>{const l=o(a);l!==i&&e.get(l).push(a)}),e}function eo(n,t){n.classList?.add(t)}function Gh(n,t){n.classList?.remove(t)}function G5e(n,t,e){rc(e).onDone(()=>n.processLeaveNode(t))}function QY(n,t){for(let e=0;e<n.length;e++){const i=n[e];i instanceof uH?QY(i.players,t):t.push(i)}}function JY(n,t,e){const i=e.get(n);if(!i)return!1;let r=t.get(n);return r?i.forEach(s=>r.add(s)):t.set(n,i),e.delete(n),!0}class Cw{constructor(t,e,i){this.bodyNode=t,this._driver=e,this._normalizer=i,this._triggerCache={},this.onRemovalComplete=(r,s)=>{},this._transitionEngine=new U5e(t,e,i),this._timelineEngine=new O5e(t,e,i),this._transitionEngine.onRemovalComplete=(r,s)=>this.onRemovalComplete(r,s)}registerTrigger(t,e,i,r,s){const o=t+"-"+r;let a=this._triggerCache[o];if(!a){const l=[],c=[],d=VM(this._driver,s,l,c);if(l.length)throw function NGe(n,t){return new Q(3404,!1)}();a=function A5e(n,t,e){return new M5e(n,t,e)}(r,d,this._normalizer),this._triggerCache[o]=a}this._transitionEngine.registerTrigger(e,r,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,i,r){this._transitionEngine.insertNode(t,e,i,r)}onRemove(t,e,i,r){this._transitionEngine.removeNode(t,e,r||!1,i)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,i,r){if("@"==i.charAt(0)){const[s,o]=SY(i);this._timelineEngine.command(s,e,o,r)}else this._transitionEngine.trigger(t,e,i,r)}listen(t,e,i,r,s){if("@"==i.charAt(0)){const[o,a]=SY(i);return this._timelineEngine.listen(o,e,a,s)}return this._transitionEngine.listen(t,e,i,r,s)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let X5e=(()=>{class n{constructor(e,i,r){this._element=e,this._startStyles=i,this._endStyles=r,this._state=0;let s=n.initialStylesByElement.get(e);s||n.initialStylesByElement.set(e,s=new Map),this._initialStyles=s}start(){this._state<1&&(this._startStyles&&ua(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(ua(this._element,this._initialStyles),this._endStyles&&(ua(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(kd(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(kd(this._element,this._endStyles),this._endStyles=null),ua(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function XM(n){let t=null;return n.forEach((e,i)=>{(function Z5e(n){return"display"===n||"position"===n})(i)&&(t=t||new Map,t.set(i,e))}),t}class eK{constructor(t,e,i,r){this.element=t,this.keyframes=e,this.options=i,this._specialStyles=r,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=i.duration,this._delay=i.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:new Map,this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(t){const e=[];return t.forEach(i=>{e.push(Object.fromEntries(i))}),e}_triggerWebAnimation(t,e,i){return t.animate(this._convertKeyframesToObject(e),i)}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t=new Map;this.hasStarted()&&this._finalKeyframe.forEach((i,r)=>{"offset"!==r&&t.set(r,this._finished?i:VY(this.element,r))}),this.currentSnapshot=t}triggerCallback(t){const e="start"===t?this._onStartFns:this._onDoneFns;e.forEach(i=>i()),e.length=0}}class Q5e{validateStyleProperty(t){return!0}validateAnimatableStyleProperty(t){return!0}matchesElement(t,e){return!1}containsElement(t,e){return TY(t,e)}getParentElement(t){return NM(t)}query(t,e,i){return AY(t,e,i)}computeStyle(t,e,i){return window.getComputedStyle(t)[e]}animate(t,e,i,r,s,o=[]){const l={duration:i,delay:r,fill:0==r?"both":"forwards"};s&&(l.easing=s);const c=new Map,d=o.filter(p=>p instanceof eK);(function n5e(n,t){return 0===n||0===t})(i,r)&&d.forEach(p=>{p.currentSnapshot.forEach((f,m)=>c.set(m,f))});let u=function QGe(n){return n.length?n[0]instanceof Map?n:n.map(t=>OY(t)):[]}(e).map(p=>sc(p));u=function i5e(n,t,e){if(e.size&&t.length){let i=t[0],r=[];if(e.forEach((s,o)=>{i.has(o)||r.push(o),i.set(o,s)}),r.length)for(let s=1;s<t.length;s++){let o=t[s];r.forEach(a=>o.set(a,VY(n,a)))}}return t}(t,u,c);const h=function K5e(n,t){let e=null,i=null;return Array.isArray(t)&&t.length?(e=XM(t[0]),t.length>1&&(i=XM(t[t.length-1]))):t instanceof Map&&(e=XM(t)),e||i?new X5e(n,e,i):null}(t,u);return new eK(t,u,l,h)}}let J5e=(()=>{class n extends rH{constructor(e,i){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(i.body,{id:"0",encapsulation:no.None,styles:[],data:{animation:[]}})}build(e){const i=this._nextAnimationId.toString();this._nextAnimationId++;const r=Array.isArray(e)?oH(e):e;return tK(this._renderer,null,i,"register",[r]),new e8e(i,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(Y(_p),Y(bt))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();class e8e extends Tye{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new t8e(this._id,t,e||{},this._renderer)}}class t8e{constructor(t,e,i,r){this.id=t,this.element=e,this._renderer=r,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",i)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return tK(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){return this._renderer.engine.players[+this.id]?.getPosition()??0}}function tK(n,t,e,i,r){return n.setProperty(t,`@@${e}:${i}`,r)}const nK="@.disabled";let n8e=(()=>{class n{constructor(e,i,r){this.delegate=e,this.engine=i,this._zone=r,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),i.onRemovalComplete=(s,o)=>{const a=o?.parentNode(s);a&&o.removeChild(a,s)}}createRenderer(e,i){const s=this.delegate.createRenderer(e,i);if(!(e&&i&&i.data&&i.data.animation)){let d=this._rendererCache.get(s);return d||(d=new iK("",s,this.engine,()=>this._rendererCache.delete(s)),this._rendererCache.set(s,d)),d}const o=i.id,a=i.id+"-"+this._currentId;this._currentId++,this.engine.register(a,e);const l=d=>{Array.isArray(d)?d.forEach(l):this.engine.registerTrigger(o,a,e,d.name,d)};return i.data.animation.forEach(l),new i8e(this,a,s,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,i,r){e>=0&&e<this._microtaskId?this._zone.run(()=>i(r)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(s=>{const[o,a]=s;o(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([i,r]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(Y(_p),Y(Cw),Y(Qe))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();class iK{constructor(t,e,i,r){this.namespaceId=t,this.delegate=e,this.engine=i,this._onDestroy=r,this.destroyNode=this.delegate.destroyNode?s=>e.destroyNode(s):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy(),this._onDestroy?.()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,i,r=!0){this.delegate.insertBefore(t,e,i),this.engine.onInsert(this.namespaceId,e,t,r)}removeChild(t,e,i){this.engine.onRemove(this.namespaceId,e,this.delegate,i)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,i,r){this.delegate.setAttribute(t,e,i,r)}removeAttribute(t,e,i){this.delegate.removeAttribute(t,e,i)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,i,r){this.delegate.setStyle(t,e,i,r)}removeStyle(t,e,i){this.delegate.removeStyle(t,e,i)}setProperty(t,e,i){"@"==e.charAt(0)&&e==nK?this.disableAnimations(t,!!i):this.delegate.setProperty(t,e,i)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,i){return this.delegate.listen(t,e,i)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class i8e extends iK{constructor(t,e,i,r,s){super(e,i,r,s),this.factory=t,this.namespaceId=e}setProperty(t,e,i){"@"==e.charAt(0)?"."==e.charAt(1)&&e==nK?this.disableAnimations(t,i=void 0===i||!!i):this.engine.process(this.namespaceId,t,e.slice(1),i):this.delegate.setProperty(t,e,i)}listen(t,e,i){if("@"==e.charAt(0)){const r=function r8e(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let s=e.slice(1),o="";return"@"!=s.charAt(0)&&([s,o]=function s8e(n){const t=n.indexOf(".");return[n.substring(0,t),n.slice(t+1)]}(s)),this.engine.listen(this.namespaceId,r,s,o,a=>{this.factory.scheduleListenerCallback(a._data||-1,i,a)})}return this.delegate.listen(t,e,i)}}let o8e=(()=>{class n extends Cw{constructor(e,i,r,s){super(e.body,i,r)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(Y(bt),Y(RM),Y(jM),Y(gu))},n.\u0275prov=me({token:n,factory:n.\u0275fac}),n})();const rK=[{provide:rH,useClass:J5e},{provide:jM,useFactory:function a8e(){return new k5e}},{provide:Cw,useClass:o8e},{provide:_p,useFactory:function l8e(n,t,e){return new n8e(n,t,e)},deps:[Mb,Cw,Qe]}],ZM=[{provide:RM,useFactory:()=>new Q5e},{provide:Da,useValue:"BrowserAnimations"},...rK],sK=[{provide:RM,useClass:MY},{provide:Da,useValue:"NoopAnimations"},...rK];let c8e=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?sK:ZM}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ut({type:n}),n.\u0275inj=at({providers:ZM,imports:[qL]}),n})();class qh{constructor(){this.isDataFetching=!1,this.isDataFetchingSbj=new dt}getIsDataFetchingStatus(){return this.isDataFetching}setIsDataFetchingStatus(t){this.isDataFetching=t,this.isDataFetchingSbj.next(t)}}function d8e(n,t){if(1&n&&(kt(0,"div",1)(1,"div",2)(2,"div",3),Ci(3,"div")(4,"div")(5,"div")(6,"div")(7,"div")(8,"div")(9,"div")(10,"div")(11,"div")(12,"div")(13,"div")(14,"div"),Lt()(),kt(15,"div",4),as(16),Lt()()),2&n){const e=$o();xi(16),yD(e.message)}}qh.\u0275fac=function(t){return new(t||qh)},qh.\u0275prov=me({token:qh,factory:qh.\u0275fac,providedIn:"root"});class Jg{constructor(t){this.appMonitoringService=t,this.message="Please wait...",this.showSpinner=!1,this.isDataFetchingSubs=new U}ngOnInit(){this.showSpinner=this.appMonitoringService.getIsDataFetchingStatus(),this.isDataFetchingSubs=this.appMonitoringService.isDataFetchingSbj.subscribe({next:t=>{this.showSpinner=t}})}ngOnDestroy(){this.isDataFetchingSubs.unsubscribe()}}Jg.\u0275fac=function(t){return new(t||Jg)(V(qh))},Jg.\u0275cmp=bi({type:Jg,selectors:[["app-loading-spinner"]],inputs:{message:"message"},decls:1,vars:1,consts:[["class","spinner-container",4,"ngIf"],[1,"spinner-container"],[1,"spinner-body"],[1,"spinner-body__content"],[1,"spinner-body__message"]],template:function(t,e){1&t&&wi(0,d8e,17,1,"div",0),2&t&&ai("ngIf",e.showSpinner)},dependencies:[fS],styles:[".spinner-container[_ngcontent-%COMP%]{position:absolute;width:100vw;height:100vh;background-color:#c8c7c7f3;text-align:center;z-index:9999}.spinner-body[_ngcontent-%COMP%]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:200px;height:200px;display:inline-block;overflow:hidden}.spinner-body__content[_ngcontent-%COMP%]{width:100%;height:100%;position:relative;transform:translateZ(0) scale(1);-webkit-backface-visibility:hidden;backface-visibility:hidden;transform-origin:0 0}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{left:94px;top:48px;position:absolute;animation:_ngcontent-%COMP%_spinner-content linear 1s infinite;background:#4e5658;width:12px;height:24px;border-radius:6px/12px;transform-origin:6px 52px;box-sizing:content-box}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(1){transform:rotate(0);animation-delay:-.9166666667s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(2){transform:rotate(30deg);animation-delay:-.8333333333s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(3){transform:rotate(60deg);animation-delay:-.75s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(4){transform:rotate(90deg);animation-delay:-.6666666667s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(5){transform:rotate(120deg);animation-delay:-.5833333333s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(6){transform:rotate(150deg);animation-delay:-.5s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(7){transform:rotate(180deg);animation-delay:-.4166666667s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(8){transform:rotate(210deg);animation-delay:-.3333333333s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(9){transform:rotate(240deg);animation-delay:-.25s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(10){transform:rotate(270deg);animation-delay:-.1666666667s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(11){transform:rotate(300deg);animation-delay:-.0833333333s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__content[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(12){transform:rotate(330deg);animation-delay:0s;background:#4e5658;box-shadow:2px 2px 12px #00000074}.spinner-body__message[_ngcontent-%COMP%]{position:absolute;top:65%;left:50%;transform:translate(-50%,-50%);text-align:center;color:#c8c7c7f3;font-size:2rem;padding:1rem;border-radius:.375rem;text-shadow:1px 1px 2px #000000,-1px -1px 2px #000000,5px 5px 15px #4e5658}@keyframes _ngcontent-%COMP%_spinner-content{0%{opacity:1}to{opacity:0}}"]});class e_{}e_.\u0275fac=function(t){return new(t||e_)},e_.\u0275cmp=bi({type:e_,selectors:[["app-root"]],decls:2,vars:0,template:function(t,e){1&t&&Ci(0,"app-loading-spinner")(1,"router-outlet")},dependencies:[OE,Jg]});class Yh{}Yh.\u0275fac=function(t){return new(t||Yh)},Yh.\u0275mod=ut({type:Yh,bootstrap:[e_]}),Yh.\u0275inj=at({imports:[qL,zh,c8e,B$,Oae,Fae,Wh,Gge]}),mre().bootstrapModule(Yh).catch(n=>console.error(n))},658:It=>{It.exports=fe;var Dt=null;try{Dt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function fe(J,T,ve){this.low=0|J,this.high=0|T,this.unsigned=!!ve}function Ue(J){return!0===(J&&J.__isLong__)}Object.defineProperty(fe.prototype,"__isLong__",{value:!0}),fe.isLong=Ue;var si={},We={};function xn(J,T){var ve,Be,St;return T?(St=0<=(J>>>=0)&&J<256)&&(Be=We[J])?Be:(ve=Ve(J,(0|J)<0?-1:0,!0),St&&(We[J]=ve),ve):(St=-128<=(J|=0)&&J<128)&&(Be=si[J])?Be:(ve=Ve(J,J<0?-1:0,!1),St&&(si[J]=ve),ve)}function ke(J,T){if(isNaN(J))return T?Fi:qt;if(T){if(J<0)return Fi;if(J>=de)return Ot}else{if(J<=-Ie)return jt;if(J+1>=Ie)return gt}return J<0?ke(-J,T).neg():Ve(J%te|0,J/te|0,T)}function Ve(J,T,ve){return new fe(J,T,ve)}fe.fromInt=xn,fe.fromNumber=ke,fe.fromBits=Ve;var ot=Math.pow;function Se(J,T,ve){if(0===J.length)throw Error("empty string");if("NaN"===J||"Infinity"===J||"+Infinity"===J||"-Infinity"===J)return qt;if("number"==typeof T?(ve=T,T=!1):T=!!T,(ve=ve||10)<2||36<ve)throw RangeError("radix");var Be;if((Be=J.indexOf("-"))>0)throw Error("interior hyphen");if(0===Be)return Se(J.substring(1),T,ve).neg();for(var St=ke(ot(ve,8)),wt=qt,zt=0;zt<J.length;zt+=8){var Qn=Math.min(8,J.length-zt),zn=parseInt(J.substring(zt,zt+Qn),ve);if(Qn<8){var wn=ke(ot(ve,Qn));wt=wt.mul(wn).add(ke(zn))}else wt=(wt=wt.mul(St)).add(ke(zn))}return wt.unsigned=T,wt}function U(J,T){return"number"==typeof J?ke(J,T):"string"==typeof J?Se(J,T):Ve(J.low,J.high,"boolean"==typeof T?T:J.unsigned)}fe.fromString=Se,fe.fromValue=U;var te=4294967296,de=te*te,Ie=de/2,Oe=xn(1<<24),qt=xn(0);fe.ZERO=qt;var Fi=xn(0,!0);fe.UZERO=Fi;var _i=xn(1);fe.ONE=_i;var Ao=xn(1,!0);fe.UONE=Ao;var Qr=xn(-1);fe.NEG_ONE=Qr;var gt=Ve(-1,2147483647,!1);fe.MAX_VALUE=gt;var Ot=Ve(-1,-1,!0);fe.MAX_UNSIGNED_VALUE=Ot;var jt=Ve(0,-2147483648,!1);fe.MIN_VALUE=jt;var le=fe.prototype;le.toInt=function(){return this.unsigned?this.low>>>0:this.low},le.toNumber=function(){return this.unsigned?(this.high>>>0)*te+(this.low>>>0):this.high*te+(this.low>>>0)},le.toString=function(T){if((T=T||10)<2||36<T)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(jt)){var ve=ke(T),Be=this.div(ve),St=Be.mul(ve).sub(this);return Be.toString(T)+St.toInt().toString(T)}return"-"+this.neg().toString(T)}for(var wt=ke(ot(T,6),this.unsigned),zt=this,Qn="";;){var zn=zt.div(wt),Un=(zt.sub(zn.mul(wt)).toInt()>>>0).toString(T);if((zt=zn).isZero())return Un+Qn;for(;Un.length<6;)Un="0"+Un;Qn=""+Un+Qn}},le.getHighBits=function(){return this.high},le.getHighBitsUnsigned=function(){return this.high>>>0},le.getLowBits=function(){return this.low},le.getLowBitsUnsigned=function(){return this.low>>>0},le.getNumBitsAbs=function(){if(this.isNegative())return this.eq(jt)?64:this.neg().getNumBitsAbs();for(var T=0!=this.high?this.high:this.low,ve=31;ve>0&&!(T&1<<ve);ve--);return 0!=this.high?ve+33:ve+1},le.isZero=function(){return 0===this.high&&0===this.low},le.eqz=le.isZero,le.isNegative=function(){return!this.unsigned&&this.high<0},le.isPositive=function(){return this.unsigned||this.high>=0},le.isOdd=function(){return 1==(1&this.low)},le.isEven=function(){return 0==(1&this.low)},le.equals=function(T){return Ue(T)||(T=U(T)),(this.unsigned===T.unsigned||this.high>>>31!=1||T.high>>>31!=1)&&this.high===T.high&&this.low===T.low},le.eq=le.equals,le.notEquals=function(T){return!this.eq(T)},le.neq=le.notEquals,le.ne=le.notEquals,le.lessThan=function(T){return this.comp(T)<0},le.lt=le.lessThan,le.lessThanOrEqual=function(T){return this.comp(T)<=0},le.lte=le.lessThanOrEqual,le.le=le.lessThanOrEqual,le.greaterThan=function(T){return this.comp(T)>0},le.gt=le.greaterThan,le.greaterThanOrEqual=function(T){return this.comp(T)>=0},le.gte=le.greaterThanOrEqual,le.ge=le.greaterThanOrEqual,le.compare=function(T){if(Ue(T)||(T=U(T)),this.eq(T))return 0;var ve=this.isNegative(),Be=T.isNegative();return ve&&!Be?-1:!ve&&Be?1:this.unsigned?T.high>>>0>this.high>>>0||T.high===this.high&&T.low>>>0>this.low>>>0?-1:1:this.sub(T).isNegative()?-1:1},le.comp=le.compare,le.negate=function(){return!this.unsigned&&this.eq(jt)?jt:this.not().add(_i)},le.neg=le.negate,le.add=function(T){Ue(T)||(T=U(T));var Un=0,wr=0,Ze=0,er=0;return Ze+=(er+=(65535&this.low)+(65535&T.low))>>>16,wr+=(Ze+=(this.low>>>16)+(T.low>>>16))>>>16,Un+=(wr+=(65535&this.high)+(65535&T.high))>>>16,Un+=(this.high>>>16)+(T.high>>>16),Ve((Ze&=65535)<<16|(er&=65535),(Un&=65535)<<16|(wr&=65535),this.unsigned)},le.subtract=function(T){return Ue(T)||(T=U(T)),this.add(T.neg())},le.sub=le.subtract,le.multiply=function(T){if(this.isZero())return qt;if(Ue(T)||(T=U(T)),Dt)return Ve(Dt.mul(this.low,this.high,T.low,T.high),Dt.get_high(),this.unsigned);if(T.isZero())return qt;if(this.eq(jt))return T.isOdd()?jt:qt;if(T.eq(jt))return this.isOdd()?jt:qt;if(this.isNegative())return T.isNegative()?this.neg().mul(T.neg()):this.neg().mul(T).neg();if(T.isNegative())return this.mul(T.neg()).neg();if(this.lt(Oe)&&T.lt(Oe))return ke(this.toNumber()*T.toNumber(),this.unsigned);var St=65535&this.high,wt=this.low>>>16,zt=65535&this.low,zn=65535&T.high,wn=T.low>>>16,Un=65535&T.low,wr=0,Ze=0,er=0,Td=0;return er+=(Td+=zt*Un)>>>16,Ze+=(er+=wt*Un)>>>16,er&=65535,Ze+=(er+=zt*wn)>>>16,wr+=(Ze+=St*Un)>>>16,Ze&=65535,wr+=(Ze+=wt*wn)>>>16,Ze&=65535,wr+=(Ze+=zt*zn)>>>16,wr+=(this.high>>>16)*Un+St*wn+wt*zn+zt*(T.high>>>16),Ve((er&=65535)<<16|(Td&=65535),(wr&=65535)<<16|(Ze&=65535),this.unsigned)},le.mul=le.multiply,le.divide=function(T){if(Ue(T)||(T=U(T)),T.isZero())throw Error("division by zero");var Be,St,wt;if(Dt)return this.unsigned||-2147483648!==this.high||-1!==T.low||-1!==T.high?Ve((this.unsigned?Dt.div_u:Dt.div_s)(this.low,this.high,T.low,T.high),Dt.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?Fi:qt;if(this.unsigned){if(T.unsigned||(T=T.toUnsigned()),T.gt(this))return Fi;if(T.gt(this.shru(1)))return Ao;wt=Fi}else{if(this.eq(jt))return T.eq(_i)||T.eq(Qr)?jt:T.eq(jt)?_i:(Be=this.shr(1).div(T).shl(1)).eq(qt)?T.isNegative()?_i:Qr:(St=this.sub(T.mul(Be)),wt=Be.add(St.div(T)));if(T.eq(jt))return this.unsigned?Fi:qt;if(this.isNegative())return T.isNegative()?this.neg().div(T.neg()):this.neg().div(T).neg();if(T.isNegative())return this.div(T.neg()).neg();wt=qt}for(St=this;St.gte(T);){Be=Math.max(1,Math.floor(St.toNumber()/T.toNumber()));for(var Qn=Math.ceil(Math.log(Be)/Math.LN2),zn=Qn<=48?1:ot(2,Qn-48),wn=ke(Be),Un=wn.mul(T);Un.isNegative()||Un.gt(St);)Un=(wn=ke(Be-=zn,this.unsigned)).mul(T);wn.isZero()&&(wn=_i),wt=wt.add(wn),St=St.sub(Un)}return wt},le.div=le.divide,le.modulo=function(T){return Ue(T)||(T=U(T)),Dt?Ve((this.unsigned?Dt.rem_u:Dt.rem_s)(this.low,this.high,T.low,T.high),Dt.get_high(),this.unsigned):this.sub(this.div(T).mul(T))},le.mod=le.modulo,le.rem=le.modulo,le.not=function(){return Ve(~this.low,~this.high,this.unsigned)},le.and=function(T){return Ue(T)||(T=U(T)),Ve(this.low&T.low,this.high&T.high,this.unsigned)},le.or=function(T){return Ue(T)||(T=U(T)),Ve(this.low|T.low,this.high|T.high,this.unsigned)},le.xor=function(T){return Ue(T)||(T=U(T)),Ve(this.low^T.low,this.high^T.high,this.unsigned)},le.shiftLeft=function(T){return Ue(T)&&(T=T.toInt()),0==(T&=63)?this:T<32?Ve(this.low<<T,this.high<<T|this.low>>>32-T,this.unsigned):Ve(0,this.low<<T-32,this.unsigned)},le.shl=le.shiftLeft,le.shiftRight=function(T){return Ue(T)&&(T=T.toInt()),0==(T&=63)?this:T<32?Ve(this.low>>>T|this.high<<32-T,this.high>>T,this.unsigned):Ve(this.high>>T-32,this.high>=0?0:-1,this.unsigned)},le.shr=le.shiftRight,le.shiftRightUnsigned=function(T){if(Ue(T)&&(T=T.toInt()),0==(T&=63))return this;var ve=this.high;return T<32?Ve(this.low>>>T|ve<<32-T,ve>>>T,this.unsigned):Ve(32===T?ve:ve>>>T-32,0,this.unsigned)},le.shru=le.shiftRightUnsigned,le.shr_u=le.shiftRightUnsigned,le.toSigned=function(){return this.unsigned?Ve(this.low,this.high,!1):this},le.toUnsigned=function(){return this.unsigned?this:Ve(this.low,this.high,!0)},le.toBytes=function(T){return T?this.toBytesLE():this.toBytesBE()},le.toBytesLE=function(){var T=this.high,ve=this.low;return[255&ve,ve>>>8&255,ve>>>16&255,ve>>>24,255&T,T>>>8&255,T>>>16&255,T>>>24]},le.toBytesBE=function(){var T=this.high,ve=this.low;return[T>>>24,T>>>16&255,T>>>8&255,255&T,ve>>>24,ve>>>16&255,ve>>>8&255,255&ve]},fe.fromBytes=function(T,ve,Be){return Be?fe.fromBytesLE(T,ve):fe.fromBytesBE(T,ve)},fe.fromBytesLE=function(T,ve){return new fe(T[0]|T[1]<<8|T[2]<<16|T[3]<<24,T[4]|T[5]<<8|T[6]<<16|T[7]<<24,ve)},fe.fromBytesBE=function(T,ve){return new fe(T[4]<<24|T[5]<<16|T[6]<<8|T[7],T[0]<<24|T[1]<<16|T[2]<<8|T[3],ve)}},340:(It,Dt,fe)=>{var Ue=fe(471),si=fe(992),We=fe(657),xn=fe(583),ke=fe(929),Ve=fe(83),ot=fe(818);ot.alea=Ue,ot.xor128=si,ot.xorwow=We,ot.xorshift7=xn,ot.xor4096=ke,ot.tychei=Ve,It.exports=ot},471:function(It,Dt,fe){var Ue;!function(si,We,xn){function ke(U){var he=this,_e=function Se(){var U=4022871197;return function(_e){_e=String(_e);for(var te=0;te<_e.length;te++){var de=.02519603282416938*(U+=_e.charCodeAt(te));de-=U=de>>>0,U=(de*=U)>>>0,U+=4294967296*(de-=U)}return 2.3283064365386963e-10*(U>>>0)}}();he.next=function(){var te=2091639*he.s0+2.3283064365386963e-10*he.c;return he.s0=he.s1,he.s1=he.s2,he.s2=te-(he.c=0|te)},he.c=1,he.s0=_e(" "),he.s1=_e(" "),he.s2=_e(" "),he.s0-=_e(U),he.s0<0&&(he.s0+=1),he.s1-=_e(U),he.s1<0&&(he.s1+=1),he.s2-=_e(U),he.s2<0&&(he.s2+=1),_e=null}function Ve(U,he){return he.c=U.c,he.s0=U.s0,he.s1=U.s1,he.s2=U.s2,he}function ot(U,he){var _e=new ke(U),te=he&&he.state,de=_e.next;return de.int32=function(){return 4294967296*_e.next()|0},de.double=function(){return de()+11102230246251565e-32*(2097152*de()|0)},de.quick=de,te&&("object"==typeof te&&Ve(te,_e),de.state=function(){return Ve(_e,{})}),de}We&&We.exports?We.exports=ot:fe.amdD&&fe.amdO?void 0!==(Ue=function(){return ot}.call(Dt,fe,Dt,We))&&(We.exports=Ue):this.alea=ot}(0,It=fe.nmd(It))},83:function(It,Dt,fe){var Ue;!function(si,We,xn){function ke(Se){var U=this,he="";U.next=function(){var te=U.b,de=U.c,Ie=U.d,Oe=U.a;return te=te<<25^te>>>7^de,de=de-Ie|0,Ie=Ie<<24^Ie>>>8^Oe,Oe=Oe-te|0,U.b=te=te<<20^te>>>12^de,U.c=de=de-Ie|0,U.d=Ie<<16^de>>>16^Oe,U.a=Oe-te|0},U.a=0,U.b=0,U.c=-1640531527,U.d=1367130551,Se===Math.floor(Se)?(U.a=Se/4294967296|0,U.b=0|Se):he+=Se;for(var _e=0;_e<he.length+20;_e++)U.b^=0|he.charCodeAt(_e),U.next()}function Ve(Se,U){return U.a=Se.a,U.b=Se.b,U.c=Se.c,U.d=Se.d,U}function ot(Se,U){var he=new ke(Se),_e=U&&U.state,te=function(){return(he.next()>>>0)/4294967296};return te.double=function(){do{var Oe=((he.next()>>>11)+(he.next()>>>0)/4294967296)/(1<<21)}while(0===Oe);return Oe},te.int32=he.next,te.quick=te,_e&&("object"==typeof _e&&Ve(_e,he),te.state=function(){return Ve(he,{})}),te}We&&We.exports?We.exports=ot:fe.amdD&&fe.amdO?void 0!==(Ue=function(){return ot}.call(Dt,fe,Dt,We))&&(We.exports=Ue):this.tychei=ot}(0,It=fe.nmd(It))},992:function(It,Dt,fe){var Ue;!function(si,We,xn){function ke(Se){var U=this,he="";U.x=0,U.y=0,U.z=0,U.w=0,U.next=function(){var te=U.x^U.x<<11;return U.x=U.y,U.y=U.z,U.z=U.w,U.w^=U.w>>>19^te^te>>>8},Se===(0|Se)?U.x=Se:he+=Se;for(var _e=0;_e<he.length+64;_e++)U.x^=0|he.charCodeAt(_e),U.next()}function Ve(Se,U){return U.x=Se.x,U.y=Se.y,U.z=Se.z,U.w=Se.w,U}function ot(Se,U){var he=new ke(Se),_e=U&&U.state,te=function(){return(he.next()>>>0)/4294967296};return te.double=function(){do{var Oe=((he.next()>>>11)+(he.next()>>>0)/4294967296)/(1<<21)}while(0===Oe);return Oe},te.int32=he.next,te.quick=te,_e&&("object"==typeof _e&&Ve(_e,he),te.state=function(){return Ve(he,{})}),te}We&&We.exports?We.exports=ot:fe.amdD&&fe.amdO?void 0!==(Ue=function(){return ot}.call(Dt,fe,Dt,We))&&(We.exports=Ue):this.xor128=ot}(0,It=fe.nmd(It))},929:function(It,Dt,fe){var Ue;!function(si,We,xn){function ke(Se){var U=this;U.next=function(){var Ie,Oe,_e=U.w,te=U.X,de=U.i;return U.w=_e=_e+1640531527|0,Oe=te[de+34&127],Ie=te[de=de+1&127],Oe^=Oe<<13,Ie^=Ie<<17,Oe=te[de]=(Oe^=Oe>>>15)^(Ie^=Ie>>>12),U.i=de,Oe+(_e^_e>>>16)|0},function he(_e,te){var de,Ie,Oe,qt,Fi,_i=[],Ao=128;for(te===(0|te)?(Ie=te,te=null):(te+="\0",Ie=0,Ao=Math.max(Ao,te.length)),Oe=0,qt=-32;qt<Ao;++qt)te&&(Ie^=te.charCodeAt((qt+32)%te.length)),0===qt&&(Fi=Ie),Ie^=Ie<<10,Ie^=Ie>>>15,Ie^=Ie<<4,Ie^=Ie>>>13,qt>=0&&(Oe=0==(de=_i[127&qt]^=Ie+(Fi=Fi+1640531527|0))?Oe+1:0);for(Oe>=128&&(_i[127&(te&&te.length||0)]=-1),Oe=127,qt=512;qt>0;--qt)Ie=_i[Oe+34&127],de=_i[Oe=Oe+1&127],Ie^=Ie<<13,de^=de<<17,_i[Oe]=(Ie^=Ie>>>15)^(de^=de>>>12);_e.w=Fi,_e.X=_i,_e.i=Oe}(U,Se)}function Ve(Se,U){return U.i=Se.i,U.w=Se.w,U.X=Se.X.slice(),U}function ot(Se,U){null==Se&&(Se=+new Date);var he=new ke(Se),_e=U&&U.state,te=function(){return(he.next()>>>0)/4294967296};return te.double=function(){do{var Oe=((he.next()>>>11)+(he.next()>>>0)/4294967296)/(1<<21)}while(0===Oe);return Oe},te.int32=he.next,te.quick=te,_e&&(_e.X&&Ve(_e,he),te.state=function(){return Ve(he,{})}),te}We&&We.exports?We.exports=ot:fe.amdD&&fe.amdO?void 0!==(Ue=function(){return ot}.call(Dt,fe,Dt,We))&&(We.exports=Ue):this.xor4096=ot}(0,It=fe.nmd(It))},583:function(It,Dt,fe){var Ue;!function(si,We,xn){function ke(Se){var U=this;U.next=function(){var de,Ie,_e=U.x,te=U.i;return de=_e[te],Ie=(de^=de>>>7)^de<<24,Ie^=(de=_e[te+1&7])^de>>>10,Ie^=(de=_e[te+3&7])^de>>>3,Ie^=(de=_e[te+4&7])^de<<7,de=_e[te+7&7],_e[te]=Ie^=(de^=de<<13)^de<<9,U.i=te+1&7,Ie},function he(_e,te){var de,Oe=[];if(te===(0|te))Oe[0]=te;else for(te=""+te,de=0;de<te.length;++de)Oe[7&de]=Oe[7&de]<<15^te.charCodeAt(de)+Oe[de+1&7]<<13;for(;Oe.length<8;)Oe.push(0);for(de=0;de<8&&0===Oe[de];++de);for(8==de&&(Oe[7]=-1),_e.x=Oe,_e.i=0,de=256;de>0;--de)_e.next()}(U,Se)}function Ve(Se,U){return U.x=Se.x.slice(),U.i=Se.i,U}function ot(Se,U){null==Se&&(Se=+new Date);var he=new ke(Se),_e=U&&U.state,te=function(){return(he.next()>>>0)/4294967296};return te.double=function(){do{var Oe=((he.next()>>>11)+(he.next()>>>0)/4294967296)/(1<<21)}while(0===Oe);return Oe},te.int32=he.next,te.quick=te,_e&&(_e.x&&Ve(_e,he),te.state=function(){return Ve(he,{})}),te}We&&We.exports?We.exports=ot:fe.amdD&&fe.amdO?void 0!==(Ue=function(){return ot}.call(Dt,fe,Dt,We))&&(We.exports=Ue):this.xorshift7=ot}(0,It=fe.nmd(It))},657:function(It,Dt,fe){var Ue;!function(si,We,xn){function ke(Se){var U=this,he="";U.next=function(){var te=U.x^U.x>>>2;return U.x=U.y,U.y=U.z,U.z=U.w,U.w=U.v,(U.d=U.d+362437|0)+(U.v=U.v^U.v<<4^te^te<<1)|0},U.x=0,U.y=0,U.z=0,U.w=0,U.v=0,Se===(0|Se)?U.x=Se:he+=Se;for(var _e=0;_e<he.length+64;_e++)U.x^=0|he.charCodeAt(_e),_e==he.length&&(U.d=U.x<<10^U.x>>>4),U.next()}function Ve(Se,U){return U.x=Se.x,U.y=Se.y,U.z=Se.z,U.w=Se.w,U.v=Se.v,U.d=Se.d,U}function ot(Se,U){var he=new ke(Se),_e=U&&U.state,te=function(){return(he.next()>>>0)/4294967296};return te.double=function(){do{var Oe=((he.next()>>>11)+(he.next()>>>0)/4294967296)/(1<<21)}while(0===Oe);return Oe},te.int32=he.next,te.quick=te,_e&&("object"==typeof _e&&Ve(_e,he),te.state=function(){return Ve(he,{})}),te}We&&We.exports?We.exports=ot:fe.amdD&&fe.amdO?void 0!==(Ue=function(){return ot}.call(Dt,fe,Dt,We))&&(We.exports=Ue):this.xorwow=ot}(0,It=fe.nmd(It))},818:function(It,Dt,fe){var Ue;!function(si,We,xn){var de,ke=256,Ve=6,Se="random",U=xn.pow(ke,Ve),he=xn.pow(2,52),_e=2*he,te=ke-1;function Ie(gt,Ot,jt){var le=[],J=_i(Fi((Ot=1==Ot?{entropy:!0}:Ot||{}).entropy?[gt,Qr(We)]:gt??function Ao(){try{var gt;return de&&(gt=de.randomBytes)?gt=gt(ke):(gt=new Uint8Array(ke),(si.crypto||si.msCrypto).getRandomValues(gt)),Qr(gt)}catch{var Ot=si.navigator,jt=Ot&&Ot.plugins;return[+new Date,si,jt,si.screen,Qr(We)]}}(),3),le),T=new Oe(le),ve=function(){for(var Be=T.g(Ve),St=U,wt=0;Be<he;)Be=(Be+wt)*ke,St*=ke,wt=T.g(1);for(;Be>=_e;)Be/=2,St/=2,wt>>>=1;return(Be+wt)/St};return ve.int32=function(){return 0|T.g(4)},ve.quick=function(){return T.g(4)/4294967296},ve.double=ve,_i(Qr(T.S),We),(Ot.pass||jt||function(Be,St,wt,zt){return zt&&(zt.S&&qt(zt,T),Be.state=function(){return qt(T,{})}),wt?(xn[Se]=Be,St):Be})(ve,J,"global"in Ot?Ot.global:this==xn,Ot.state)}function Oe(gt){var Ot,jt=gt.length,le=this,J=0,T=le.i=le.j=0,ve=le.S=[];for(jt||(gt=[jt++]);J<ke;)ve[J]=J++;for(J=0;J<ke;J++)ve[J]=ve[T=te&T+gt[J%jt]+(Ot=ve[J])],ve[T]=Ot;(le.g=function(Be){for(var St,wt=0,zt=le.i,Qn=le.j,zn=le.S;Be--;)St=zn[zt=te&zt+1],wt=wt*ke+zn[te&(zn[zt]=zn[Qn=te&Qn+St])+(zn[Qn]=St)];return le.i=zt,le.j=Qn,wt})(ke)}function qt(gt,Ot){return Ot.i=gt.i,Ot.j=gt.j,Ot.S=gt.S.slice(),Ot}function Fi(gt,Ot){var J,jt=[],le=typeof gt;if(Ot&&"object"==le)for(J in gt)try{jt.push(Fi(gt[J],Ot-1))}catch{}return jt.length?jt:"string"==le?gt:gt+"\0"}function _i(gt,Ot){for(var le,jt=gt+"",J=0;J<jt.length;)Ot[te&J]=te&(le^=19*Ot[te&J])+jt.charCodeAt(J++);return Qr(Ot)}function Qr(gt){return String.fromCharCode.apply(0,gt)}if(_i(xn.random(),We),It.exports){It.exports=Ie;try{de=fe(42)}catch{}}else void 0!==(Ue=function(){return Ie}.call(Dt,fe,Dt,It))&&(It.exports=Ue)}(typeof self<"u"?self:this,[],Math)},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{}},It=>{It(It.s=335)}]);